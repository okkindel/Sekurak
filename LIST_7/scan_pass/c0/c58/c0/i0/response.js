var res = {'data':'HTTP/1.1 200 Partial Content\x0aX-Powered-By: Express\x0aAccess-Control-Allow-Origin: *\x0aAccept-Ranges: bytes\x0aContent-Range: bytes 0-399999/7751197\x0aContent-Type: null; charset=UTF-8\x0aContent-Length: 400000\x0aETag: W/\x2261a80-veDNoeO9X/2YGknH7BktU2cTt/w\x22\x0aDate: Thu, 06 Dec 2018 12:42:40 GMT\x0aConnection: keep-alive\x0a\x0a(window[\x22webpackJsonp\x22] = window[\x22webpackJsonp\x22] || []).push([[\x22vendor\x22],{\x0a\x0a/***/ \x22./node_modules/@angular/animations/fesm5/animations.js\x22:\x0a/*!**************************************************************!*\x5c\x0a  !*** ./node_modules/@angular/animations/fesm5/animations.js ***!\x0a  \x5c**************************************************************/\x0a/*! exports provided: AnimationBuilder, AnimationFactory, AUTO_STYLE, animate, animateChild, animation, group, keyframes, query, sequence, stagger, state, style, transition, trigger, useAnimation, NoopAnimationPlayer, \xc9\xb5PRE_STYLE, \xc9\xb5AnimationGroupPlayer */\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22AnimationBuilder\x22, function() { return AnimationBuilder; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22AnimationFactory\x22, function() { return AnimationFactory; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22AUTO_STYLE\x22, function() { return AUTO_STYLE; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22animate\x22, function() { return animate; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22animateChild\x22, function() { return animateChild; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22animation\x22, function() { return animation; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22group\x22, function() { return group; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22keyframes\x22, function() { return keyframes; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22query\x22, function() { return query; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22sequence\x22, function() { return sequence; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22stagger\x22, function() { return stagger; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22state\x22, function() { return state; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22style\x22, function() { return style; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22transition\x22, function() { return transition; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22trigger\x22, function() { return trigger; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22useAnimation\x22, function() { return useAnimation; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22NoopAnimationPlayer\x22, function() { return NoopAnimationPlayer; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5PRE_STYLE\x22, function() { return \xc9\xb5PRE_STYLE; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5AnimationGroupPlayer\x22, function() { return AnimationGroupPlayer; });\x0a/**\x0a * @license Angular v7.0.3\x0a * (c) 2010-2018 Google, Inc. https://angular.io/\x0a * License: MIT\x0a */\x0a\x0a/**\x0a * An injectable service that produces an animation sequence programmatically within an\x0a * Angular component or directive.\x0a * Provided by the `BrowserAnimationsModule` or `NoopAnimationsModule`.\x0a *\x0a * @usageNotes\x0a *\x0a * To use this service, add it to your component or directive as a dependency.\x0a * The service is instantiated along with your component.\x0a *\x0a * Apps do not typically need to create their own animation players, but if you\x0a * do need to, follow these steps:\x0a *\x0a * 1. Use the `build()` method to create a programmatic animation using the\x0a * `animate()` function. The method returns an `AnimationFactory` instance.\x0a *\x0a * 2. Use the factory object to create an `AnimationPlayer` and attach it to a DOM element.\x0a *\x0a * 3. Use the player object to control the animation programmatically.\x0a *\x0a * For example:\x0a *\x0a * ```ts\x0a * // import the service from BrowserAnimationsModule\x0a * import {AnimationBuilder} from \x27@angular/animations\x27;\x0a * // require the service as a dependency\x0a * class MyCmp {\x0a *   constructor(private _builder: AnimationBuilder) {}\x0a *\x0a *   makeAnimation(element: any) {\x0a *     // first define a reusable animation\x0a *     const myAnimation = this._builder.build([\x0a *       style({ width: 0 }),\x0a *       animate(1000, style({ width: \x27100px\x27 }))\x0a *     ]);\x0a *\x0a *     // use the returned factory object to create a player\x0a *     const player = myAnimation.create(element);\x0a *\x0a *     player.play();\x0a *   }\x0a * }\x0a * ```\x0a *\x0a * @publicApi\x0a */\x0avar AnimationBuilder = /** @class */ (function () {\x0a    function AnimationBuilder() {\x0a    }\x0a    return AnimationBuilder;\x0a}());\x0a/**\x0a * A factory object returned from the `AnimationBuilder`.`build()` method.\x0a *\x0a * @publicApi\x0a */\x0avar AnimationFactory = /** @class */ (function () {\x0a    function AnimationFactory() {\x0a    }\x0a    return AnimationFactory;\x0a}());\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/**\x0a * Specifies automatic styling.\x0a *\x0a * @publicApi\x0a */\x0avar AUTO_STYLE = \x27*\x27;\x0a/**\x0a * Creates a named animation trigger, containing a  list of `state()`\x0a * and `transition()` entries to be evaluated when the expression\x0a * bound to the trigger changes.\x0a *\x0a * @param name An identifying string.\x0a * @param definitions  An animation definition object, containing an array of `state()`\x0a * and `transition()` declarations.\x0a *\x0a * @return An object that encapsulates the trigger data.\x0a *\x0a * @usageNotes\x0a * Define an animation trigger in the `animations` section of `@Component` metadata.\x0a * In the template, reference the trigger by name and bind it to a trigger expression that\x0a * evaluates to a defined animation state, using the following format:\x0a *\x0a * `[@triggerName]=\x22expression\x22`\x0a *\x0a * Animation trigger bindings convert all values to strings, and then match the\x0a * previous and current values against any linked transitions.\x0a * Booleans can be specified as `1` or `true` and `0` or `false`.\x0a *\x0a * ### Usage Example\x0a *\x0a * The following example creates an animation trigger reference based on the provided\x0a * name value.\x0a * The provided animation value is expected to be an array consisting of state and\x0a * transition declarations.\x0a *\x0a * ```typescript\x0a * @Component({\x0a *   selector: \x22my-component\x22,\x0a *   templateUrl: \x22my-component-tpl.html\x22,\x0a *   animations: [\x0a *     trigger(\x22myAnimationTrigger\x22, [\x0a *       state(...),\x0a *       state(...),\x0a *       transition(...),\x0a *       transition(...)\x0a *     ])\x0a *   ]\x0a * })\x0a * class MyComponent {\x0a *   myStatusExp = \x22something\x22;\x0a * }\x0a * ```\x0a *\x0a * The template associated with this component makes use of the defined trigger\x0a * by binding to an element within its template code.\x0a *\x0a * ```html\x0a * \x3c!-- somewhere inside of my-component-tpl.html --\x3e\x0a * \x3cdiv [@myAnimationTrigger]=\x22myStatusExp\x22\x3e...\x3c/div\x3e\x0a * ```\x0a *\x0a * ### Using an inline function\x0a * The `transition` animation method also supports reading an inline function which can decide\x0a * if its associated animation should be run.\x0a *\x0a * ```typescript\x0a * // this method is run each time the `myAnimationTrigger` trigger value changes.\x0a * function myInlineMatcherFn(fromState: string, toState: string, element: any, params: {[key:\x0a string]: any}): boolean {\x0a *   // notice that `element` and `params` are also available here\x0a *   return toState == \x27yes-please-animate\x27;\x0a * }\x0a *\x0a * @Component({\x0a *   selector: \x27my-component\x27,\x0a *   templateUrl: \x27my-component-tpl.html\x27,\x0a *   animations: [\x0a *     trigger(\x27myAnimationTrigger\x27, [\x0a *       transition(myInlineMatcherFn, [\x0a *         // the animation sequence code\x0a *       ]),\x0a *     ])\x0a *   ]\x0a * })\x0a * class MyComponent {\x0a *   myStatusExp = \x22yes-please-animate\x22;\x0a * }\x0a * ```\x0a *\x0a * ### Disabling Animations\x0a * When true, the special animation control binding `@.disabled` binding prevents\x0a * all animations from rendering.\x0a * Place the  `@.disabled` binding on an element to disable\x0a * animations on the element itself, as well as any inner animation triggers\x0a * within the element.\x0a *\x0a * The following example shows how to use this feature:\x0a *\x0a * ```typescript\x0a * @Component({\x0a *   selector: \x27my-component\x27,\x0a *   template: `\x0a *     \x3cdiv [@.disabled]=\x22isDisabled\x22\x3e\x0a *       \x3cdiv [@childAnimation]=\x22exp\x22\x3e\x3c/div\x3e\x0a *     \x3c/div\x3e\x0a *   `,\x0a *   animations: [\x0a *     trigger(\x22childAnimation\x22, [\x0a *       // ...\x0a *     ])\x0a *   ]\x0a * })\x0a * class MyComponent {\x0a *   isDisabled = true;\x0a *   exp = \x27...\x27;\x0a * }\x0a * ```\x0a *\x0a * When `@.disabled` is true, it prevents the `@childAnimation` trigger from animating,\x0a * along with any inner animations.\x0a *\x0a * ### Disable animations application-wide\x0a * When an area of the template is set to have animations disabled,\x0a * **all** inner components have their animations disabled as well.\x0a * This means that you can disable all animations for an app\x0a * by placing a host binding set on `@.disabled` on the topmost Angular component.\x0a *\x0a * ```typescript\x0a * import {Component, HostBinding} from \x27@angular/core\x27;\x0a *\x0a * @Component({\x0a *   selector: \x27app-component\x27,\x0a *   templateUrl: \x27app.component.html\x27,\x0a * })\x0a * class AppComponent {\x0a *   @HostBinding(\x27@.disabled\x27)\x0a *   public animationsDisabled = true;\x0a * }\x0a * ```\x0a *\x0a * ### Overriding disablement of inner animations\x0a * Despite inner animations being disabled, a parent animation can `query()`\x0a * for inner elements located in disabled areas of the template and still animate\x0a * them if needed. This is also the case for when a sub animation is\x0a * queried by a parent and then later animated using `animateChild()`.\x0a *\x0a * ### Detecting when an animation is disabled\x0a * If a region of the DOM (or the entire application) has its animations disabled, the animation\x0a * trigger callbacks still fire, but for zero seconds. When the callback fires, it provides\x0a * an instance of an `AnimationEvent`. If animations are disabled,\x0a * the `.disabled` flag on the event is true.\x0a *\x0a * @publicApi\x0a */\x0afunction trigger(name, definitions) {\x0a    return { type: 7 /* Trigger */, name: name, definitions: definitions, options: {} };\x0a}\x0a/**\x0a * Defines an animation step that combines styling information with timing information.\x0a *\x0a * @param timings Sets `AnimateTimings` for the parent animation.\x0a * A string in the format \x22duration [delay] [easing]\x22.\x0a *  - Duration and delay are expressed as a number and optional time unit,\x0a * such as \x221s\x22 or \x2210ms\x22 for one second and 10 milliseconds, respectively.\x0a * The default unit is milliseconds.\x0a *  - The easing value controls how the animation accelerates and decelerates\x0a * during its runtime. Value is one of  `ease`, `ease-in`, `ease-out`,\x0a * `ease-in-out`, or a `cubic-bezier()` function call.\x0a * If not supplied, no easing is applied.\x0a *\x0a * For example, the string \x221s 100ms ease-out\x22 specifies a duration of\x0a * 1000 milliseconds, and delay of 100 ms, and the \x22ease-out\x22 easing style,\x0a * which decelerates near the end of the duration.\x0a * @param styles Sets AnimationStyles for the parent animation.\x0a * A function call to either `style()` or `keyframes()`\x0a * that returns a collection of CSS style entries to be applied to the parent animation.\x0a * When null, uses the styles from the destination state.\x0a * This is useful when describing an animation step that will complete an animation;\x0a * see \x22Animating to the final state\x22 in `transitions()`.\x0a * @returns An object that encapsulates the animation step.\x0a *\x0a * @usageNotes\x0a * Call within an animation `sequence()`, `{@link animations/group group()}`, or\x0a * `transition()` call to specify an animation step\x0a * that applies given style data to the parent animation for a given amount of time.\x0a *\x0a * ### Syntax Examples\x0a * **Timing examples**\x0a *\x0a * The following examples show various `timings` specifications.\x0a * - `animate(500)` : Duration is 500 milliseconds.\x0a * - `animate(\x221s\x22)` : Duration is 1000 milliseconds.\x0a * - `animate(\x22100ms 0.5s\x22)` : Duration is 100 milliseconds, delay is 500 milliseconds.\x0a * - `animate(\x225s ease-in\x22)` : Duration is 5000 milliseconds, easing in.\x0a * - `animate(\x225s 10ms cubic-bezier(.17,.67,.88,.1)\x22)` : Duration is 5000 milliseconds, delay is 10\x0a * milliseconds, easing according to a bezier curve.\x0a *\x0a * **Style examples**\x0a *\x0a * The following example calls `style()` to set a single CSS style.\x0a * ```typescript\x0a * animate(500, style({ background: \x22red\x22 }))\x0a * ```\x0a * The following example calls `keyframes()` to set a CSS style\x0a * to different values for successive keyframes.\x0a * ```typescript\x0a * animate(500, keyframes(\x0a *  [\x0a *   style({ background: \x22blue\x22 })),\x0a *   style({ background: \x22red\x22 }))\x0a *  ])\x0a * ```\x0a *\x0a * @publicApi\x0a */\x0afunction animate(timings, styles) {\x0a    if (styles === void 0) { styles = null; }\x0a    return { type: 4 /* Animate */, styles: styles, timings: timings };\x0a}\x0a/**\x0a * @description Defines a list of animation steps to be run in parallel.\x0a *\x0a * @param steps An array of animation step objects.\x0a * - When steps are defined by `style()` or `animate()`\x0a * function calls, each call within the group is executed instantly.\x0a * - To specify offset styles to be applied at a later time, define steps with\x0a * `keyframes()`, or use `animate()` calls with a delay value.\x0a * For example:\x0a *\x0a * ```typescript\x0a * group([\x0a *   animate(\x221s\x22, { background: \x22black\x22 }))\x0a *   animate(\x222s\x22, { color: \x22white\x22 }))\x0a * ])\x0a * ```\x0a *\x0a * @param options An options object containing a delay and\x0a * developer-defined parameters that provide styling defaults and\x0a * can be overridden on invocation.\x0a *\x0a * @return An object that encapsulates the group data.\x0a *\x0a * @usageNotes\x0a * Grouped animations are useful when a series of styles must be\x0a * animated at different starting times and closed off at different ending times.\x0a *\x0a * When called within a `sequence()` or a\x0a * `transition()` call, does not continue to the next\x0a * instruction until all of the inner animation steps have completed.\x0a *\x0a * @publicApi\x0a */\x0afunction group(steps, options) {\x0a    if (options === void 0) { options = null; }\x0a    return { type: 3 /* Group */, steps: steps, options: options };\x0a}\x0a/**\x0a * Defines a list of animation steps to be run sequentially, one by one.\x0a *\x0a * @param steps An array of animation step objects.\x0a * - Steps defined by `style()` calls apply the styling data immediately.\x0a * - Steps defined by `animate()` calls apply the styling data over time\x0a *   as specified by the timing data.\x0a *\x0a * ```typescript\x0a * sequence([\x0a *   style({ opacity: 0 })),\x0a *   animate(\x221s\x22, { opacity: 1 }))\x0a * ])\x0a * ```\x0a *\x0a * @param options An options object containing a delay and\x0a * developer-defined parameters that provide styling defaults and\x0a * can be overridden on invocation.\x0a *\x0a * @return An object that encapsulates the sequence data.\x0a *\x0a * @usageNotes\x0a * When you pass an array of steps to a\x0a * `transition()` call, the steps run sequentially by default.\x0a * Compare this to the `{@link animations/group group()}` call, which runs animation steps in parallel.\x0a *\x0a * When a sequence is used within a `{@link animations/group group()}` or a `transition()` call,\x0a * execution continues to the next instruction only after each of the inner animation\x0a * steps have completed.\x0a *\x0a * @publicApi\x0a **/\x0afunction sequence(steps, options) {\x0a    if (options === void 0) { options = null; }\x0a    return { type: 2 /* Sequence */, steps: steps, options: options };\x0a}\x0a/**\x0a * Declares a key/value object containing CSS properties/styles that\x0a * can then be used for an animation `state`, within an animation `sequence`,\x0a * or as styling data for calls to `animate()` and `keyframes()`.\x0a *\x0a * @param tokens A set of CSS styles or HTML styles associated with an animation state.\x0a * The value can be any of the following:\x0a * - A key-value style pair associating a CSS property with a value.\x0a * - An array of key-value style pairs.\x0a * - An asterisk (*), to use auto-styling, where styles are derived from the element\x0a * being animated and applied to the animation when it starts.\x0a *\x0a * Auto-styling can be used to define a state that depends on layout or other\x0a * environmental factors.\x0a *\x0a * @return An object that encapsulates the style data.\x0a *\x0a * @usageNotes\x0a * The following examples create animation styles that collect a set of\x0a * CSS property values:\x0a *\x0a * ```typescript\x0a * // string values for CSS properties\x0a * style({ background: \x22red\x22, color: \x22blue\x22 })\x0a *\x0a * // numerical pixel values\x0a * style({ width: 100, height: 0 })\x0a * ```\x0a *\x0a * The following example uses auto-styling to allow a component to animate from\x0a * a height of 0 up to the height of the parent element:\x0a *\x0a * ```\x0a * style({ height: 0 }),\x0a * animate(\x221s\x22, style({ height: \x22*\x22 }))\x0a * ```\x0a *\x0a * @publicApi\x0a **/\x0afunction style(tokens) {\x0a    return { type: 6 /* Style */, styles: tokens, offset: null };\x0a}\x0a/**\x0a * Declares an animation state within a trigger attached to an element.\x0a *\x0a * @param name One or more names for the defined state in a comma-separated string.\x0a * The following reserved state names can be supplied to define a style for specific use\x0a * cases:\x0a *\x0a * - `void` You can associate styles with this name to be used when\x0a * the element is detached from the application. For example, when an `ngIf` evaluates\x0a * to false, the state of the associated element is void.\x0a *  - `*` (asterisk) Indicates the default state. You can associate styles with this name\x0a * to be used as the fallback when the state that is being animated is not declared\x0a * within the trigger.\x0a *\x0a * @param styles A set of CSS styles associated with this state, created using the\x0a * `style()` function.\x0a * This set of styles persists on the element once the state has been reached.\x0a * @param options Parameters that can be passed to the state when it is invoked.\x0a * 0 or more key-value pairs.\x0a * @return An object that encapsulates the new state data.\x0a *\x0a * @usageNotes\x0a * Use the `trigger()` function to register states to an animation trigger.\x0a * Use the `transition()` function to animate between states.\x0a * When a state is active within a component, its associated styles persist on the element,\x0a * even when the animation ends.\x0a *\x0a * @publicApi\x0a **/\x0afunction state(name, styles, options) {\x0a    return { type: 0 /* State */, name: name, styles: styles, options: options };\x0a}\x0a/**\x0a * Defines a set of animation styles, associating each style with an optional `offset` value.\x0a *\x0a * @param steps A set of animation styles with optional offset data.\x0a * The optional `offset` value for a style specifies a percentage of the total animation\x0a * time at which that style is applied.\x0a * @returns An object that encapsulates the keyframes data.\x0a *\x0a * @usageNotes\x0a * Use with the `animate()` call. Instead of applying animations\x0a * from the current state\x0a * to the destination state, keyframes describe how each style entry is applied and at what point\x0a * within the animation arc.\x0a * Compare [CSS Keyframe Animations](https://www.w3schools.com/css/css3_animations.asp).\x0a *\x0a * ### Usage\x0a *\x0a * In the following example, the offset values describe\x0a * when each `backgroundColor` value is applied. The color is red at the start, and changes to\x0a * blue when 20% of the total time has elapsed.\x0a *\x0a * ```typescript\x0a * // the provided offset values\x0a * animate(\x225s\x22, keyframes([\x0a *   style({ backgroundColor: \x22red\x22, offset: 0 }),\x0a *   style({ backgroundColor: \x22blue\x22, offset: 0.2 }),\x0a *   style({ backgroundColor: \x22orange\x22, offset: 0.3 }),\x0a *   style({ backgroundColor: \x22black\x22, offset: 1 })\x0a * ]))\x0a * ```\x0a *\x0a * If there are no `offset` values specified in the style entries, the offsets\x0a * are calculated automatically.\x0a *\x0a * ```typescript\x0a * animate(\x225s\x22, keyframes([\x0a *   style({ backgroundColor: \x22red\x22 }) // offset = 0\x0a *   style({ backgroundColor: \x22blue\x22 }) // offset = 0.33\x0a *   style({ backgroundColor: \x22orange\x22 }) // offset = 0.66\x0a *   style({ backgroundColor: \x22black\x22 }) // offset = 1\x0a * ]))\x0a *```\x0a\x0a * @publicApi\x0a */\x0afunction keyframes(steps) {\x0a    return { type: 5 /* Keyframes */, steps: steps };\x0a}\x0a/**\x0a * Declares an animation transition as a sequence of animation steps to run when a given\x0a * condition is satisfied. The condition is a Boolean expression or function that compares\x0a * the previous and current animation states, and returns true if this transition should occur.\x0a * When the state criteria of a defined transition are met, the associated animation is\x0a * triggered.\x0a *\x0a * @param stateChangeExpr A Boolean expression or function that compares the previous and current\x0a * animation states, and returns true if this transition should occur. Note that  \x22true\x22 and \x22false\x22\x0a * match 1 and 0, respectively. An expression is evaluated each time a state change occurs in the\x0a * animation trigger element.\x0a * The animation steps run when the expression evaluates to true.\x0a *\x0a * - A state-change string takes the form \x22state1 =\x3e state2\x22, where each side is a defined animation\x0a * state, or an asterix (*) to refer to a dynamic start or end state.\x0a *   - The expression string can contain multiple comma-separated statements;\x0a * for example \x22state1 =\x3e state2, state3 =\x3e state4\x22.\x0a *   - Special values `:enter` and `:leave` initiate a transition on the entry and exit states,\x0a * equivalent to  \x22void =\x3e *\x22  and \x22* =\x3e void\x22.\x0a *   - Special values `:increment` and `:decrement` initiate a transition when a numeric value has\x0a * increased or decreased in value.\x0a * - A function is executed each time a state change occurs in the animation trigger element.\x0a * The animation steps run when the function returns true.\x0a *\x0a * @param steps One or more animation objects, as returned by the `animate()` or\x0a * `sequence()` function, that form a transformation from one state to another.\x0a * A sequence is used by default when you pass an array.\x0a * @param options An options object that can contain a delay value for the start of the animation,\x0a * and additional developer-defined parameters. Provided values for additional parameters are used\x0a * as defaults, and override values can be passed to the caller on invocation.\x0a * @returns An object that encapsulates the transition data.\x0a *\x0a * @usageNotes\x0a * The template associated with a component binds an animation trigger to an element.\x0a *\x0a * ```HTML\x0a * \x3c!-- somewhere inside of my-component-tpl.html --\x3e\x0a * \x3cdiv [@myAnimationTrigger]=\x22myStatusExp\x22\x3e...\x3c/div\x3e\x0a * ```\x0a *\x0a * All transitions are defined within an animation trigger,\x0a * along with named states that the transitions change to and from.\x0a *\x0a * ```typescript\x0a * trigger(\x22myAnimationTrigger\x22, [\x0a *  // define states\x0a *  state(\x22on\x22, style({ background: \x22green\x22 })),\x0a *  state(\x22off\x22, style({ background: \x22grey\x22 })),\x0a *  ...]\x0a * ```\x0a *\x0a * Note that when you call the `sequence()` function within a `{@link animations/group group()}`\x0a * or a `transition()` call, execution does not continue to the next instruction\x0a * until each of the inner animation steps have completed.\x0a *\x0a * ### Syntax examples\x0a *\x0a * The following examples define transitions between the two defined states (and default states),\x0a * using various options:\x0a *\x0a * ```typescript\x0a * // Transition occurs when the state value\x0a * // bound to \x22myAnimationTrigger\x22 changes from \x22on\x22 to \x22off\x22\x0a * transition(\x22on =\x3e off\x22, animate(500))\x0a * // Run the same animation for both directions\x0a * transition(\x22on \x3c=\x3e off\x22, animate(500))\x0a * // Define multiple state-change pairs separated by commas\x0a * transition(\x22on =\x3e off, off =\x3e void\x22, animate(500))\x0a * ```\x0a *\x0a * ### Special values for state-change expressions\x0a *\x0a * - Catch-all state change for when an element is inserted into the page and the\x0a * destination state is unknown:\x0a *\x0a * ```typescript\x0a * transition(\x22void =\x3e *\x22, [\x0a *  style({ opacity: 0 }),\x0a *  animate(500)\x0a *  ])\x0a * ```\x0a *\x0a * - Capture a state change between any states:\x0a *\x0a *  `transition(\x22* =\x3e *\x22, animate(\x221s 0s\x22))`\x0a *\x0a * - Entry and exit transitions:\x0a *\x0a * ```typescript\x0a * transition(\x22:enter\x22, [\x0a *   style({ opacity: 0 }),\x0a *   animate(500, style({ opacity: 1 }))\x0a *   ]),\x0a * transition(\x22:leave\x22, [\x0a *   animate(500, style({ opacity: 0 }))\x0a *   ])\x0a * ```\x0a *\x0a * - Use `:increment` and `:decrement` to initiate transitions:\x0a *\x0a * ```typescript\x0a * transition(\x22:increment\x22, group([\x0a *  query(\x27:enter\x27, [\x0a *     style({ left: \x27100%\x27 }),\x0a *     animate(\x270.5s ease-out\x27, style(\x27*\x27))\x0a *   ]),\x0a *  query(\x27:leave\x27, [\x0a *     animate(\x270.5s ease-out\x27, style({ left: \x27-100%\x27 }))\x0a *  ])\x0a * ]))\x0a *\x0a * transition(\x22:decrement\x22, group([\x0a *  query(\x27:enter\x27, [\x0a *     style({ left: \x27100%\x27 }),\x0a *     animate(\x270.5s ease-out\x27, style(\x27*\x27))\x0a *   ]),\x0a *  query(\x27:leave\x27, [\x0a *     animate(\x270.5s ease-out\x27, style({ left: \x27-100%\x27 }))\x0a *  ])\x0a * ]))\x0a * ```\x0a *\x0a * ### State-change functions\x0a *\x0a * Here is an example of a `fromState` specified as a state-change function that invokes an\x0a * animation when true:\x0a *\x0a * ```typescript\x0a * transition((fromState, toState) =\x3e\x0a *  {\x0a *   return fromState == \x22off\x22 && toState == \x22on\x22;\x0a *  },\x0a *  animate(\x221s 0s\x22))\x0a * ```\x0a *\x0a * ### Animating to the final state\x0a *\x0a * If the final step in a transition is a call to `animate()` that uses a timing value\x0a * with no style data, that step is automatically considered the final animation arc,\x0a * for the element to reach the final state. Angular automatically adds or removes\x0a * CSS styles to ensure that the element is in the correct final state.\x0a *\x0a * The following example defines a transition that starts by hiding the element,\x0a * then makes sure that it animates properly to whatever state is currently active for trigger:\x0a *\x0a * ```typescript\x0a * transition(\x22void =\x3e *\x22, [\x0a *   style({ opacity: 0 }),\x0a *   animate(500)\x0a *  ])\x0a * ```\x0a * ### Boolean value matching\x0a * If a trigger binding value is a Boolean, it can be matched using a transition expression\x0a * that compares true and false or 1 and 0. For example:\x0a *\x0a * ```\x0a * // in the template\x0a * \x3cdiv [@openClose]=\x22open ? true : false\x22\x3e...\x3c/div\x3e\x0a * // in the component metadata\x0a * trigger(\x27openClose\x27, [\x0a *   state(\x27true\x27, style({ height: \x27*\x27 })),\x0a *   state(\x27false\x27, style({ height: \x270px\x27 })),\x0a *   transition(\x27false \x3c=\x3e true\x27, animate(500))\x0a * ])\x0a * ```\x0a *\x0a * @publicApi\x0a **/\x0afunction transition(stateChangeExpr, steps, options) {\x0a    if (options === void 0) { options = null; }\x0a    return { type: 1 /* Transition */, expr: stateChangeExpr, animation: steps, options: options };\x0a}\x0a/**\x0a * Produces a reusable animation that can be invoked in another animation or sequence,\x0a * by calling the `useAnimation()` function.\x0a *\x0a * @param steps One or more animation objects, as returned by the `animate()`\x0a * or `sequence()` function, that form a transformation from one state to another.\x0a * A sequence is used by default when you pass an array.\x0a * @param options An options object that can contain a delay value for the start of the\x0a * animation, and additional developer-defined parameters.\x0a * Provided values for additional parameters are used as defaults,\x0a * and override values can be passed to the caller on invocation.\x0a * @returns An object that encapsulates the animation data.\x0a *\x0a * @usageNotes\x0a * The following example defines a reusable animation, providing some default parameter\x0a * values.\x0a *\x0a * ```typescript\x0a * var fadeAnimation = animation([\x0a *   style({ opacity: \x27{{ start }}\x27 }),\x0a *   animate(\x27{{ time }}\x27,\x0a *   style({ opacity: \x27{{ end }}\x27}))\x0a *   ],\x0a *   { params: { time: \x271000ms\x27, start: 0, end: 1 }});\x0a * ```\x0a *\x0a * The following invokes the defined animation with a call to `useAnimation()`,\x0a * passing in override parameter values.\x0a *\x0a * ```js\x0a * useAnimation(fadeAnimation, {\x0a *   params: {\x0a *     time: \x272s\x27,\x0a *     start: 1,\x0a *     end: 0\x0a *   }\x0a * })\x0a * ```\x0a *\x0a * If any of the passed-in parameter values are missing from this call,\x0a * the default values are used. If one or more parameter values are missing before a step is\x0a * animated, `useAnimation()` throws an error.\x0a *\x0a * @publicApi\x0a */\x0afunction animation(steps, options) {\x0a    if (options === void 0) { options = null; }\x0a    return { type: 8 /* Reference */, animation: steps, options: options };\x0a}\x0a/**\x0a * Executes a queried inner animation element within an animation sequence.\x0a *\x0a * @param options An options object that can contain a delay value for the start of the\x0a * animation, and additional override values for developer-defined parameters.\x0a * @return An object that encapsulates the child animation data.\x0a *\x0a * @usageNotes\x0a * Each time an animation is triggered in Angular, the parent animation\x0a * has priority and any child animations are blocked. In order\x0a * for a child animation to run, the parent animation must query each of the elements\x0a * containing child animations, and run them using this function.\x0a *\x0a * Note that this feature designed to be used with `query()` and it will only work\x0a * with animations that are assigned using the Angular animation library. CSS keyframes\x0a * and transitions are not handled by this API.\x0a *\x0a * @publicApi\x0a */\x0afunction animateChild(options) {\x0a    if (options === void 0) { options = null; }\x0a    return { type: 9 /* AnimateChild */, options: options };\x0a}\x0a/**\x0a * Starts a reusable animation that is created using the `animation()` function.\x0a *\x0a * @param animation The reusable animation to start.\x0a * @param options An options object that can contain a delay value for the start of\x0a * the animation, and additional override values for developer-defined parameters.\x0a * @return An object that contains the animation parameters.\x0a *\x0a * @publicApi\x0a */\x0afunction useAnimation(animation, options) {\x0a    if (options === void 0) { options = null; }\x0a    return { type: 10 /* AnimateRef */, animation: animation, options: options };\x0a}\x0a/**\x0a * Finds one or more inner elements within the current element that is\x0a * being animated within a sequence. Use with `animateChild()`.\x0a *\x0a * @param selector The element to query, or a set of elements that contain Angular-specific\x0a * characteristics, specified with one or more of the following tokens.\x0a *  - `query(\x22:enter\x22)` or `query(\x22:leave\x22)` : Query for newly inserted/removed elements.\x0a *  - `query(\x22:animating\x22)` : Query all currently animating elements.\x0a *  - `query(\x22@triggerName\x22)` : Query elements that contain an animation trigger.\x0a *  - `query(\x22@*\x22)` : Query all elements that contain an animation triggers.\x0a *  - `query(\x22:self\x22)` : Include the current element into the animation sequence.\x0a *\x0a * @param animation One or more animation steps to apply to the queried element or elements.\x0a * An array is treated as an animation sequence.\x0a * @param options An options object. Use the \x27limit\x27 field to limit the total number of\x0a * items to collect.\x0a * @return An object that encapsulates the query data.\x0a *\x0a * @usageNotes\x0a * Tokens can be merged into a combined query selector string. For example:\x0a *\x0a * ```typescript\x0a *  query(\x27:self, .record:enter, .record:leave, @subTrigger\x27, [...])\x0a * ```\x0a *\x0a * The `query()` function collects multiple elements and works internally by using\x0a * `element.querySelectorAll`. Use the `limit` field of an options object to limit\x0a * the total number of items to be collected. For example:\x0a *\x0a * ```js\x0a * query(\x27div\x27, [\x0a *   animate(...),\x0a *   animate(...)\x0a * ], { limit: 1 })\x0a * ```\x0a *\x0a * By default, throws an error when zero items are found. Set the\x0a * `optional` flag to ignore this error. For example:\x0a *\x0a * ```js\x0a * query(\x27.some-element-that-may-not-be-there\x27, [\x0a *   animate(...),\x0a *   animate(...)\x0a * ], { optional: true })\x0a * ```\x0a *\x0a * ### Usage Example\x0a *\x0a * The following example queries for inner elements and animates them\x0a * individually using `animateChild()`.\x0a *\x0a * ```typescript\x0a * @Component({\x0a *   selector: \x27inner\x27,\x0a *   template: `\x0a *     \x3cdiv [@queryAnimation]=\x22exp\x22\x3e\x0a *       \x3ch1\x3eTitle\x3c/h1\x3e\x0a *       \x3cdiv class=\x22content\x22\x3e\x0a *         Blah blah blah\x0a *       \x3c/div\x3e\x0a *     \x3c/div\x3e\x0a *   `,\x0a *   animations: [\x0a *    trigger(\x27queryAnimation\x27, [\x0a *      transition(\x27* =\x3e goAnimate\x27, [\x0a *        // hide the inner elements\x0a *        query(\x27h1\x27, style({ opacity: 0 })),\x0a *        query(\x27.content\x27, style({ opacity: 0 })),\x0a *\x0a *        // animate the inner elements in, one by one\x0a *        query(\x27h1\x27, animate(1000, style({ opacity: 1 })),\x0a *        query(\x27.content\x27, animate(1000, style({ opacity: 1 })),\x0a *      ])\x0a *    ])\x0a *  ]\x0a * })\x0a * class Cmp {\x0a *   exp = \x27\x27;\x0a *\x0a *   goAnimate() {\x0a *     this.exp = \x27goAnimate\x27;\x0a *   }\x0a * }\x0a * ```\x0a *\x0a * @publicApi\x0a */\x0afunction query(selector, animation, options) {\x0a    if (options === void 0) { options = null; }\x0a    return { type: 11 /* Query */, selector: selector, animation: animation, options: options };\x0a}\x0a/**\x0a * Use within an animation `query()` call to issue a timing gap after\x0a * each queried item is animated.\x0a *\x0a * @param timings A delay value.\x0a * @param animation One ore more animation steps.\x0a * @returns An object that encapsulates the stagger data.\x0a *\x0a * @usageNotes\x0a * In the following example, a container element wraps a list of items stamped out\x0a * by an `ngFor`. The container element contains an animation trigger that will later be set\x0a * to query for each of the inner items.\x0a *\x0a * Each time items are added, the opacity fade-in animation runs,\x0a * and each removed item is faded out.\x0a * When either of these animations occur, the stagger effect is\x0a * applied after each item\x27s animation is started.\x0a *\x0a * ```html\x0a * \x3c!-- list.component.html --\x3e\x0a * \x3cbutton (click)=\x22toggle()\x22\x3eShow / Hide Items\x3c/button\x3e\x0a * \x3chr /\x3e\x0a * \x3cdiv [@listAnimation]=\x22items.length\x22\x3e\x0a *   \x3cdiv *ngFor=\x22let item of items\x22\x3e\x0a *     {{ item }}\x0a *   \x3c/div\x3e\x0a * \x3c/div\x3e\x0a * ```\x0a *\x0a * Here is the component code:\x0a *\x0a * ```typescript\x0a * import {trigger, transition, style, animate, query, stagger} from \x27@angular/animations\x27;\x0a * @Component({\x0a *   templateUrl: \x27list.component.html\x27,\x0a *   animations: [\x0a *     trigger(\x27listAnimation\x27, [\x0a *     ...\x0a *     ])\x0a *   ]\x0a * })\x0a * class ListComponent {\x0a *   items = [];\x0a *\x0a *   showItems() {\x0a *     this.items = [0,1,2,3,4];\x0a *   }\x0a *\x0a *   hideItems() {\x0a *     this.items = [];\x0a *   }\x0a *\x0a *   toggle() {\x0a *     this.items.length ? this.hideItems() : this.showItems();\x0a *    }\x0a *  }\x0a * ```\x0a *\x0a * Here is the animation trigger code:\x0a *\x0a * ```typescript\x0a * trigger(\x27listAnimation\x27, [\x0a *   transition(\x27* =\x3e *\x27, [ // each time the binding value changes\x0a *     query(\x27:leave\x27, [\x0a *       stagger(100, [\x0a *         animate(\x270.5s\x27, style({ opacity: 0 }))\x0a *       ])\x0a *     ]),\x0a *     query(\x27:enter\x27, [\x0a *       style({ opacity: 0 }),\x0a *       stagger(100, [\x0a *         animate(\x270.5s\x27, style({ opacity: 1 }))\x0a *       ])\x0a *     ])\x0a *   ])\x0a * ])\x0a * ```\x0a *\x0a * @publicApi\x0a */\x0afunction stagger(timings, animation) {\x0a    return { type: 12 /* Stagger */, timings: timings, animation: animation };\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0afunction scheduleMicroTask(cb) {\x0a    Promise.resolve(null).then(cb);\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/**\x0a * An empty programmatic controller for reusable animations.\x0a * Used internally when animations are disabled, to avoid\x0a * checking for the null case when an animation player is expected.\x0a *\x0a * @see `animate()`\x0a * @see `AnimationPlayer`\x0a * @see `GroupPlayer`\x0a *\x0a * @publicApi\x0a */\x0avar NoopAnimationPlayer = /** @class */ (function () {\x0a    function NoopAnimationPlayer(duration, delay) {\x0a        if (duration === void 0) { duration = 0; }\x0a        if (delay === void 0) { delay = 0; }\x0a        this._onDoneFns = [];\x0a        this._onStartFns = [];\x0a        this._onDestroyFns = [];\x0a        this._started = false;\x0a        this._destroyed = false;\x0a        this._finished = false;\x0a        this.parentPlayer = null;\x0a        this.totalTime = duration + delay;\x0a    }\x0a    NoopAnimationPlayer.prototype._onFinish = function () {\x0a        if (!this._finished) {\x0a            this._finished = true;\x0a            this._onDoneFns.forEach(function (fn) { return fn(); });\x0a            this._onDoneFns = [];\x0a        }\x0a    };\x0a    NoopAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\x0a    NoopAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\x0a    NoopAnimationPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };\x0a    NoopAnimationPlayer.prototype.hasStarted = function () { return this._started; };\x0a    NoopAnimationPlayer.prototype.init = function () { };\x0a    NoopAnimationPlayer.prototype.play = function () {\x0a        if (!this.hasStarted()) {\x0a            this._onStart();\x0a            this.triggerMicrotask();\x0a        }\x0a        this._started = true;\x0a    };\x0a    /** @internal */\x0a    NoopAnimationPlayer.prototype.triggerMicrotask = function () {\x0a        var _this = this;\x0a        scheduleMicroTask(function () { return _this._onFinish(); });\x0a    };\x0a    NoopAnimationPlayer.prototype._onStart = function () {\x0a        this._onStartFns.forEach(function (fn) { return fn(); });\x0a        this._onStartFns = [];\x0a    };\x0a    NoopAnimationPlayer.prototype.pause = function () { };\x0a    NoopAnimationPlayer.prototype.restart = function () { };\x0a    NoopAnimationPlayer.prototype.finish = function () { this._onFinish(); };\x0a    NoopAnimationPlayer.prototype.destroy = function () {\x0a        if (!this._destroyed) {\x0a            this._destroyed = true;\x0a            if (!this.hasStarted()) {\x0a                this._onStart();\x0a            }\x0a            this.finish();\x0a            this._onDestroyFns.forEach(function (fn) { return fn(); });\x0a            this._onDestroyFns = [];\x0a        }\x0a    };\x0a    NoopAnimationPlayer.prototype.reset = function () { };\x0a    NoopAnimationPlayer.prototype.setPosition = function (position) { };\x0a    NoopAnimationPlayer.prototype.getPosition = function () { return 0; };\x0a    /** @internal */\x0a    NoopAnimationPlayer.prototype.triggerCallback = function (phaseName) {\x0a        var methods = phaseName == \x27start\x27 ? this._onStartFns : this._onDoneFns;\x0a        methods.forEach(function (fn) { return fn(); });\x0a        methods.length = 0;\x0a    };\x0a    return NoopAnimationPlayer;\x0a}());\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/**\x0a * A programmatic controller for a group of reusable animations.\x0a * Used internally to control animations.\x0a *\x0a * @see `AnimationPlayer`\x0a * @see `{@link animations/group group()}`\x0a *\x0a */\x0avar AnimationGroupPlayer = /** @class */ (function () {\x0a    function AnimationGroupPlayer(_players) {\x0a        var _this = this;\x0a        this._onDoneFns = [];\x0a        this._onStartFns = [];\x0a        this._finished = false;\x0a        this._started = false;\x0a        this._destroyed = false;\x0a        this._onDestroyFns = [];\x0a        this.parentPlayer = null;\x0a        this.totalTime = 0;\x0a        this.players = _players;\x0a        var doneCount = 0;\x0a        var destroyCount = 0;\x0a        var startCount = 0;\x0a        var total = this.players.length;\x0a        if (total == 0) {\x0a            scheduleMicroTask(function () { return _this._onFinish(); });\x0a        }\x0a        else {\x0a            this.players.forEach(function (player) {\x0a                player.onDone(function () {\x0a                    if (++doneCount == total) {\x0a                        _this._onFinish();\x0a                    }\x0a                });\x0a                player.onDestroy(function () {\x0a                    if (++destroyCount == total) {\x0a                        _this._onDestroy();\x0a                    }\x0a                });\x0a                player.onStart(function () {\x0a                    if (++startCount == total) {\x0a                        _this._onStart();\x0a                    }\x0a                });\x0a            });\x0a        }\x0a        this.totalTime = this.players.reduce(function (time, player) { return Math.max(time, player.totalTime); }, 0);\x0a    }\x0a    AnimationGroupPlayer.prototype._onFinish = function () {\x0a        if (!this._finished) {\x0a            this._finished = true;\x0a            this._onDoneFns.forEach(function (fn) { return fn(); });\x0a            this._onDoneFns = [];\x0a        }\x0a    };\x0a    AnimationGroupPlayer.prototype.init = function () { this.players.forEach(function (player) { return player.init(); }); };\x0a    AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\x0a    AnimationGroupPlayer.prototype._onStart = function () {\x0a        if (!this.hasStarted()) {\x0a            this._started = true;\x0a            this._onStartFns.forEach(function (fn) { return fn(); });\x0a            this._onStartFns = [];\x0a        }\x0a    };\x0a    AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\x0a    AnimationGroupPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };\x0a    AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };\x0a    AnimationGroupPlayer.prototype.play = function () {\x0a        if (!this.parentPlayer) {\x0a            this.init();\x0a        }\x0a        this._onStart();\x0a        this.players.forEach(function (player) { return player.play(); });\x0a    };\x0a    AnimationGroupPlayer.prototype.pause = function () { this.players.forEach(function (player) { return player.pause(); }); };\x0a    AnimationGroupPlayer.prototype.restart = function () { this.players.forEach(function (player) { return player.restart(); }); };\x0a    AnimationGroupPlayer.prototype.finish = function () {\x0a        this._onFinish();\x0a        this.players.forEach(function (player) { return player.finish(); });\x0a    };\x0a    AnimationGroupPlayer.prototype.destroy = function () { this._onDestroy(); };\x0a    AnimationGroupPlayer.prototype._onDestroy = function () {\x0a        if (!this._destroyed) {\x0a            this._destroyed = true;\x0a            this._onFinish();\x0a            this.players.forEach(function (player) { return player.destroy(); });\x0a            this._onDestroyFns.forEach(function (fn) { return fn(); });\x0a            this._onDestroyFns = [];\x0a        }\x0a    };\x0a    AnimationGroupPlayer.prototype.reset = function () {\x0a        this.players.forEach(function (player) { return player.reset(); });\x0a        this._destroyed = false;\x0a        this._finished = false;\x0a        this._started = false;\x0a    };\x0a    AnimationGroupPlayer.prototype.setPosition = function (p) {\x0a        var timeAtPosition = p * this.totalTime;\x0a        this.players.forEach(function (player) {\x0a            var position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;\x0a            player.setPosition(position);\x0a        });\x0a    };\x0a    AnimationGroupPlayer.prototype.getPosition = function () {\x0a        var min = 0;\x0a        this.players.forEach(function (player) {\x0a            var p = player.getPosition();\x0a            min = Math.min(p, min);\x0a        });\x0a        return min;\x0a    };\x0a    AnimationGroupPlayer.prototype.beforeDestroy = function () {\x0a        this.players.forEach(function (player) {\x0a            if (player.beforeDestroy) {\x0a                player.beforeDestroy();\x0a            }\x0a        });\x0a    };\x0a    /** @internal */\x0a    AnimationGroupPlayer.prototype.triggerCallback = function (phaseName) {\x0a        var methods = phaseName == \x27start\x27 ? this._onStartFns : this._onDoneFns;\x0a        methods.forEach(function (fn) { return fn(); });\x0a        methods.length = 0;\x0a    };\x0a    return AnimationGroupPlayer;\x0a}());\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0avar \xc9\xb5PRE_STYLE = \x27!\x27;\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a/**\x0a * Generated bundle index. Do not edit.\x0a */\x0a\x0a\x0a//# sourceMappingURL=animations.js.map\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/@angular/animations/fesm5/browser.js\x22:\x0a/*!***********************************************************!*\x5c\x0a  !*** ./node_modules/@angular/animations/fesm5/browser.js ***!\x0a  \x5c***********************************************************/\x0a/*! exports provided: AnimationDriver, \xc9\xb5Animation, \xc9\xb5AnimationStyleNormalizer, \xc9\xb5NoopAnimationStyleNormalizer, \xc9\xb5WebAnimationsStyleNormalizer, \xc9\xb5AnimationDriver, \xc9\xb5NoopAnimationDriver, \xc9\xb5AnimationEngine, \xc9\xb5CssKeyframesDriver, \xc9\xb5CssKeyframesPlayer, \xc9\xb5containsElement, \xc9\xb5invokeQuery, \xc9\xb5matchesElement, \xc9\xb5validateStyleProperty, \xc9\xb5WebAnimationsDriver, \xc9\xb5supportsWebAnimations, \xc9\xb5WebAnimationsPlayer, \xc9\xb5allowPreviousPlayerStylesMerge */\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22AnimationDriver\x22, function() { return AnimationDriver; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5Animation\x22, function() { return Animation; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5AnimationStyleNormalizer\x22, function() { return AnimationStyleNormalizer; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5NoopAnimationStyleNormalizer\x22, function() { return NoopAnimationStyleNormalizer; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5WebAnimationsStyleNormalizer\x22, function() { return WebAnimationsStyleNormalizer; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5AnimationDriver\x22, function() { return AnimationDriver; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5NoopAnimationDriver\x22, function() { return NoopAnimationDriver; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5AnimationEngine\x22, function() { return AnimationEngine; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5CssKeyframesDriver\x22, function() { return CssKeyframesDriver; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5CssKeyframesPlayer\x22, function() { return CssKeyframesPlayer; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5containsElement\x22, function() { return containsElement; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5invokeQuery\x22, function() { return invokeQuery; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5matchesElement\x22, function() { return matchesElement; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5validateStyleProperty\x22, function() { return validateStyleProperty; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5WebAnimationsDriver\x22, function() { return WebAnimationsDriver; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5supportsWebAnimations\x22, function() { return supportsWebAnimations; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5WebAnimationsPlayer\x22, function() { return WebAnimationsPlayer; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5allowPreviousPlayerStylesMerge\x22, function() { return allowPreviousPlayerStylesMerge; });\x0a/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \x22./node_modules/tslib/tslib.es6.js\x22);\x0a/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/animations */ \x22./node_modules/@angular/animations/fesm5/animations.js\x22);\x0a/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ \x22./node_modules/@angular/core/fesm5/core.js\x22);\x0a/**\x0a * @license Angular v7.0.3\x0a * (c) 2010-2018 Google, Inc. https://angular.io/\x0a * License: MIT\x0a */\x0a\x0a\x0a\x0a\x0a\x0afunction isBrowser() {\x0a    return (typeof window !== \x27undefined\x27 && typeof window.document !== \x27undefined\x27);\x0a}\x0afunction isNode() {\x0a    return (typeof process !== \x27undefined\x27);\x0a}\x0afunction optimizeGroupPlayer(players) {\x0a    switch (players.length) {\x0a        case 0:\x0a            return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22NoopAnimationPlayer\x22]();\x0a        case 1:\x0a            return players[0];\x0a        default:\x0a            return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22\xc9\xb5AnimationGroupPlayer\x22](players);\x0a    }\x0a}\x0afunction normalizeKeyframes(driver, normalizer, element, keyframes, preStyles, postStyles) {\x0a    if (preStyles === void 0) { preStyles = {}; }\x0a    if (postStyles === void 0) { postStyles = {}; }\x0a    var errors = [];\x0a    var normalizedKeyframes = [];\x0a    var previousOffset = -1;\x0a    var previousKeyframe = null;\x0a    keyframes.forEach(function (kf) {\x0a        var offset = kf[\x27offset\x27];\x0a        var isSameOffset = offset == previousOffset;\x0a        var normalizedKeyframe = (isSameOffset && previousKeyframe) || {};\x0a        Object.keys(kf).forEach(function (prop) {\x0a            var normalizedProp = prop;\x0a            var normalizedValue = kf[prop];\x0a            if (prop !== \x27offset\x27) {\x0a                normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);\x0a                switch (normalizedValue) {\x0a                    case _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22\xc9\xb5PRE_STYLE\x22]:\x0a                        normalizedValue = preStyles[prop];\x0a                        break;\x0a                    case _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22AUTO_STYLE\x22]:\x0a                        normalizedValue = postStyles[prop];\x0a                        break;\x0a                    default:\x0a                        normalizedValue =\x0a                            normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);\x0a                        break;\x0a                }\x0a            }\x0a            normalizedKeyframe[normalizedProp] = normalizedValue;\x0a        });\x0a        if (!isSameOffset) {\x0a            normalizedKeyframes.push(normalizedKeyframe);\x0a        }\x0a        previousKeyframe = normalizedKeyframe;\x0a        previousOffset = offset;\x0a    });\x0a    if (errors.length) {\x0a        var LINE_START = \x27\x5cn - \x27;\x0a        throw new Error(\x22Unable to animate due to the following errors:\x22 + LINE_START + errors.join(LINE_START));\x0a    }\x0a    return normalizedKeyframes;\x0a}\x0afunction listenOnPlayer(player, eventName, event, callback) {\x0a    switch (eventName) {\x0a        case \x27start\x27:\x0a            player.onStart(function () { return callback(event && copyAnimationEvent(event, \x27start\x27, player)); });\x0a            break;\x0a        case \x27done\x27:\x0a            player.onDone(function () { return callback(event && copyAnimationEvent(event, \x27done\x27, player)); });\x0a            break;\x0a        case \x27destroy\x27:\x0a            player.onDestroy(function () { return callback(event && copyAnimationEvent(event, \x27destroy\x27, player)); });\x0a            break;\x0a    }\x0a}\x0afunction copyAnimationEvent(e, phaseName, player) {\x0a    var totalTime = player.totalTime;\x0a    var disabled = player.disabled ? true : false;\x0a    var event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime, disabled);\x0a    var data = e[\x27_data\x27];\x0a    if (data != null) {\x0a        event[\x27_data\x27] = data;\x0a    }\x0a    return event;\x0a}\x0afunction makeAnimationEvent(element, triggerName, fromState, toState, phaseName, totalTime, disabled) {\x0a    if (phaseName === void 0) { phaseName = \x27\x27; }\x0a    if (totalTime === void 0) { totalTime = 0; }\x0a    return { element: element, triggerName: triggerName, fromState: fromState, toState: toState, phaseName: phaseName, totalTime: totalTime, disabled: !!disabled };\x0a}\x0afunction getOrSetAsInMap(map, key, defaultValue) {\x0a    var value;\x0a    if (map instanceof Map) {\x0a        value = map.get(key);\x0a        if (!value) {\x0a            map.set(key, value = defaultValue);\x0a        }\x0a    }\x0a    else {\x0a        value = map[key];\x0a        if (!value) {\x0a            value = map[key] = defaultValue;\x0a        }\x0a    }\x0a    return value;\x0a}\x0afunction parseTimelineCommand(command) {\x0a    var separatorPos = command.indexOf(\x27:\x27);\x0a    var id = command.substring(1, separatorPos);\x0a    var action = command.substr(separatorPos + 1);\x0a    return [id, action];\x0a}\x0avar _contains = function (elm1, elm2) { return false; };\x0avar _matches = function (element, selector) {\x0a    return false;\x0a};\x0avar _query = function (element, selector, multi) {\x0a    return [];\x0a};\x0a// Define utility methods for browsers and platform-server(domino) where Element\x0a// and utility methods exist.\x0avar _isNode = isNode();\x0aif (_isNode || typeof Element !== \x27undefined\x27) {\x0a    // this is well supported in all browsers\x0a    _contains = function (elm1, elm2) { return elm1.contains(elm2); };\x0a    if (_isNode || Element.prototype.matches) {\x0a        _matches = function (element, selector) { return element.matches(selector); };\x0a    }\x0a    else {\x0a        var proto = Element.prototype;\x0a        var fn_1 = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||\x0a            proto.oMatchesSelector || proto.webkitMatchesSelector;\x0a        if (fn_1) {\x0a            _matches = function (element, selector) { return fn_1.apply(element, [selector]); };\x0a        }\x0a    }\x0a    _query = function (element, selector, multi) {\x0a        var results = [];\x0a        if (multi) {\x0a            results.push.apply(results, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__spread\x22])(element.querySelectorAll(selector)));\x0a        }\x0a        else {\x0a            var elm = element.querySelector(selector);\x0a            if (elm) {\x0a                results.push(elm);\x0a            }\x0a        }\x0a        return results;\x0a    };\x0a}\x0afunction containsVendorPrefix(prop) {\x0a    // Webkit is the only real popular vendor prefix nowadays\x0a    // cc: http://shouldiprefix.com/\x0a    return prop.substring(1, 6) == \x27ebkit\x27; // webkit or Webkit\x0a}\x0avar _CACHED_BODY = null;\x0avar _IS_WEBKIT = false;\x0afunction validateStyleProperty(prop) {\x0a    if (!_CACHED_BODY) {\x0a        _CACHED_BODY = getBodyNode() || {};\x0a        _IS_WEBKIT = _CACHED_BODY.style ? (\x27WebkitAppearance\x27 in _CACHED_BODY.style) : false;\x0a    }\x0a    var result = true;\x0a    if (_CACHED_BODY.style && !containsVendorPrefix(prop)) {\x0a        result = prop in _CACHED_BODY.style;\x0a        if (!result && _IS_WEBKIT) {\x0a            var camelProp = \x27Webkit\x27 + prop.charAt(0).toUpperCase() + prop.substr(1);\x0a            result = camelProp in _CACHED_BODY.style;\x0a        }\x0a    }\x0a    return result;\x0a}\x0afunction getBodyNode() {\x0a    if (typeof document != \x27undefined\x27) {\x0a        return document.body;\x0a    }\x0a    return null;\x0a}\x0avar matchesElement = _matches;\x0avar containsElement = _contains;\x0avar invokeQuery = _query;\x0afunction hypenatePropsObject(object) {\x0a    var newObj = {};\x0a    Object.keys(object).forEach(function (prop) {\x0a        var newProp = prop.replace(/([a-z])([A-Z])/g, \x27$1-$2\x27);\x0a        newObj[newProp] = object[prop];\x0a    });\x0a    return newObj;\x0a}\x0a\x0a/**\x0a * @publicApi\x0a */\x0avar NoopAnimationDriver = /** @class */ (function () {\x0a    function NoopAnimationDriver() {\x0a    }\x0a    NoopAnimationDriver.prototype.validateStyleProperty = function (prop) { return validateStyleProperty(prop); };\x0a    NoopAnimationDriver.prototype.matchesElement = function (element, selector) {\x0a        return matchesElement(element, selector);\x0a    };\x0a    NoopAnimationDriver.prototype.containsElement = function (elm1, elm2) { return containsElement(elm1, elm2); };\x0a    NoopAnimationDriver.prototype.query = function (element, selector, multi) {\x0a        return invokeQuery(element, selector, multi);\x0a    };\x0a    NoopAnimationDriver.prototype.computeStyle = function (element, prop, defaultValue) {\x0a        return defaultValue || \x27\x27;\x0a    };\x0a    NoopAnimationDriver.prototype.animate = function (element, keyframes, duration, delay, easing, previousPlayers, scrubberAccessRequested) {\x0a        if (previousPlayers === void 0) { previousPlayers = []; }\x0a        return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22NoopAnimationPlayer\x22](duration, delay);\x0a    };\x0a    NoopAnimationDriver = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__decorate\x22])([\x0a        Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\x22Injectable\x22])()\x0a    ], NoopAnimationDriver);\x0a    return NoopAnimationDriver;\x0a}());\x0a/**\x0a * @publicApi\x0a */\x0avar AnimationDriver = /** @class */ (function () {\x0a    function AnimationDriver() {\x0a    }\x0a    AnimationDriver.NOOP = new NoopAnimationDriver();\x0a    return AnimationDriver;\x0a}());\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0avar ONE_SECOND = 1000;\x0avar SUBSTITUTION_EXPR_START = \x27{{\x27;\x0avar SUBSTITUTION_EXPR_END = \x27}}\x27;\x0avar ENTER_CLASSNAME = \x27ng-enter\x27;\x0avar LEAVE_CLASSNAME = \x27ng-leave\x27;\x0avar NG_TRIGGER_CLASSNAME = \x27ng-trigger\x27;\x0avar NG_TRIGGER_SELECTOR = \x27.ng-trigger\x27;\x0avar NG_ANIMATING_CLASSNAME = \x27ng-animating\x27;\x0avar NG_ANIMATING_SELECTOR = \x27.ng-animating\x27;\x0afunction resolveTimingValue(value) {\x0a    if (typeof value == \x27number\x27)\x0a        return value;\x0a    var matches = value.match(/^(-?[\x5c.\x5cd]+)(m?s)/);\x0a    if (!matches || matches.length \x3c 2)\x0a        return 0;\x0a    return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\x0a}\x0afunction _convertTimeValueToMS(value, unit) {\x0a    switch (unit) {\x0a        case \x27s\x27:\x0a            return value * ONE_SECOND;\x0a        default: // ms or something else\x0a            return value;\x0a    }\x0a}\x0afunction resolveTiming(timings, errors, allowNegativeValues) {\x0a    return timings.hasOwnProperty(\x27duration\x27) ?\x0a        timings :\x0a        parseTimeExpression(timings, errors, allowNegativeValues);\x0a}\x0afunction parseTimeExpression(exp, errors, allowNegativeValues) {\x0a    var regex = /^(-?[\x5c.\x5cd]+)(m?s)(?:\x5cs+(-?[\x5c.\x5cd]+)(m?s))?(?:\x5cs+([-a-z]+(?:\x5c(.+?\x5c))?))?$/i;\x0a    var duration;\x0a    var delay = 0;\x0a    var easing = \x27\x27;\x0a    if (typeof exp === \x27string\x27) {\x0a        var matches = exp.match(regex);\x0a        if (matches === null) {\x0a            errors.push(\x22The provided timing value \x5c\x22\x22 + exp + \x22\x5c\x22 is invalid.\x22);\x0a            return { duration: 0, delay: 0, easing: \x27\x27 };\x0a        }\x0a        duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\x0a        var delayMatch = matches[3];\x0a        if (delayMatch != null) {\x0a            delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);\x0a        }\x0a        var easingVal = matches[5];\x0a        if (easingVal) {\x0a            easing = easingVal;\x0a        }\x0a    }\x0a    else {\x0a        duration = exp;\x0a    }\x0a    if (!allowNegativeValues) {\x0a        var containsErrors = false;\x0a        var startIndex = errors.length;\x0a        if (duration \x3c 0) {\x0a            errors.push(\x22Duration values below 0 are not allowed for this animation step.\x22);\x0a            containsErrors = true;\x0a        }\x0a        if (delay \x3c 0) {\x0a            errors.push(\x22Delay values below 0 are not allowed for this animation step.\x22);\x0a            containsErrors = true;\x0a        }\x0a        if (containsErrors) {\x0a            errors.splice(startIndex, 0, \x22The provided timing value \x5c\x22\x22 + exp + \x22\x5c\x22 is invalid.\x22);\x0a        }\x0a    }\x0a    return { duration: duration, delay: delay, easing: easing };\x0a}\x0afunction copyObj(obj, destination) {\x0a    if (destination === void 0) { destination = {}; }\x0a    Object.keys(obj).forEach(function (prop) { destination[prop] = obj[prop]; });\x0a    return destination;\x0a}\x0afunction normalizeStyles(styles) {\x0a    var normalizedStyles = {};\x0a    if (Array.isArray(styles)) {\x0a        styles.forEach(function (data) { return copyStyles(data, false, normalizedStyles); });\x0a    }\x0a    else {\x0a        copyStyles(styles, false, normalizedStyles);\x0a    }\x0a    return normalizedStyles;\x0a}\x0afunction copyStyles(styles, readPrototype, destination) {\x0a    if (destination === void 0) { destination = {}; }\x0a    if (readPrototype) {\x0a        // we make use of a for-in loop so that the\x0a        // prototypically inherited properties are\x0a        // revealed from the backFill map\x0a        for (var prop in styles) {\x0a            destination[prop] = styles[prop];\x0a        }\x0a    }\x0a    else {\x0a        copyObj(styles, destination);\x0a    }\x0a    return destination;\x0a}\x0afunction getStyleAttributeString(element, key, value) {\x0a    // Return the key-value pair string to be added to the style attribute for the\x0a    // given CSS style key.\x0a    if (value) {\x0a        return key + \x27:\x27 + value + \x27;\x27;\x0a    }\x0a    else {\x0a        return \x27\x27;\x0a    }\x0a}\x0afunction writeStyleAttribute(element) {\x0a    // Read the style property of the element and manually reflect it to the\x0a    // style attribute. This is needed because Domino on platform-server doesn\x27t\x0a    // understand the full set of allowed CSS properties and doesn\x27t reflect some\x0a    // of them automatically.\x0a    var styleAttrValue = \x27\x27;\x0a    for (var i = 0; i \x3c element.style.length; i++) {\x0a        var key = element.style.item(i);\x0a        styleAttrValue += getStyleAttributeString(element, key, element.style.getPropertyValue(key));\x0a    }\x0a    for (var key in element.style) {\x0a        // Skip internal Domino properties that don\x27t need to be reflected.\x0a        if (!element.style.hasOwnProperty(key) || key.startsWith(\x27_\x27)) {\x0a            continue;\x0a        }\x0a        var dashKey = camelCaseToDashCase(key);\x0a        styleAttrValue += getStyleAttributeString(element, dashKey, element.style[key]);\x0a    }\x0a    element.setAttribute(\x27style\x27, styleAttrValue);\x0a}\x0afunction setStyles(element, styles) {\x0a    if (element[\x27style\x27]) {\x0a        Object.keys(styles).forEach(function (prop) {\x0a            var camelProp = dashCaseToCamelCase(prop);\x0a            element.style[camelProp] = styles[prop];\x0a        });\x0a        // On the server set the \x27style\x27 attribute since it\x27s not automatically reflected.\x0a        if (isNode()) {\x0a            writeStyleAttribute(element);\x0a        }\x0a    }\x0a}\x0afunction eraseStyles(element, styles) {\x0a    if (element[\x27style\x27]) {\x0a        Object.keys(styles).forEach(function (prop) {\x0a            var camelProp = dashCaseToCamelCase(prop);\x0a            element.style[camelProp] = \x27\x27;\x0a        });\x0a        // On the server set the \x27style\x27 attribute since it\x27s not automatically reflected.\x0a        if (isNode()) {\x0a            writeStyleAttribute(element);\x0a        }\x0a    }\x0a}\x0afunction normalizeAnimationEntry(steps) {\x0a    if (Array.isArray(steps)) {\x0a        if (steps.length == 1)\x0a            return steps[0];\x0a        return Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22sequence\x22])(steps);\x0a    }\x0a    return steps;\x0a}\x0afunction validateStyleParams(value, options, errors) {\x0a    var params = options.params || {};\x0a    var matches = extractStyleParams(value);\x0a    if (matches.length) {\x0a        matches.forEach(function (varName) {\x0a            if (!params.hasOwnProperty(varName)) {\x0a                errors.push(\x22Unable to resolve the local animation param \x22 + varName + \x22 in the given list of values\x22);\x0a            }\x0a        });\x0a    }\x0a}\x0avar PARAM_REGEX = new RegExp(SUBSTITUTION_EXPR_START + \x22\x5c\x5cs*(.+?)\x5c\x5cs*\x22 + SUBSTITUTION_EXPR_END, \x27g\x27);\x0afunction extractStyleParams(value) {\x0a    var params = [];\x0a    if (typeof value === \x27string\x27) {\x0a        var val = value.toString();\x0a        var match = void 0;\x0a        while (match = PARAM_REGEX.exec(val)) {\x0a            params.push(match[1]);\x0a        }\x0a        PARAM_REGEX.lastIndex = 0;\x0a    }\x0a    return params;\x0a}\x0afunction interpolateParams(value, params, errors) {\x0a    var original = value.toString();\x0a    var str = original.replace(PARAM_REGEX, function (_, varName) {\x0a        var localVal = params[varName];\x0a        // this means that the value was never overridden by the data passed in by the user\x0a        if (!params.hasOwnProperty(varName)) {\x0a            errors.push(\x22Please provide a value for the animation param \x22 + varName);\x0a            localVal = \x27\x27;\x0a        }\x0a        return localVal.toString();\x0a    });\x0a    // we do this to assert that numeric values stay as they are\x0a    return str == original ? value : str;\x0a}\x0afunction iteratorToArray(iterator) {\x0a    var arr = [];\x0a    var item = iterator.next();\x0a    while (!item.done) {\x0a        arr.push(item.value);\x0a        item = iterator.next();\x0a    }\x0a    return arr;\x0a}\x0avar DASH_CASE_REGEXP = /-+([a-z0-9])/g;\x0afunction dashCaseToCamelCase(input) {\x0a    return input.replace(DASH_CASE_REGEXP, function () {\x0a        var m = [];\x0a        for (var _i = 0; _i \x3c arguments.length; _i++) {\x0a            m[_i] = arguments[_i];\x0a        }\x0a        return m[1].toUpperCase();\x0a    });\x0a}\x0afunction camelCaseToDashCase(input) {\x0a    return input.replace(/([a-z])([A-Z])/g, \x27$1-$2\x27).toLowerCase();\x0a}\x0afunction allowPreviousPlayerStylesMerge(duration, delay) {\x0a    return duration === 0 || delay === 0;\x0a}\x0afunction balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles) {\x0a    var previousStyleProps = Object.keys(previousStyles);\x0a    if (previousStyleProps.length && keyframes.length) {\x0a        var startingKeyframe_1 = keyframes[0];\x0a        var missingStyleProps_1 = [];\x0a        previousStyleProps.forEach(function (prop) {\x0a            if (!startingKeyframe_1.hasOwnProperty(prop)) {\x0a                missingStyleProps_1.push(prop);\x0a            }\x0a            startingKeyframe_1[prop] = previousStyles[prop];\x0a        });\x0a        if (missingStyleProps_1.length) {\x0a            var _loop_1 = function () {\x0a                var kf = keyframes[i];\x0a                missingStyleProps_1.forEach(function (prop) { kf[prop] = computeStyle(element, prop); });\x0a            };\x0a            // tslint:disable-next-line\x0a            for (var i = 1; i \x3c keyframes.length; i++) {\x0a                _loop_1();\x0a            }\x0a        }\x0a    }\x0a    return keyframes;\x0a}\x0afunction visitDslNode(visitor, node, context) {\x0a    switch (node.type) {\x0a        case 7 /* Trigger */:\x0a            return visitor.visitTrigger(node, context);\x0a        case 0 /* State */:\x0a            return visitor.visitState(node, context);\x0a        case 1 /* Transition */:\x0a            return visitor.visitTransition(node, context);\x0a        case 2 /* Sequence */:\x0a            return visitor.visitSequence(node, context);\x0a        case 3 /* Group */:\x0a            return visitor.visitGroup(node, context);\x0a        case 4 /* Animate */:\x0a            return visitor.visitAnimate(node, context);\x0a        case 5 /* Keyframes */:\x0a            return visitor.visitKeyframes(node, context);\x0a        case 6 /* Style */:\x0a            return visitor.visitStyle(node, context);\x0a        case 8 /* Reference */:\x0a            return visitor.visitReference(node, context);\x0a        case 9 /* AnimateChild */:\x0a            return visitor.visitAnimateChild(node, context);\x0a        case 10 /* AnimateRef */:\x0a            return visitor.visitAnimateRef(node, context);\x0a        case 11 /* Query */:\x0a            return visitor.visitQuery(node, context);\x0a        case 12 /* Stagger */:\x0a            return visitor.visitStagger(node, context);\x0a        default:\x0a            throw new Error(\x22Unable to resolve animation metadata node #\x22 + node.type);\x0a    }\x0a}\x0afunction computeStyle(element, prop) {\x0a    return window.getComputedStyle(element)[prop];\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0avar ANY_STATE = \x27*\x27;\x0afunction parseTransitionExpr(transitionValue, errors) {\x0a    var expressions = [];\x0a    if (typeof transitionValue == \x27string\x27) {\x0a        transitionValue\x0a            .split(/\x5cs*,\x5cs*/)\x0a            .forEach(function (str) { return parseInnerTransitionStr(str, expressions, errors); });\x0a    }\x0a    else {\x0a        expressions.push(transitionValue);\x0a    }\x0a    return expressions;\x0a}\x0afunction parseInnerTransitionStr(eventStr, expressions, errors) {\x0a    if (eventStr[0] == \x27:\x27) {\x0a        var result = parseAnimationAlias(eventStr, errors);\x0a        if (typeof result == \x27function\x27) {\x0a            expressions.push(result);\x0a            return;\x0a        }\x0a        eventStr = result;\x0a    }\x0a    var match = eventStr.match(/^(\x5c*|[-\x5cw]+)\x5cs*(\x3c?[=-]\x3e)\x5cs*(\x5c*|[-\x5cw]+)$/);\x0a    if (match == null || match.length \x3c 4) {\x0a        errors.push(\x22The provided transition expression \x5c\x22\x22 + eventStr + \x22\x5c\x22 is not supported\x22);\x0a        return expressions;\x0a    }\x0a    var fromState = match[1];\x0a    var separator = match[2];\x0a    var toState = match[3];\x0a    expressions.push(makeLambdaFromStates(fromState, toState));\x0a    var isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\x0a    if (separator[0] == \x27\x3c\x27 && !isFullAnyStateExpr) {\x0a        expressions.push(makeLambdaFromStates(toState, fromState));\x0a    }\x0a}\x0afunction parseAnimationAlias(alias, errors) {\x0a    switch (alias) {\x0a        case \x27:enter\x27:\x0a            return \x27void =\x3e *\x27;\x0a        case \x27:leave\x27:\x0a            return \x27* =\x3e void\x27;\x0a        case \x27:increment\x27:\x0a            return function (fromState, toState) { return parseFloat(toState) \x3e parseFloat(fromState); };\x0a        case \x27:decrement\x27:\x0a            return function (fromState, toState) { return parseFloat(toState) \x3c parseFloat(fromState); };\x0a        default:\x0a            errors.push(\x22The transition alias value \x5c\x22\x22 + alias + \x22\x5c\x22 is not supported\x22);\x0a            return \x27* =\x3e *\x27;\x0a    }\x0a}\x0a// DO NOT REFACTOR ... keep the follow set instantiations\x0a// with the values intact (closure compiler for some reason\x0a// removes follow-up lines that add the values outside of\x0a// the constructor...\x0avar TRUE_BOOLEAN_VALUES = new Set([\x27true\x27, \x271\x27]);\x0avar FALSE_BOOLEAN_VALUES = new Set([\x27false\x27, \x270\x27]);\x0afunction makeLambdaFromStates(lhs, rhs) {\x0a    var LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);\x0a    var RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);\x0a    return function (fromState, toState) {\x0a        var lhsMatch = lhs == ANY_STATE || lhs == fromState;\x0a        var rhsMatch = rhs == ANY_STATE || rhs == toState;\x0a        if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === \x27boolean\x27) {\x0a            lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);\x0a        }\x0a        if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === \x27boolean\x27) {\x0a            rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);\x0a        }\x0a        return lhsMatch && rhsMatch;\x0a    };\x0a}\x0a\x0avar SELF_TOKEN = \x27:self\x27;\x0avar SELF_TOKEN_REGEX = new RegExp(\x22s*\x22 + SELF_TOKEN + \x22s*,?\x22, \x27g\x27);\x0a/*\x0a * [Validation]\x0a * The visitor code below will traverse the animation AST generated by the animation verb functions\x0a * (the output is a tree of objects) and attempt to perform a series of validations on the data. The\x0a * following corner-cases will be validated:\x0a *\x0a * 1. Overlap of animations\x0a * Given that a CSS property cannot be animated in more than one place at the same time, it\x27s\x0a * important that this behaviour is detected and validated. The way in which this occurs is that\x0a * each time a style property is examined, a string-map containing the property will be updated with\x0a * the start and end times for when the property is used within an animation step.\x0a *\x0a * If there are two or more parallel animations that are currently running (these are invoked by the\x0a * group()) on the same element then the validator will throw an error. Since the start/end timing\x0a * values are collected for each property then if the current animation step is animating the same\x0a * property and its timing values fall anywhere into the window of time that the property is\x0a * currently being animated within then this is what causes an error.\x0a *\x0a * 2. Timing values\x0a * The validator will validate to see if a timing value of `duration delay easing` or\x0a * `durationNumber` is valid or not.\x0a *\x0a * (note that upon validation the code below will replace the timing data with an object containing\x0a * {duration,delay,easing}.\x0a *\x0a * 3. Offset Validation\x0a * Each of the style() calls are allowed to have an offset value when placed inside of keyframes().\x0a * Offsets within keyframes() are considered valid when:\x0a *\x0a *   - No offsets are used at all\x0a *   - Each style() entry contains an offset value\x0a *   - Each offset is between 0 and 1\x0a *   - Each offset is greater to or equal than the previous one\x0a *\x0a * Otherwise an error will be thrown.\x0a */\x0afunction buildAnimationAst(driver, metadata, errors) {\x0a    return new AnimationAstBuilderVisitor(driver).build(metadata, errors);\x0a}\x0avar ROOT_SELECTOR = \x27\x27;\x0avar AnimationAstBuilderVisitor = /** @class */ (function () {\x0a    function AnimationAstBuilderVisitor(_driver) {\x0a        this._driver = _driver;\x0a    }\x0a    AnimationAstBuilderVisitor.prototype.build = function (metadata, errors) {\x0a        var context = new AnimationAstBuilderContext(errors);\x0a        this._resetContextStyleTimingState(context);\x0a        return visitDslNode(this, normalizeAnimationEntry(metadata), context);\x0a    };\x0a    AnimationAstBuilderVisitor.prototype._resetContextStyleTimingState = function (context) {\x0a        context.currentQuerySelector = ROOT_SELECTOR;\x0a        context.collectedStyles = {};\x0a        context.collectedStyles[ROOT_SELECTOR] = {};\x0a        context.currentTime = 0;\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitTrigger = function (metadata, context) {\x0a        var _this = this;\x0a        var queryCount = context.queryCount = 0;\x0a        var depCount = context.depCount = 0;\x0a        var states = [];\x0a        var transitions = [];\x0a        if (metadata.name.charAt(0) == \x27@\x27) {\x0a            context.errors.push(\x27animation triggers cannot be prefixed with an `@` sign (e.g. trigger(\x5c\x27@foo\x5c\x27, [...]))\x27);\x0a        }\x0a        metadata.definitions.forEach(function (def) {\x0a            _this._resetContextStyleTimingState(context);\x0a            if (def.type == 0 /* State */) {\x0a                var stateDef_1 = def;\x0a                var name_1 = stateDef_1.name;\x0a                name_1.toString().split(/\x5cs*,\x5cs*/).forEach(function (n) {\x0a                    stateDef_1.name = n;\x0a                    states.push(_this.visitState(stateDef_1, context));\x0a                });\x0a                stateDef_1.name = name_1;\x0a            }\x0a            else if (def.type == 1 /* Transition */) {\x0a                var transition = _this.visitTransition(def, context);\x0a                queryCount += transition.queryCount;\x0a                depCount += transition.depCount;\x0a                transitions.push(transition);\x0a            }\x0a            else {\x0a                context.errors.push(\x27only state() and transition() definitions can sit inside of a trigger()\x27);\x0a            }\x0a        });\x0a        return {\x0a            type: 7 /* Trigger */,\x0a            name: metadata.name, states: states, transitions: transitions, queryCount: queryCount, depCount: depCount,\x0a            options: null\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitState = function (metadata, context) {\x0a        var styleAst = this.visitStyle(metadata.styles, context);\x0a        var astParams = (metadata.options && metadata.options.params) || null;\x0a        if (styleAst.containsDynamicStyles) {\x0a            var missingSubs_1 = new Set();\x0a            var params_1 = astParams || {};\x0a            styleAst.styles.forEach(function (value) {\x0a                if (isObject(value)) {\x0a                    var stylesObj_1 = value;\x0a                    Object.keys(stylesObj_1).forEach(function (prop) {\x0a                        extractStyleParams(stylesObj_1[prop]).forEach(function (sub) {\x0a                            if (!params_1.hasOwnProperty(sub)) {\x0a                                missingSubs_1.add(sub);\x0a                            }\x0a                        });\x0a                    });\x0a                }\x0a            });\x0a            if (missingSubs_1.size) {\x0a                var missingSubsArr = iteratorToArray(missingSubs_1.values());\x0a                context.errors.push(\x22state(\x5c\x22\x22 + metadata.name + \x22\x5c\x22, ...) must define default values for all the following style substitutions: \x22 + missingSubsArr.join(\x27, \x27));\x0a            }\x0a        }\x0a        return {\x0a            type: 0 /* State */,\x0a            name: metadata.name,\x0a            style: styleAst,\x0a            options: astParams ? { params: astParams } : null\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitTransition = function (metadata, context) {\x0a        context.queryCount = 0;\x0a        context.depCount = 0;\x0a        var animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\x0a        var matchers = parseTransitionExpr(metadata.expr, context.errors);\x0a        return {\x0a            type: 1 /* Transition */,\x0a            matchers: matchers,\x0a            animation: animation,\x0a            queryCount: context.queryCount,\x0a            depCount: context.depCount,\x0a            options: normalizeAnimationOptions(metadata.options)\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitSequence = function (metadata, context) {\x0a        var _this = this;\x0a        return {\x0a            type: 2 /* Sequence */,\x0a            steps: metadata.steps.map(function (s) { return visitDslNode(_this, s, context); }),\x0a            options: normalizeAnimationOptions(metadata.options)\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitGroup = function (metadata, context) {\x0a        var _this = this;\x0a        var currentTime = context.currentTime;\x0a        var furthestTime = 0;\x0a        var steps = metadata.steps.map(function (step) {\x0a            context.currentTime = currentTime;\x0a            var innerAst = visitDslNode(_this, step, context);\x0a            furthestTime = Math.max(furthestTime, context.currentTime);\x0a            return innerAst;\x0a        });\x0a        context.currentTime = furthestTime;\x0a        return {\x0a            type: 3 /* Group */,\x0a            steps: steps,\x0a            options: normalizeAnimationOptions(metadata.options)\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitAnimate = function (metadata, context) {\x0a        var timingAst = constructTimingAst(metadata.timings, context.errors);\x0a        context.currentAnimateTimings = timingAst;\x0a        var styleAst;\x0a        var styleMetadata = metadata.styles ? metadata.styles : Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22style\x22])({});\x0a        if (styleMetadata.type == 5 /* Keyframes */) {\x0a            styleAst = this.visitKeyframes(styleMetadata, context);\x0a        }\x0a        else {\x0a            var styleMetadata_1 = metadata.styles;\x0a            var isEmpty = false;\x0a            if (!styleMetadata_1) {\x0a                isEmpty = true;\x0a                var newStyleData = {};\x0a                if (timingAst.easing) {\x0a                    newStyleData[\x27easing\x27] = timingAst.easing;\x0a                }\x0a                styleMetadata_1 = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22style\x22])(newStyleData);\x0a            }\x0a            context.currentTime += timingAst.duration + timingAst.delay;\x0a            var _styleAst = this.visitStyle(styleMetadata_1, context);\x0a            _styleAst.isEmptyStep = isEmpty;\x0a            styleAst = _styleAst;\x0a        }\x0a        context.currentAnimateTimings = null;\x0a        return {\x0a            type: 4 /* Animate */,\x0a            timings: timingAst,\x0a            style: styleAst,\x0a            options: null\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitStyle = function (metadata, context) {\x0a        var ast = this._makeStyleAst(metadata, context);\x0a        this._validateStyleAst(ast, context);\x0a        return ast;\x0a    };\x0a    AnimationAstBuilderVisitor.prototype._makeStyleAst = function (metadata, context) {\x0a        var styles = [];\x0a        if (Array.isArray(metadata.styles)) {\x0a            metadata.styles.forEach(function (styleTuple) {\x0a                if (typeof styleTuple == \x27string\x27) {\x0a                    if (styleTuple == _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22AUTO_STYLE\x22]) {\x0a                        styles.push(styleTuple);\x0a                    }\x0a                    else {\x0a                        context.errors.push(\x22The provided style string value \x22 + styleTuple + \x22 is not allowed.\x22);\x0a                    }\x0a                }\x0a                else {\x0a                    styles.push(styleTuple);\x0a                }\x0a            });\x0a        }\x0a        else {\x0a            styles.push(metadata.styles);\x0a        }\x0a        var containsDynamicStyles = false;\x0a        var collectedEasing = null;\x0a        styles.forEach(function (styleData) {\x0a            if (isObject(styleData)) {\x0a                var styleMap = styleData;\x0a                var easing = styleMap[\x27easing\x27];\x0a                if (easing) {\x0a                    collectedEasing = easing;\x0a                    delete styleMap[\x27easing\x27];\x0a                }\x0a                if (!containsDynamicStyles) {\x0a                    for (var prop in styleMap) {\x0a                        var value = styleMap[prop];\x0a                        if (value.toString().indexOf(SUBSTITUTION_EXPR_START) \x3e= 0) {\x0a                            containsDynamicStyles = true;\x0a                            break;\x0a                        }\x0a                    }\x0a                }\x0a            }\x0a        });\x0a        return {\x0a            type: 6 /* Style */,\x0a            styles: styles,\x0a            easing: collectedEasing,\x0a            offset: metadata.offset, containsDynamicStyles: containsDynamicStyles,\x0a            options: null\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype._validateStyleAst = function (ast, context) {\x0a        var _this = this;\x0a        var timings = context.currentAnimateTimings;\x0a        var endTime = context.currentTime;\x0a        var startTime = context.currentTime;\x0a        if (timings && startTime \x3e 0) {\x0a            startTime -= timings.duration + timings.delay;\x0a        }\x0a        ast.styles.forEach(function (tuple) {\x0a            if (typeof tuple == \x27string\x27)\x0a                return;\x0a            Object.keys(tuple).forEach(function (prop) {\x0a                if (!_this._driver.validateStyleProperty(prop)) {\x0a                    context.errors.push(\x22The provided animation property \x5c\x22\x22 + prop + \x22\x5c\x22 is not a supported CSS property for animations\x22);\x0a                    return;\x0a                }\x0a                var collectedStyles = context.collectedStyles[context.currentQuerySelector];\x0a                var collectedEntry = collectedStyles[prop];\x0a                var updateCollectedStyle = true;\x0a                if (collectedEntry) {\x0a                    if (startTime != endTime && startTime \x3e= collectedEntry.startTime &&\x0a                        endTime \x3c= collectedEntry.endTime) {\x0a                        context.errors.push(\x22The CSS property \x5c\x22\x22 + prop + \x22\x5c\x22 that exists between the times of \x5c\x22\x22 + collectedEntry.startTime + \x22ms\x5c\x22 and \x5c\x22\x22 + collectedEntry.endTime + \x22ms\x5c\x22 is also being animated in a parallel animation between the times of \x5c\x22\x22 + startTime + \x22ms\x5c\x22 and \x5c\x22\x22 + endTime + \x22ms\x5c\x22\x22);\x0a                        updateCollectedStyle = false;\x0a                    }\x0a                    // we always choose the smaller start time value since we\x0a                    // want to have a record of the entire animation window where\x0a                    // the style property is being animated in between\x0a                    startTime = collectedEntry.startTime;\x0a                }\x0a                if (updateCollectedStyle) {\x0a                    collectedStyles[prop] = { startTime: startTime, endTime: endTime };\x0a                }\x0a                if (context.options) {\x0a                    validateStyleParams(tuple[prop], context.options, context.errors);\x0a                }\x0a            });\x0a        });\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitKeyframes = function (metadata, context) {\x0a        var _this = this;\x0a        var ast = { type: 5 /* Keyframes */, styles: [], options: null };\x0a        if (!context.currentAnimateTimings) {\x0a            context.errors.push(\x22keyframes() must be placed inside of a call to animate()\x22);\x0a            return ast;\x0a        }\x0a        var MAX_KEYFRAME_OFFSET = 1;\x0a        var totalKeyframesWithOffsets = 0;\x0a        var offsets = [];\x0a        var offsetsOutOfOrder = false;\x0a        var keyframesOutOfRange = false;\x0a        var previousOffset = 0;\x0a        var keyframes = metadata.steps.map(function (styles) {\x0a            var style$$1 = _this._makeStyleAst(styles, context);\x0a            var offsetVal = style$$1.offset != null ? style$$1.offset : consumeOffset(style$$1.styles);\x0a            var offset = 0;\x0a            if (offsetVal != null) {\x0a                totalKeyframesWithOffsets++;\x0a                offset = style$$1.offset = offsetVal;\x0a            }\x0a            keyframesOutOfRange = keyframesOutOfRange || offset \x3c 0 || offset \x3e 1;\x0a            offsetsOutOfOrder = offsetsOutOfOrder || offset \x3c previousOffset;\x0a            previousOffset = offset;\x0a            offsets.push(offset);\x0a            return style$$1;\x0a        });\x0a        if (keyframesOutOfRange) {\x0a            context.errors.push(\x22Please ensure that all keyframe offsets are between 0 and 1\x22);\x0a        }\x0a        if (offsetsOutOfOrder) {\x0a            context.errors.push(\x22Please ensure that all keyframe offsets are in order\x22);\x0a        }\x0a        var length = metadata.steps.length;\x0a        var generatedOffset = 0;\x0a        if (totalKeyframesWithOffsets \x3e 0 && totalKeyframesWithOffsets \x3c length) {\x0a            context.errors.push(\x22Not all style() steps within the declared keyframes() contain offsets\x22);\x0a        }\x0a        else if (totalKeyframesWithOffsets == 0) {\x0a            generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);\x0a        }\x0a        var limit = length - 1;\x0a        var currentTime = context.currentTime;\x0a        var currentAnimateTimings = context.currentAnimateTimings;\x0a        var animateDuration = currentAnimateTimings.duration;\x0a        keyframes.forEach(function (kf, i) {\x0a            var offset = generatedOffset \x3e 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];\x0a            var durationUpToThisFrame = offset * animateDuration;\x0a            context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;\x0a            currentAnimateTimings.duration = durationUpToThisFrame;\x0a            _this._validateStyleAst(kf, context);\x0a            kf.offset = offset;\x0a            ast.styles.push(kf);\x0a        });\x0a        return ast;\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitReference = function (metadata, context) {\x0a        return {\x0a            type: 8 /* Reference */,\x0a            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),\x0a            options: normalizeAnimationOptions(metadata.options)\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitAnimateChild = function (metadata, context) {\x0a        context.depCount++;\x0a        return {\x0a            type: 9 /* AnimateChild */,\x0a            options: normalizeAnimationOptions(metadata.options)\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitAnimateRef = function (metadata, context) {\x0a        return {\x0a            type: 10 /* AnimateRef */,\x0a            animation: this.visitReference(metadata.animation, context),\x0a            options: normalizeAnimationOptions(metadata.options)\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitQuery = function (metadata, context) {\x0a        var parentSelector = context.currentQuerySelector;\x0a        var options = (metadata.options || {});\x0a        context.queryCount++;\x0a        context.currentQuery = metadata;\x0a        var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__read\x22])(normalizeSelector(metadata.selector), 2), selector = _a[0], includeSelf = _a[1];\x0a        context.currentQuerySelector =\x0a            parentSelector.length ? (parentSelector + \x27 \x27 + selector) : selector;\x0a        getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});\x0a        var animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\x0a        context.currentQuery = null;\x0a        context.currentQuerySelector = parentSelector;\x0a        return {\x0a            type: 11 /* Query */,\x0a            selector: selector,\x0a            limit: options.limit || 0,\x0a            optional: !!options.optional, includeSelf: includeSelf, animation: animation,\x0a            originalSelector: metadata.selector,\x0a            options: normalizeAnimationOptions(metadata.options)\x0a        };\x0a    };\x0a    AnimationAstBuilderVisitor.prototype.visitStagger = function (metadata, context) {\x0a        if (!context.currentQuery) {\x0a            context.errors.push(\x22stagger() can only be used inside of query()\x22);\x0a        }\x0a        var timings = metadata.timings === \x27full\x27 ?\x0a            { duration: 0, delay: 0, easing: \x27full\x27 } :\x0a            resolveTiming(metadata.timings, context.errors, true);\x0a        return {\x0a            type: 12 /* Stagger */,\x0a            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context), timings: timings,\x0a            options: null\x0a        };\x0a    };\x0a    return AnimationAstBuilderVisitor;\x0a}());\x0afunction normalizeSelector(selector) {\x0a    var hasAmpersand = selector.split(/\x5cs*,\x5cs*/).find(function (token) { return token == SELF_TOKEN; }) ? true : false;\x0a    if (hasAmpersand) {\x0a        selector = selector.replace(SELF_TOKEN_REGEX, \x27\x27);\x0a    }\x0a    // the :enter and :leave selectors are filled in at runtime during timeline building\x0a    selector = selector.replace(/@\x5c*/g, NG_TRIGGER_SELECTOR)\x0a        .replace(/@\x5cw+/g, function (match) { return NG_TRIGGER_SELECTOR + \x27-\x27 + match.substr(1); })\x0a        .replace(/:animating/g, NG_ANIMATING_SELECTOR);\x0a    return [selector, hasAmpersand];\x0a}\x0afunction normalizeParams(obj) {\x0a    return obj ? copyObj(obj) : null;\x0a}\x0avar AnimationAstBuilderContext = /** @class */ (function () {\x0a    function AnimationAstBuilderContext(errors) {\x0a        this.errors = errors;\x0a        this.queryCount = 0;\x0a        this.depCount = 0;\x0a        this.currentTransition = null;\x0a        this.currentQuery = null;\x0a        this.currentQuerySelector = null;\x0a        this.currentAnimateTimings = null;\x0a        this.currentTime = 0;\x0a        this.collectedStyles = {};\x0a        this.options = null;\x0a    }\x0a    return AnimationAstBuilderContext;\x0a}());\x0afunction consumeOffset(styles) {\x0a    if (typeof styles == \x27string\x27)\x0a        return null;\x0a    var offset = null;\x0a    if (Array.isArray(styles)) {\x0a        styles.forEach(function (styleTuple) {\x0a            if (isObject(styleTuple) && styleTuple.hasOwnProperty(\x27offset\x27)) {\x0a                var obj = styleTuple;\x0a                offset = parseFloat(obj[\x27offset\x27]);\x0a                delete obj[\x27offset\x27];\x0a            }\x0a        });\x0a    }\x0a    else if (isObject(styles) && styles.hasOwnProperty(\x27offset\x27)) {\x0a        var obj = styles;\x0a        offset = parseFloat(obj[\x27offset\x27]);\x0a        delete obj[\x27offset\x27];\x0a    }\x0a    return offset;\x0a}\x0afunction isObject(value) {\x0a    return !Array.isArray(value) && typeof value == \x27object\x27;\x0a}\x0afunction constructTimingAst(value, errors) {\x0a    var timings = null;\x0a    if (value.hasOwnProperty(\x27duration\x27)) {\x0a        timings = value;\x0a    }\x0a    else if (typeof value == \x27number\x27) {\x0a        var duration = resolveTiming(value, errors).duration;\x0a        return makeTimingAst(duration, 0, \x27\x27);\x0a    }\x0a    var strValue = value;\x0a    var isDynamic = strValue.split(/\x5cs+/).some(function (v) { return v.charAt(0) == \x27{\x27 && v.charAt(1) == \x27{\x27; });\x0a    if (isDynamic) {\x0a        var ast = makeTimingAst(0, 0, \x27\x27);\x0a        ast.dynamic = true;\x0a        ast.strValue = strValue;\x0a        return ast;\x0a    }\x0a    timings = timings || resolveTiming(strValue, errors);\x0a    return makeTimingAst(timings.duration, timings.delay, timings.easing);\x0a}\x0afunction normalizeAnimationOptions(options) {\x0a    if (options) {\x0a        options = copyObj(options);\x0a        if (options[\x27params\x27]) {\x0a            options[\x27params\x27] = normalizeParams(options[\x27params\x27]);\x0a        }\x0a    }\x0a    else {\x0a        options = {};\x0a    }\x0a    return options;\x0a}\x0afunction makeTimingAst(duration, delay, easing) {\x0a    return { duration: duration, delay: delay, easing: easing };\x0a}\x0a\x0afunction createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing, subTimeline) {\x0a    if (easing === void 0) { easing = null; }\x0a    if (subTimeline === void 0) { subTimeline = false; }\x0a    return {\x0a        type: 1 /* TimelineAnimation */,\x0a        element: element,\x0a        keyframes: keyframes,\x0a        preStyleProps: preStyleProps,\x0a        postStyleProps: postStyleProps,\x0a        duration: duration,\x0a        delay: delay,\x0a        totalTime: duration + delay, easing: easing, subTimeline: subTimeline\x0a    };\x0a}\x0a\x0avar ElementInstructionMap = /** @class */ (function () {\x0a    function ElementInstructionMap() {\x0a        this._map = new Map();\x0a    }\x0a    ElementInstructionMap.prototype.consume = function (element) {\x0a        var instructions = this._map.get(element);\x0a        if (instructions) {\x0a            this._map.delete(element);\x0a        }\x0a        else {\x0a            instructions = [];\x0a        }\x0a        return instructions;\x0a    };\x0a    ElementInstructionMap.prototype.append = function (element, instructions) {\x0a        var existingInstructions = this._map.get(element);\x0a        if (!existingInstructions) {\x0a            this._map.set(element, existingInstructions = []);\x0a        }\x0a        existingInstructions.push.apply(existingInstructions, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__spread\x22])(instructions));\x0a    };\x0a    ElementInstructionMap.prototype.has = function (element) { return this._map.has(element); };\x0a    ElementInstructionMap.prototype.clear = function () { this._map.clear(); };\x0a    return ElementInstructionMap;\x0a}());\x0a\x0avar ONE_FRAME_IN_MILLISECONDS = 1;\x0avar ENTER_TOKEN = \x27:enter\x27;\x0avar ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, \x27g\x27);\x0avar LEAVE_TOKEN = \x27:leave\x27;\x0avar LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, \x27g\x27);\x0a/*\x0a * The code within this file aims to generate web-animations-compatible keyframes from Angular\x27s\x0a * animation DSL code.\x0a *\x0a * The code below will be converted from:\x0a *\x0a * ```\x0a * sequence([\x0a *   style({ opacity: 0 }),\x0a *   animate(1000, style({ opacity: 0 }))\x0a * ])\x0a * ```\x0a *\x0a * To:\x0a * ```\x0a * keyframes = [{ opacity: 0, offset: 0 }, { opacity: 1, offset: 1 }]\x0a * duration = 1000\x0a * delay = 0\x0a * easing = \x27\x27\x0a * ```\x0a *\x0a * For this operation to cover the combination of animation verbs (style, animate, group, etc...) a\x0a * combination of prototypical inheritance, AST traversal and merge-sort-like algorithms are used.\x0a *\x0a * [AST Traversal]\x0a * Each of the animation verbs, when executed, will return an string-map object representing what\x0a * type of action it is (style, animate, group, etc...) and the data associated with it. This means\x0a * that when functional composition mix of these functions is evaluated (like in the example above)\x0a * then it will end up producing a tree of objects representing the animation itself.\x0a *\x0a * When this animation object tree is processed by the visitor code below it will visit each of the\x0a * verb statements within the visitor. And during each visit it will build the context of the\x0a * animation keyframes by interacting with the `TimelineBuilder`.\x0a *\x0a * [TimelineBuilder]\x0a * This class is responsible for tracking the styles and building a series of keyframe objects for a\x0a * timeline between a start and end time. The builder starts off with an initial timeline and each\x0a * time the AST comes across a `group()`, `keyframes()` or a combination of the two wihtin a\x0a * `sequence()` then it will generate a sub timeline for each step as well as a new one after\x0a * they are complete.\x0a *\x0a * As the AST is traversed, the timing state on each of the timelines will be incremented. If a sub\x0a * timeline was created (based on one of the cases above) then the parent timeline will attempt to\x0a * merge the styles used within the sub timelines into itself (only with group() this will happen).\x0a * This happens with a merge operation (much like how the merge works in mergesort) and it will only\x0a * copy the most recently used styles from the sub timelines into the parent timeline. This ensures\x0a * that if the styles are used later on in another phase of the animation then they will be the most\x0a * up-to-date values.\x0a *\x0a * [How Missing Styles Are Updated]\x0a * Each timeline has a `backFill` property which is responsible for filling in new styles into\x0a * already processed keyframes if a new style shows up later within the animation sequence.\x0a *\x0a * ```\x0a * sequence([\x0a *   style({ width: 0 }),\x0a *   animate(1000, style({ width: 100 })),\x0a *   animate(1000, style({ width: 200 })),\x0a *   animate(1000, style({ width: 300 }))\x0a *   animate(1000, style({ width: 400, height: 400 })) // notice how `height` doesn\x27t exist anywhere\x0a * else\x0a * ])\x0a * ```\x0a *\x0a * What is happening here is that the `height` value is added later in the sequence, but is missing\x0a * from all previous animation steps. Therefore when a keyframe is created it would also be missing\x0a * from all previous keyframes up until where it is first used. For the timeline keyframe generation\x0a * to properly fill in the style it will place the previous value (the value from the parent\x0a * timeline) or a default value of `*` into the backFill object. Given that each of the keyframe\x0a * styles are objects that prototypically inhert from the backFill object, this means that if a\x0a * value is added into the backFill then it will automatically propagate any missing values to all\x0a * keyframes. Therefore the missing `height` value will be properly filled into the already\x0a * processed keyframes.\x0a *\x0a * When a sub-timeline is created it will have its own backFill property. This is done so that\x0a * styles present within the sub-timeline do not accidentally seep into the previous/future timeline\x0a * keyframes\x0a *\x0a * (For prototypically-inherited contents to be detected a `for(i in obj)` loop must be used.)\x0a *\x0a * [Validation]\x0a * The code in this file is not responsible for validation. That functionality happens with within\x0a * the `AnimationValidatorVisitor` code.\x0a */\x0afunction buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors) {\x0a    if (startingStyles === void 0) { startingStyles = {}; }\x0a    if (finalStyles === void 0) { finalStyles = {}; }\x0a    if (errors === void 0) { errors = []; }\x0a    return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);\x0a}\x0avar AnimationTimelineBuilderVisitor = /** @class */ (function () {\x0a    function AnimationTimelineBuilderVisitor() {\x0a    }\x0a    AnimationTimelineBuilderVisitor.prototype.buildKeyframes = function (driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors) {\x0a        if (errors === void 0) { errors = []; }\x0a        subInstructions = subInstructions || new ElementInstructionMap();\x0a        var context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);\x0a        context.options = options;\x0a        context.currentTimeline.setStyles([startingStyles], null, context.errors, options);\x0a        visitDslNode(this, ast, context);\x0a        // this checks to see if an actual animation happened\x0a        var timelines = context.timelines.filter(function (timeline) { return timeline.containsAnimation(); });\x0a        if (timelines.length && Object.keys(finalStyles).length) {\x0a            var tl = timelines[timelines.length - 1];\x0a            if (!tl.allowOnlyTimelineStyles()) {\x0a                tl.setStyles([finalStyles], null, context.errors, options);\x0a            }\x0a        }\x0a        return timelines.length ? timelines.map(function (timeline) { return timeline.buildKeyframes(); }) :\x0a            [createTimelineInstruction(rootElement, [], [], [], 0, 0, \x27\x27, false)];\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitTrigger = function (ast, context) {\x0a        // these values are not visited in this AST\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitState = function (ast, context) {\x0a        // these values are not visited in this AST\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitTransition = function (ast, context) {\x0a        // these values are not visited in this AST\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitAnimateChild = function (ast, context) {\x0a        var elementInstructions = context.subInstructions.consume(context.element);\x0a        if (elementInstructions) {\x0a            var innerContext = context.createSubContext(ast.options);\x0a            var startTime = context.currentTimeline.currentTime;\x0a            var endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);\x0a            if (startTime != endTime) {\x0a                // we do this on the upper context because we created a sub context for\x0a                // the sub child animations\x0a                context.transformIntoNewTimeline(endTime);\x0a            }\x0a        }\x0a        context.previousNode = ast;\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitAnimateRef = function (ast, context) {\x0a        var innerContext = context.createSubContext(ast.options);\x0a        innerContext.transformIntoNewTimeline();\x0a        this.visitReference(ast.animation, innerContext);\x0a        context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);\x0a        context.previousNode = ast;\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype._visitSubInstructions = function (instructions, context, options) {\x0a        var startTime = context.currentTimeline.currentTime;\x0a        var furthestTime = startTime;\x0a        // this is a special-case for when a user wants to skip a sub\x0a        // animation from being fired entirely.\x0a        var duration = options.duration != null ? resolveTimingValue(options.duration) : null;\x0a        var delay = options.delay != null ? resolveTimingValue(options.delay) : null;\x0a        if (duration !== 0) {\x0a            instructions.forEach(function (instruction) {\x0a                var instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);\x0a                furthestTime =\x0a                    Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);\x0a            });\x0a        }\x0a        return furthestTime;\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitReference = function (ast, context) {\x0a        context.updateOptions(ast.options, true);\x0a        visitDslNode(this, ast.animation, context);\x0a        context.previousNode = ast;\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitSequence = function (ast, context) {\x0a        var _this = this;\x0a        var subContextCount = context.subContextCount;\x0a        var ctx = context;\x0a        var options = ast.options;\x0a        if (options && (options.params || options.delay)) {\x0a            ctx = context.createSubContext(options);\x0a            ctx.transformIntoNewTimeline();\x0a            if (options.delay != null) {\x0a                if (ctx.previousNode.type == 6 /* Style */) {\x0a                    ctx.currentTimeline.snapshotCurrentStyles();\x0a                    ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\x0a                }\x0a                var delay = resolveTimingValue(options.delay);\x0a                ctx.delayNextStep(delay);\x0a            }\x0a        }\x0a        if (ast.steps.length) {\x0a            ast.steps.forEach(function (s) { return visitDslNode(_this, s, ctx); });\x0a            // this is here just incase the inner steps only contain or end with a style() call\x0a            ctx.currentTimeline.applyStylesToKeyframe();\x0a            // this means that some animation function within the sequence\x0a            // ended up creating a sub timeline (which means the current\x0a            // timeline cannot overlap with the contents of the sequence)\x0a            if (ctx.subContextCount \x3e subContextCount) {\x0a                ctx.transformIntoNewTimeline();\x0a            }\x0a        }\x0a        context.previousNode = ast;\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitGroup = function (ast, context) {\x0a        var _this = this;\x0a        var innerTimelines = [];\x0a        var furthestTime = context.currentTimeline.currentTime;\x0a        var delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;\x0a        ast.steps.forEach(function (s) {\x0a            var innerContext = context.createSubContext(ast.options);\x0a            if (delay) {\x0a                innerContext.delayNextStep(delay);\x0a            }\x0a            visitDslNode(_this, s, innerContext);\x0a            furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\x0a            innerTimelines.push(innerContext.currentTimeline);\x0a        });\x0a        // this operation is run after the AST loop because otherwise\x0a        // if the parent timeline\x27s collected styles were updated then\x0a        // it would pass in invalid data into the new-to-be forked items\x0a        innerTimelines.forEach(function (timeline) { return context.currentTimeline.mergeTimelineCollectedStyles(timeline); });\x0a        context.transformIntoNewTimeline(furthestTime);\x0a        context.previousNode = ast;\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype._visitTiming = function (ast, context) {\x0a        if (ast.dynamic) {\x0a            var strValue = ast.strValue;\x0a            var timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;\x0a            return resolveTiming(timingValue, context.errors);\x0a        }\x0a        else {\x0a            return { duration: ast.duration, delay: ast.delay, easing: ast.easing };\x0a        }\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitAnimate = function (ast, context) {\x0a        var timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);\x0a        var timeline = context.currentTimeline;\x0a        if (timings.delay) {\x0a            context.incrementTime(timings.delay);\x0a            timeline.snapshotCurrentStyles();\x0a        }\x0a        var style$$1 = ast.style;\x0a        if (style$$1.type == 5 /* Keyframes */) {\x0a            this.visitKeyframes(style$$1, context);\x0a        }\x0a        else {\x0a            context.incrementTime(timings.duration);\x0a            this.visitStyle(style$$1, context);\x0a            timeline.applyStylesToKeyframe();\x0a        }\x0a        context.currentAnimateTimings = null;\x0a        context.previousNode = ast;\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitStyle = function (ast, context) {\x0a        var timeline = context.currentTimeline;\x0a        var timings = context.currentAnimateTimings;\x0a        // this is a special case for when a style() call\x0a        // directly follows  an animate() call (but not inside of an animate() call)\x0a        if (!timings && timeline.getCurrentStyleProperties().length) {\x0a            timeline.forwardFrame();\x0a        }\x0a        var easing = (timings && timings.easing) || ast.easing;\x0a        if (ast.isEmptyStep) {\x0a            timeline.applyEmptyStep(easing);\x0a        }\x0a        else {\x0a            timeline.setStyles(ast.styles, easing, context.errors, context.options);\x0a        }\x0a        context.previousNode = ast;\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitKeyframes = function (ast, context) {\x0a        var currentAnimateTimings = context.currentAnimateTimings;\x0a        var startTime = (context.currentTimeline).duration;\x0a        var duration = currentAnimateTimings.duration;\x0a        var innerContext = context.createSubContext();\x0a        var innerTimeline = innerContext.currentTimeline;\x0a        innerTimeline.easing = currentAnimateTimings.easing;\x0a        ast.styles.forEach(function (step) {\x0a            var offset = step.offset || 0;\x0a            innerTimeline.forwardTime(offset * duration);\x0a            innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);\x0a            innerTimeline.applyStylesToKeyframe();\x0a        });\x0a        // this will ensure that the parent timeline gets all the styles from\x0a        // the child even if the new timeline below is not used\x0a        context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);\x0a        // we do this because the window between this timeline and the sub timeline\x0a        // should ensure that the styles within are exactly the same as they were before\x0a        context.transformIntoNewTimeline(startTime + duration);\x0a        context.previousNode = ast;\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitQuery = function (ast, context) {\x0a        var _this = this;\x0a        // in the event that the first step before this is a style step we need\x0a        // to ensure the styles are applied before the children are animated\x0a        var startTime = context.currentTimeline.currentTime;\x0a        var options = (ast.options || {});\x0a        var delay = options.delay ? resolveTimingValue(options.delay) : 0;\x0a        if (delay && (context.previousNode.type === 6 /* Style */ ||\x0a            (startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length))) {\x0a            context.currentTimeline.snapshotCurrentStyles();\x0a            context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\x0a        }\x0a        var furthestTime = startTime;\x0a        var elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);\x0a        context.currentQueryTotal = elms.length;\x0a        var sameElementTimeline = null;\x0a        elms.forEach(function (element, i) {\x0a            context.currentQueryIndex = i;\x0a            var innerContext = context.createSubContext(ast.options, element);\x0a            if (delay) {\x0a                innerContext.delayNextStep(delay);\x0a            }\x0a            if (element === context.element) {\x0a                sameElementTimeline = innerContext.currentTimeline;\x0a            }\x0a            visitDslNode(_this, ast.animation, innerContext);\x0a            // this is here just incase the inner steps only contain or end\x0a            // with a style() call (which is here to signal that this is a preparatory\x0a            // call to style an element before it is animated again)\x0a            innerContext.currentTimeline.applyStylesToKeyframe();\x0a            var endTime = innerContext.currentTimeline.currentTime;\x0a            furthestTime = Math.max(furthestTime, endTime);\x0a        });\x0a        context.currentQueryIndex = 0;\x0a        context.currentQueryTotal = 0;\x0a        context.transformIntoNewTimeline(furthestTime);\x0a        if (sameElementTimeline) {\x0a            context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);\x0a            context.currentTimeline.snapshotCurrentStyles();\x0a        }\x0a        context.previousNode = ast;\x0a    };\x0a    AnimationTimelineBuilderVisitor.prototype.visitStagger = function (ast, context) {\x0a        var parentContext = context.parentContext;\x0a        var tl = context.currentTimeline;\x0a        var timings = ast.timings;\x0a        var duration = Math.abs(timings.duration);\x0a        var maxTime = duration * (context.currentQueryTotal - 1);\x0a        var delay = duration * context.currentQueryIndex;\x0a        var staggerTransformer = timings.duration \x3c 0 ? \x27reverse\x27 : timings.easing;\x0a        switch (staggerTransformer) {\x0a            case \x27reverse\x27:\x0a                delay = maxTime - delay;\x0a                break;\x0a            case \x27full\x27:\x0a                delay = parentContext.currentStaggerTime;\x0a                break;\x0a        }\x0a        var timeline = context.currentTimeline;\x0a        if (delay) {\x0a            timeline.delayNextStep(delay);\x0a        }\x0a        var startingTime = timeline.currentTime;\x0a        visitDslNode(this, ast.animation, context);\x0a        context.previousNode = ast;\x0a        // time = duration + delay\x0a        // the reason why this computation is so complex is because\x0a        // the inner timeline may either have a delay value or a stretched\x0a        // keyframe depending on if a subtimeline is not used or is used.\x0a        parentContext.currentStaggerTime =\x0a            (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);\x0a    };\x0a    return AnimationTimelineBuilderVisitor;\x0a}());\x0avar DEFAULT_NOOP_PREVIOUS_NODE = {};\x0avar AnimationTimelineContext = /** @class */ (function () {\x0a    function AnimationTimelineContext(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {\x0a        this._driver = _driver;\x0a        this.element = element;\x0a        this.subInstructions = subInstructions;\x0a        this._enterClassName = _enterClassName;\x0a        this._leaveClassName = _leaveClassName;\x0a        this.errors = errors;\x0a        this.timelines = timelines;\x0a        this.parentContext = null;\x0a        this.currentAnimateTimings = null;\x0a        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\x0a        this.subContextCount = 0;\x0a        this.options = {};\x0a        this.currentQueryIndex = 0;\x0a        this.currentQueryTotal = 0;\x0a        this.currentStaggerTime = 0;\x0a        this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);\x0a        timelines.push(this.currentTimeline);\x0a    }\x0a    Object.defineProperty(AnimationTimelineContext.prototype, \x22params\x22, {\x0a        get: function () { return this.options.params; },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    AnimationTimelineContext.prototype.updateOptions = function (options, skipIfExists) {\x0a        var _this = this;\x0a        if (!options)\x0a            return;\x0a        var newOptions = options;\x0a        var optionsToUpdate = this.options;\x0a        // NOTE: this will get patched up when other animation methods support duration overrides\x0a        if (newOptions.duration != null) {\x0a            optionsToUpdate.duration = resolveTimingValue(newOptions.duration);\x0a        }\x0a        if (newOptions.delay != null) {\x0a            optionsToUpdate.delay = resolveTimingValue(newOptions.delay);\x0a        }\x0a        var newParams = newOptions.params;\x0a        if (newParams) {\x0a            var paramsToUpdate_1 = optionsToUpdate.params;\x0a            if (!paramsToUpdate_1) {\x0a                paramsToUpdate_1 = this.options.params = {};\x0a            }\x0a            Object.keys(newParams).forEach(function (name) {\x0a                if (!skipIfExists || !paramsToUpdate_1.hasOwnProperty(name)) {\x0a                    paramsToUpdate_1[name] = interpolateParams(newParams[name], paramsToUpdate_1, _this.errors);\x0a                }\x0a            });\x0a        }\x0a    };\x0a    AnimationTimelineContext.prototype._copyOptions = function () {\x0a        var options = {};\x0a        if (this.options) {\x0a            var oldParams_1 = this.options.params;\x0a            if (oldParams_1) {\x0a                var params_1 = options[\x27params\x27] = {};\x0a                Object.keys(oldParams_1).forEach(function (name) { params_1[name] = oldParams_1[name]; });\x0a            }\x0a        }\x0a        return options;\x0a    };\x0a    AnimationTimelineContext.prototype.createSubContext = function (options, element, newTime) {\x0a        if (options === void 0) { options = null; }\x0a        var target = element || this.element;\x0a        var context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));\x0a        context.previousNode = this.previousNode;\x0a        context.currentAnimateTimings = this.currentAnimateTimings;\x0a        context.options = this._copyOptions();\x0a        context.updateOptions(options);\x0a        context.currentQueryIndex = this.currentQueryIndex;\x0a        context.currentQueryTotal = this.currentQueryTotal;\x0a        context.parentContext = this;\x0a        this.subContextCount++;\x0a        return context;\x0a    };\x0a    AnimationTimelineContext.prototype.transformIntoNewTimeline = function (newTime) {\x0a        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\x0a        this.currentTimeline = this.currentTimeline.fork(this.element, newTime);\x0a        this.timelines.push(this.currentTimeline);\x0a        return this.currentTimeline;\x0a    };\x0a    AnimationTimelineContext.prototype.appendInstructionToTimeline = function (instruction, duration, delay) {\x0a        var updatedTimings = {\x0a            duration: duration != null ? duration : instruction.duration,\x0a            delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,\x0a            easing: \x27\x27\x0a        };\x0a        var builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);\x0a        this.timelines.push(builder);\x0a        return updatedTimings;\x0a    };\x0a    AnimationTimelineContext.prototype.incrementTime = function (time) {\x0a        this.currentTimeline.forwardTime(this.currentTimeline.duration + time);\x0a    };\x0a    AnimationTimelineContext.prototype.delayNextStep = function (delay) {\x0a        // negative delays are not yet supported\x0a        if (delay \x3e 0) {\x0a            this.currentTimeline.delayNextStep(delay);\x0a        }\x0a    };\x0a    AnimationTimelineContext.prototype.invokeQuery = function (selector, originalSelector, limit, includeSelf, optional, errors) {\x0a        var results = [];\x0a        if (includeSelf) {\x0a            results.push(this.element);\x0a        }\x0a        if (selector.length \x3e 0) { // if :self is only used then the selector is empty\x0a            selector = selector.replace(ENTER_TOKEN_REGEX, \x27.\x27 + this._enterClassName);\x0a            selector = selector.replace(LEAVE_TOKEN_REGEX, \x27.\x27 + this._leaveClassName);\x0a            var multi = limit != 1;\x0a            var elements = this._driver.query(this.element, selector, multi);\x0a            if (limit !== 0) {\x0a                elements = limit \x3c 0 ? elements.slice(elements.length + limit, elements.length) :\x0a                    elements.slice(0, limit);\x0a            }\x0a            results.push.apply(results, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__spread\x22])(elements));\x0a        }\x0a        if (!optional && results.length == 0) {\x0a            errors.push(\x22`query(\x5c\x22\x22 + originalSelector + \x22\x5c\x22)` returned zero elements. (Use `query(\x5c\x22\x22 + originalSelector + \x22\x5c\x22, { optional: true })` if you wish to allow this.)\x22);\x0a        }\x0a        return results;\x0a    };\x0a    return AnimationTimelineContext;\x0a}());\x0avar TimelineBuilder = /** @class */ (function () {\x0a    function TimelineBuilder(_driver, element, startTime, _elementTimelineStylesLookup) {\x0a        this._driver = _driver;\x0a        this.element = element;\x0a        this.startTime = startTime;\x0a        this._elementTimelineStylesLookup = _elementTimelineStylesLookup;\x0a        this.duration = 0;\x0a        this._previousKeyframe = {};\x0a        this._currentKeyframe = {};\x0a        this._keyframes = new Map();\x0a        this._styleSummary = {};\x0a        this._pendingStyles = {};\x0a        this._backFill = {};\x0a        this._currentEmptyStepKeyframe = null;\x0a        if (!this._elementTimelineStylesLookup) {\x0a            this._elementTimelineStylesLookup = new Map();\x0a        }\x0a        this._localTimelineStyles = Object.create(this._backFill, {});\x0a        this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);\x0a        if (!this._globalTimelineStyles) {\x0a            this._globalTimelineStyles = this._localTimelineStyles;\x0a            this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);\x0a        }\x0a        this._loadKeyframe();\x0a    }\x0a    TimelineBuilder.prototype.containsAnimation = function () {\x0a        switch (this._keyframes.size) {\x0a            case 0:\x0a                return false;\x0a            case 1:\x0a                return this.getCurrentStyleProperties().length \x3e 0;\x0a            default:\x0a                return true;\x0a        }\x0a    };\x0a    TimelineBuilder.prototype.getCurrentStyleProperties = function () { return Object.keys(this._currentKeyframe); };\x0a    Object.defineProperty(TimelineBuilder.prototype, \x22currentTime\x22, {\x0a        get: function () { return this.startTime + this.duration; },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    TimelineBuilder.prototype.delayNextStep = function (delay) {\x0a        // in the event that a style() step is placed right before a stagger()\x0a        // and that style() step is the very first style() value in the animation\x0a        // then we need to make a copy of the keyframe [0, copy, 1] so that the delay\x0a        // properly applies the style() values to work with the stagger...\x0a        var hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;\x0a        if (this.duration || hasPreStyleStep) {\x0a            this.forwardTime(this.currentTime + delay);\x0a            if (hasPreStyleStep) {\x0a                this.snapshotCurrentStyles();\x0a            }\x0a        }\x0a        else {\x0a            this.startTime += delay;\x0a        }\x0a    };\x0a    TimelineBuilder.prototype.fork = function (element, currentTime) {\x0a        this.applyStylesToKeyframe();\x0a        return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);\x0a    };\x0a    TimelineBuilder.prototype._loadKeyframe = function () {\x0a        if (this._currentKeyframe) {\x0a            this._previousKeyframe = this._currentKeyframe;\x0a        }\x0a        this._currentKeyframe = this._keyframes.get(this.duration);\x0a        if (!this._currentKeyframe) {\x0a            this._currentKeyframe = Object.create(this._backFill, {});\x0a            this._keyframes.set(this.duration, this._currentKeyframe);\x0a        }\x0a    };\x0a    TimelineBuilder.prototype.forwardFrame = function () {\x0a        this.duration += ONE_FRAME_IN_MILLISECONDS;\x0a        this._loadKeyframe();\x0a    };\x0a    TimelineBuilder.prototype.forwardTime = function (time) {\x0a        this.applyStylesToKeyframe();\x0a        this.duration = time;\x0a        this._loadKeyframe();\x0a    };\x0a    TimelineBuilder.prototype._updateStyle = function (prop, value) {\x0a        this._localTimelineStyles[prop] = value;\x0a        this._globalTimelineStyles[prop] = value;\x0a        this._styleSummary[prop] = { time: this.currentTime, value: value };\x0a    };\x0a    TimelineBuilder.prototype.allowOnlyTimelineStyles = function () { return this._currentEmptyStepKeyframe !== this._currentKeyframe; };\x0a    TimelineBuilder.prototype.applyEmptyStep = function (easing) {\x0a        var _this = this;\x0a        if (easing) {\x0a            this._previousKeyframe[\x27easing\x27] = easing;\x0a        }\x0a        // special case for animate(duration):\x0a        // all missing styles are filled with a `*` value then\x0a        // if any destination styles are filled in later on the same\x0a        // keyframe then they will override the overridden styles\x0a        // We use `_globalTimelineStyles` here because there may be\x0a        // styles in previous keyframes that are not present in this timeline\x0a        Object.keys(this._globalTimelineStyles).forEach(function (prop) {\x0a            _this._backFill[prop] = _this._globalTimelineStyles[prop] || _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22AUTO_STYLE\x22];\x0a            _this._currentKeyframe[prop] = _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22AUTO_STYLE\x22];\x0a        });\x0a        this._currentEmptyStepKeyframe = this._currentKeyframe;\x0a    };\x0a    TimelineBuilder.prototype.setStyles = function (input, easing, errors, options) {\x0a        var _this = this;\x0a        if (easing) {\x0a            this._previousKeyframe[\x27easing\x27] = easing;\x0a        }\x0a        var params = (options && options.params) || {};\x0a        var styles = flattenStyles(input, this._globalTimelineStyles);\x0a        Object.keys(styles).forEach(function (prop) {\x0a            var val = interpolateParams(styles[prop], params, errors);\x0a            _this._pendingStyles[prop] = val;\x0a            if (!_this._localTimelineStyles.hasOwnProperty(prop)) {\x0a                _this._backFill[prop] = _this._globalTimelineStyles.hasOwnProperty(prop) ?\x0a                    _this._globalTimelineStyles[prop] :\x0a                    _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22AUTO_STYLE\x22];\x0a            }\x0a            _this._updateStyle(prop, val);\x0a        });\x0a    };\x0a    TimelineBuilder.prototype.applyStylesToKeyframe = function () {\x0a        var _this = this;\x0a        var styles = this._pendingStyles;\x0a        var props = Object.keys(styles);\x0a        if (props.length == 0)\x0a            return;\x0a        this._pendingStyles = {};\x0a        props.forEach(function (prop) {\x0a            var val = styles[prop];\x0a            _this._currentKeyframe[prop] = val;\x0a        });\x0a        Object.keys(this._localTimelineStyles).forEach(function (prop) {\x0a            if (!_this._currentKeyframe.hasOwnProperty(prop)) {\x0a                _this._currentKeyframe[prop] = _this._localTimelineStyles[prop];\x0a            }\x0a        });\x0a    };\x0a    TimelineBuilder.prototype.snapshotCurrentStyles = function () {\x0a        var _this = this;\x0a        Object.keys(this._localTimelineStyles).forEach(function (prop) {\x0a            var val = _this._localTimelineStyles[prop];\x0a            _this._pendingStyles[prop] = val;\x0a            _this._updateStyle(prop, val);\x0a        });\x0a    };\x0a    TimelineBuilder.prototype.getFinalKeyframe = function () { return this._keyframes.get(this.duration); };\x0a    Object.defineProperty(TimelineBuilder.prototype, \x22properties\x22, {\x0a        get: function () {\x0a            var properties = [];\x0a            for (var prop in this._currentKeyframe) {\x0a                properties.push(prop);\x0a            }\x0a            return properties;\x0a        },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    TimelineBuilder.prototype.mergeTimelineCollectedStyles = function (timeline) {\x0a        var _this = this;\x0a        Object.keys(timeline._styleSummary).forEach(function (prop) {\x0a            var details0 = _this._styleSummary[prop];\x0a            var details1 = timeline._styleSummary[prop];\x0a            if (!details0 || details1.time \x3e details0.time) {\x0a                _this._updateStyle(prop, details1.value);\x0a            }\x0a        });\x0a    };\x0a    TimelineBuilder.prototype.buildKeyframes = function () {\x0a        var _this = this;\x0a        this.applyStylesToKeyframe();\x0a        var preStyleProps = new Set();\x0a        var postStyleProps = new Set();\x0a        var isEmpty = this._keyframes.size === 1 && this.duration === 0;\x0a        var finalKeyframes = [];\x0a        this._keyframes.forEach(function (keyframe, time) {\x0a            var finalKeyframe = copyStyles(keyframe, true);\x0a            Object.keys(finalKeyframe).forEach(function (prop) {\x0a                var value = finalKeyframe[prop];\x0a                if (value == _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22\xc9\xb5PRE_STYLE\x22]) {\x0a                    preStyleProps.add(prop);\x0a                }\x0a                else if (value == _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22AUTO_STYLE\x22]) {\x0a                    postStyleProps.add(prop);\x0a                }\x0a            });\x0a            if (!isEmpty) {\x0a                finalKeyframe[\x27offset\x27] = time / _this.duration;\x0a            }\x0a            finalKeyframes.push(finalKeyframe);\x0a        });\x0a        var preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];\x0a        var postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];\x0a        // special case for a 0-second animation (which is designed just to place styles onscreen)\x0a        if (isEmpty) {\x0a            var kf0 = finalKeyframes[0];\x0a            var kf1 = copyObj(kf0);\x0a            kf0[\x27offset\x27] = 0;\x0a            kf1[\x27offset\x27] = 1;\x0a            finalKeyframes = [kf0, kf1];\x0a        }\x0a        return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);\x0a    };\x0a    return TimelineBuilder;\x0a}());\x0avar SubTimelineBuilder = /** @class */ (function (_super) {\x0a    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__extends\x22])(SubTimelineBuilder, _super);\x0a    function SubTimelineBuilder(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe) {\x0a        if (_stretchStartingKeyframe === void 0) { _stretchStartingKeyframe = false; }\x0a        var _this = _super.call(this, driver, element, timings.delay) || this;\x0a        _this.element = element;\x0a        _this.keyframes = keyframes;\x0a        _this.preStyleProps = preStyleProps;\x0a        _this.postStyleProps = postStyleProps;\x0a        _this._stretchStartingKeyframe = _stretchStartingKeyframe;\x0a        _this.timings = { duration: timings.duration, delay: timings.delay, easing: timings.easing };\x0a        return _this;\x0a    }\x0a    SubTimelineBuilder.prototype.containsAnimation = function () { return this.keyframes.length \x3e 1; };\x0a    SubTimelineBuilder.prototype.buildKeyframes = function () {\x0a        var keyframes = this.keyframes;\x0a        var _a = this.timings, delay = _a.delay, duration = _a.duration, easing = _a.easing;\x0a        if (this._stretchStartingKeyframe && delay) {\x0a            var newKeyframes = [];\x0a            var totalTime = duration + delay;\x0a            var startingGap = delay / totalTime;\x0a            // the original starting keyframe now starts once the delay is done\x0a            var newFirstKeyframe = copyStyles(keyframes[0], false);\x0a            newFirstKeyframe[\x27offset\x27] = 0;\x0a            newKeyframes.push(newFirstKeyframe);\x0a            var oldFirstKeyframe = copyStyles(keyframes[0], false);\x0a            oldFirstKeyframe[\x27offset\x27] = roundOffset(startingGap);\x0a            newKeyframes.push(oldFirstKeyframe);\x0a            /*\x0a              When the keyframe is stretched then it means that the delay before the animation\x0a              starts is gone. Instead the first keyframe is placed at the start of the animation\x0a              and it is then copied to where it starts when the original delay is over. This basically\x0a              means nothing animates during that delay, but the styles are still renderered. For this\x0a              to work the original offset values that exist in the original keyframes must be \x22warped\x22\x0a              so that they can take the new keyframe + delay into account.\x0a      \x0a              delay=1000, duration=1000, keyframes = 0 .5 1\x0a      \x0a              turns into\x0a      \x0a              delay=0, duration=2000, keyframes = 0 .33 .66 1\x0a             */\x0a            // offsets between 1 ... n -1 are all warped by the keyframe stretch\x0a            var limit = keyframes.length - 1;\x0a            for (var i = 1; i \x3c= limit; i++) {\x0a                var kf = copyStyles(keyframes[i], false);\x0a                var oldOffset = kf[\x27offset\x27];\x0a                var timeAtKeyframe = delay + oldOffset * duration;\x0a                kf[\x27offset\x27] = roundOffset(timeAtKeyframe / totalTime);\x0a                newKeyframes.push(kf);\x0a            }\x0a            // the new starting keyframe should be added at the start\x0a            duration = totalTime;\x0a            delay = 0;\x0a            easing = \x27\x27;\x0a            keyframes = newKeyframes;\x0a        }\x0a        return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);\x0a    };\x0a    return SubTimelineBuilder;\x0a}(TimelineBuilder));\x0afunction roundOffset(offset, decimalPoints) {\x0a    if (decimalPoints === void 0) { decimalPoints = 3; }\x0a    var mult = Math.pow(10, decimalPoints - 1);\x0a    return Math.round(offset * mult) / mult;\x0a}\x0afunction flattenStyles(input, allStyles) {\x0a    var styles = {};\x0a    var allProperties;\x0a    input.forEach(function (token) {\x0a        if (token === \x27*\x27) {\x0a            allProperties = allProperties || Object.keys(allStyles);\x0a            allProperties.forEach(function (prop) { styles[prop] = _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22AUTO_STYLE\x22]; });\x0a        }\x0a        else {\x0a            copyStyles(token, false, styles);\x0a        }\x0a    });\x0a    return styles;\x0a}\x0a\x0avar Animation = /** @class */ (function () {\x0a    function Animation(_driver, input) {\x0a        this._driver = _driver;\x0a        var errors = [];\x0a        var ast = buildAnimationAst(_driver, input, errors);\x0a        if (errors.length) {\x0a            var errorMessage = \x22animation validation failed:\x5cn\x22 + errors.join(\x22\x5cn\x22);\x0a            throw new Error(errorMessage);\x0a        }\x0a        this._animationAst = ast;\x0a    }\x0a    Animation.prototype.buildTimelines = function (element, startingStyles, destinationStyles, options, subInstructions) {\x0a        var start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) :\x0a            startingStyles;\x0a        var dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) :\x0a            destinationStyles;\x0a        var errors = [];\x0a        subInstructions = subInstructions || new ElementInstructionMap();\x0a        var result = buildAnimationTimelines(this._driver, element, this._animationAst, ENTER_CLASSNAME, LEAVE_CLASSNAME, start, dest, options, subInstructions, errors);\x0a        if (errors.length) {\x0a            var errorMessage = \x22animation building failed:\x5cn\x22 + errors.join(\x22\x5cn\x22);\x0a            throw new Error(errorMessage);\x0a        }\x0a        return result;\x0a    };\x0a    return Animation;\x0a}());\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/**\x0a * @publicApi\x0a */\x0avar AnimationStyleNormalizer = /** @class */ (function () {\x0a    function AnimationStyleNormalizer() {\x0a    }\x0a    return AnimationStyleNormalizer;\x0a}());\x0a/**\x0a * @publicApi\x0a */\x0avar NoopAnimationStyleNormalizer = /** @class */ (function () {\x0a    function NoopAnimationStyleNormalizer() {\x0a    }\x0a    NoopAnimationStyleNormalizer.prototype.normalizePropertyName = function (propertyName, errors) { return propertyName; };\x0a    NoopAnimationStyleNormalizer.prototype.normalizeStyleValue = function (userProvidedProperty, normalizedProperty, value, errors) {\x0a        return value;\x0a    };\x0a    return NoopAnimationStyleNormalizer;\x0a}());\x0a\x0avar WebAnimationsStyleNormalizer = /** @class */ (function (_super) {\x0a    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__extends\x22])(WebAnimationsStyleNormalizer, _super);\x0a    function WebAnimationsStyleNormalizer() {\x0a        return _super !== null && _super.apply(this, arguments) || this;\x0a    }\x0a    WebAnimationsStyleNormalizer.prototype.normalizePropertyName = function (propertyName, errors) {\x0a        return dashCaseToCamelCase(propertyName);\x0a    };\x0a    WebAnimationsStyleNormalizer.prototype.normalizeStyleValue = function (userProvidedProperty, normalizedProperty, value, errors) {\x0a        var unit = \x27\x27;\x0a        var strVal = value.toString().trim();\x0a        if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== \x270\x27) {\x0a            if (typeof value === \x27number\x27) {\x0a                unit = \x27px\x27;\x0a            }\x0a            else {\x0a                var valAndSuffixMatch = value.match(/^[+-]?[\x5cd\x5c.]+([a-z]*)$/);\x0a                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\x0a                    errors.push(\x22Please provide a CSS unit value for \x22 + userProvidedProperty + \x22:\x22 + value);\x0a                }\x0a            }\x0a        }\x0a        return strVal + unit;\x0a    };\x0a    return WebAnimationsStyleNormalizer;\x0a}(AnimationStyleNormalizer));\x0avar DIMENSIONAL_PROP_MAP = makeBooleanMap(\x27width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective\x27\x0a    .split(\x27,\x27));\x0afunction makeBooleanMap(keys) {\x0a    var map = {};\x0a    keys.forEach(function (key) { return map[key] = true; });\x0a    return map;\x0a}\x0a\x0afunction createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {\x0a    return {\x0a        type: 0 /* TransitionAnimation */,\x0a        element: element,\x0a        triggerName: triggerName,\x0a        isRemovalTransition: isRemovalTransition,\x0a        fromState: fromState,\x0a        fromStyles: fromStyles,\x0a        toState: toState,\x0a        toStyles: toStyles,\x0a        timelines: timelines,\x0a        queriedElements: queriedElements,\x0a        preStyleProps: preStyleProps,\x0a        postStyleProps: postStyleProps,\x0a        totalTime: totalTime,\x0a        errors: errors\x0a    };\x0a}\x0a\x0avar EMPTY_OBJECT = {};\x0avar AnimationTransitionFactory = /** @class */ (function () {\x0a    function AnimationTransitionFactory(_triggerName, ast, _stateStyles) {\x0a        this._triggerName = _triggerName;\x0a        this.ast = ast;\x0a        this._stateStyles = _stateStyles;\x0a    }\x0a    AnimationTransitionFactory.prototype.match = function (currentState, nextState, element, params) {\x0a        return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);\x0a    };\x0a    AnimationTransitionFactory.prototype.buildStyles = function (stateName, params, errors) {\x0a        var backupStateStyler = this._stateStyles[\x27*\x27];\x0a        var stateStyler = this._stateStyles[stateName];\x0a        var backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};\x0a        return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;\x0a    };\x0a    AnimationTransitionFactory.prototype.build = function (driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {\x0a        var errors = [];\x0a        var transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;\x0a        var currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;\x0a        var currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);\x0a        var nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;\x0a        var nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);\x0a        var queriedElements = new Set();\x0a        var preStyleMap = new Map();\x0a        var postStyleMap = new Map();\x0a        var isRemoval = nextState === \x27void\x27;\x0a        var animationOptions = { params: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__assign\x22])({}, transitionAnimationParams, nextAnimationParams) };\x0a        var timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);\x0a        var totalTime = 0;\x0a        timelines.forEach(function (tl) { totalTime = Math.max(tl.duration + tl.delay, totalTime); });\x0a        if (errors.length) {\x0a            return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);\x0a        }\x0a        timelines.forEach(function (tl) {\x0a            var elm = tl.element;\x0a            var preProps = getOrSetAsInMap(preStyleMap, elm, {});\x0a            tl.preStyleProps.forEach(function (prop) { return preProps[prop] = true; });\x0a            var postProps = getOrSetAsInMap(postStyleMap, elm, {});\x0a            tl.postStyleProps.forEach(function (prop) { return postProps[prop] = true; });\x0a            if (elm !== element) {\x0a                queriedElements.add(elm);\x0a            }\x0a        });\x0a        var queriedElementsList = iteratorToArray(queriedElements.values());\x0a        return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap, totalTime);\x0a    };\x0a    return AnimationTransitionFactory;\x0a}());\x0afunction oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {\x0a    return matchFns.some(function (fn) { return fn(currentState, nextState, element, params); });\x0a}\x0avar AnimationStateStyles = /** @class */ (function () {\x0a    function AnimationStateStyles(styles, defaultParams) {\x0a        this.styles = styles;\x0a        this.defaultParams = defaultParams;\x0a    }\x0a    AnimationStateStyles.prototype.buildStyles = function (params, errors) {\x0a        var finalStyles = {};\x0a        var combinedParams = copyObj(this.defaultParams);\x0a        Object.keys(params).forEach(function (key) {\x0a            var value = params[key];\x0a            if (value != null) {\x0a                combinedParams[key] = value;\x0a            }\x0a        });\x0a        this.styles.styles.forEach(function (value) {\x0a            if (typeof value !== \x27string\x27) {\x0a                var styleObj_1 = value;\x0a                Object.keys(styleObj_1).forEach(function (prop) {\x0a                    var val = styleObj_1[prop];\x0a                    if (val.length \x3e 1) {\x0a                        val = interpolateParams(val, combinedParams, errors);\x0a                    }\x0a                    finalStyles[prop] = val;\x0a                });\x0a            }\x0a        });\x0a        return finalStyles;\x0a    };\x0a    return AnimationStateStyles;\x0a}());\x0a\x0a/**\x0a * @publicApi\x0a */\x0afunction buildTrigger(name, ast) {\x0a    return new AnimationTrigger(name, ast);\x0a}\x0a/**\x0a* @publicApi\x0a*/\x0avar AnimationTrigger = /** @class */ (function () {\x0a    function AnimationTrigger(name, ast) {\x0a        var _this = this;\x0a        this.name = name;\x0a        this.ast = ast;\x0a        this.transitionFactories = [];\x0a        this.states = {};\x0a        ast.states.forEach(function (ast) {\x0a            var defaultParams = (ast.options && ast.options.params) || {};\x0a            _this.states[ast.name] = new AnimationStateStyles(ast.style, defaultParams);\x0a        });\x0a        balanceProperties(this.states, \x27true\x27, \x271\x27);\x0a        balanceProperties(this.states, \x27false\x27, \x270\x27);\x0a        ast.transitions.forEach(function (ast) {\x0a            _this.transitionFactories.push(new AnimationTransitionFactory(name, ast, _this.states));\x0a        });\x0a        this.fallbackTransition = createFallbackTransition(name, this.states);\x0a    }\x0a    Object.defineProperty(AnimationTrigger.prototype, \x22containsQueries\x22, {\x0a        get: function () { return this.ast.queryCount \x3e 0; },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    AnimationTrigger.prototype.matchTransition = function (currentState, nextState, element, params) {\x0a        var entry = this.transitionFactories.find(function (f) { return f.match(currentState, nextState, element, params); });\x0a        return entry || null;\x0a    };\x0a    AnimationTrigger.prototype.matchStyles = function (currentState, params, errors) {\x0a        return this.fallbackTransition.buildStyles(currentState, params, errors);\x0a    };\x0a    return AnimationTrigger;\x0a}());\x0afunction createFallbackTransition(triggerName, states) {\x0a    var matchers = [function (fromState, toState) { return true; }];\x0a    var animation = { type: 2 /* Sequence */, steps: [], options: null };\x0a    var transition = {\x0a        type: 1 /* Transition */,\x0a        animation: animation,\x0a        matchers: matchers,\x0a        options: null,\x0a        queryCount: 0,\x0a        depCount: 0\x0a    };\x0a    return new AnimationTransitionFactory(triggerName, transition, states);\x0a}\x0afunction balanceProperties(obj, key1, key2) {\x0a    if (obj.hasOwnProperty(key1)) {\x0a        if (!obj.hasOwnProperty(key2)) {\x0a            obj[key2] = obj[key1];\x0a        }\x0a    }\x0a    else if (obj.hasOwnProperty(key2)) {\x0a        obj[key1] = obj[key2];\x0a    }\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0avar EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();\x0avar TimelineAnimationEngine = /** @class */ (function () {\x0a    function TimelineAnimationEngine(bodyNode, _driver, _normalizer) {\x0a        this.bodyNode = bodyNode;\x0a        this._driver = _driver;\x0a        this._normalizer = _normalizer;\x0a        this._animations = {};\x0a        this._playersById = {};\x0a        this.players = [];\x0a    }\x0a    TimelineAnimationEngine.prototype.register = function (id, metadata) {\x0a        var errors = [];\x0a        var ast = buildAnimationAst(this._driver, metadata, errors);\x0a        if (errors.length) {\x0a            throw new Error(\x22Unable to build the animation due to the following errors: \x22 + errors.join(\x22\x5cn\x22));\x0a        }\x0a        else {\x0a            this._animations[id] = ast;\x0a        }\x0a    };\x0a    TimelineAnimationEngine.prototype._buildPlayer = function (i, preStyles, postStyles) {\x0a        var element = i.element;\x0a        var keyframes = normalizeKeyframes(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);\x0a        return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], true);\x0a    };\x0a    TimelineAnimationEngine.prototype.create = function (id, element, options) {\x0a        var _this = this;\x0a        if (options === void 0) { options = {}; }\x0a        var errors = [];\x0a        var ast = this._animations[id];\x0a        var instructions;\x0a        var autoStylesMap = new Map();\x0a        if (ast) {\x0a            instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors);\x0a            instructions.forEach(function (inst) {\x0a                var styles = getOrSetAsInMap(autoStylesMap, inst.element, {});\x0a                inst.postStyleProps.forEach(function (prop) { return styles[prop] = null; });\x0a            });\x0a        }\x0a        else {\x0a            errors.push(\x27The requested animation doesn\x5c\x27t exist or has already been destroyed\x27);\x0a            instructions = [];\x0a        }\x0a        if (errors.length) {\x0a            throw new Error(\x22Unable to create the animation due to the following errors: \x22 + errors.join(\x22\x5cn\x22));\x0a        }\x0a        autoStylesMap.forEach(function (styles, element) {\x0a            Object.keys(styles).forEach(function (prop) { styles[prop] = _this._driver.computeStyle(element, prop, _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22AUTO_STYLE\x22]); });\x0a        });\x0a        var players = instructions.map(function (i) {\x0a            var styles = autoStylesMap.get(i.element);\x0a            return _this._buildPlayer(i, {}, styles);\x0a        });\x0a        var player = optimizeGroupPlayer(players);\x0a        this._playersById[id] = player;\x0a        player.onDestroy(function () { return _this.destroy(id); });\x0a        this.players.push(player);\x0a        return player;\x0a    };\x0a    TimelineAnimationEngine.prototype.destroy = function (id) {\x0a        var player = this._getPlayer(id);\x0a        player.destroy();\x0a        delete this._playersById[id];\x0a        var index = this.players.indexOf(player);\x0a        if (index \x3e= 0) {\x0a            this.players.splice(index, 1);\x0a        }\x0a    };\x0a    TimelineAnimationEngine.prototype._getPlayer = function (id) {\x0a        var player = this._playersById[id];\x0a        if (!player) {\x0a            throw new Error(\x22Unable to find the timeline player referenced by \x22 + id);\x0a        }\x0a        return player;\x0a    };\x0a    TimelineAnimationEngine.prototype.listen = function (id, element, eventName, callback) {\x0a        // triggerName, fromState, toState are all ignored for timeline animations\x0a        var baseEvent = makeAnimationEvent(element, \x27\x27, \x27\x27, \x27\x27);\x0a        listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);\x0a        return function () { };\x0a    };\x0a    TimelineAnimationEngine.prototype.command = function (id, element, command, args) {\x0a        if (command == \x27register\x27) {\x0a            this.register(id, args[0]);\x0a            return;\x0a        }\x0a        if (command == \x27create\x27) {\x0a            var options = (args[0] || {});\x0a            this.create(id, element, options);\x0a            return;\x0a        }\x0a        var player = this._getPlayer(id);\x0a        switch (command) {\x0a            case \x27play\x27:\x0a                player.play();\x0a                break;\x0a            case \x27pause\x27:\x0a                player.pause();\x0a                break;\x0a            case \x27reset\x27:\x0a                player.reset();\x0a                break;\x0a            case \x27restart\x27:\x0a                player.restart();\x0a                break;\x0a            case \x27finish\x27:\x0a                player.finish();\x0a                break;\x0a            case \x27init\x27:\x0a                player.init();\x0a                break;\x0a            case \x27setPosition\x27:\x0a                player.setPosition(parseFloat(args[0]));\x0a                break;\x0a            case \x27destroy\x27:\x0a                this.destroy(id);\x0a                break;\x0a        }\x0a    };\x0a    return TimelineAnimationEngine;\x0a}());\x0a\x0avar QUEUED_CLASSNAME = \x27ng-animate-queued\x27;\x0avar QUEUED_SELECTOR = \x27.ng-animate-queued\x27;\x0avar DISABLED_CLASSNAME = \x27ng-animate-disabled\x27;\x0avar DISABLED_SELECTOR = \x27.ng-animate-disabled\x27;\x0avar STAR_CLASSNAME = \x27ng-star-inserted\x27;\x0avar STAR_SELECTOR = \x27.ng-star-inserted\x27;\x0avar EMPTY_PLAYER_ARRAY = [];\x0avar NULL_REMOVAL_STATE = {\x0a    namespaceId: \x27\x27,\x0a    setForRemoval: false,\x0a    setForMove: false,\x0a    hasAnimation: false,\x0a    removedBeforeQueried: false\x0a};\x0avar NULL_REMOVED_QUERIED_STATE = {\x0a    namespaceId: \x27\x27,\x0a    setForMove: false,\x0a    setForRemoval: false,\x0a    hasAnimation: false,\x0a    removedBeforeQueried: true\x0a};\x0avar REMOVAL_FLAG = \x27__ng_removed\x27;\x0avar StateValue = /** @class */ (function () {\x0a    function StateValue(input, namespaceId) {\x0a        if (namespaceId === void 0) { namespaceId = \x27\x27; }\x0a        this.namespaceId = namespaceId;\x0a        var isObj = input && input.hasOwnProperty(\x27value\x27);\x0a        var value = isObj ? input[\x27value\x27] : input;\x0a        this.value = normalizeTriggerValue(value);\x0a        if (isObj) {\x0a            var options = copyObj(input);\x0a            delete options[\x27value\x27];\x0a            this.options = options;\x0a        }\x0a        else {\x0a            this.options = {};\x0a        }\x0a        if (!this.options.params) {\x0a            this.options.params = {};\x0a        }\x0a    }\x0a    Object.defineProperty(StateValue.prototype, \x22params\x22, {\x0a        get: function () { return this.options.params; },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    StateValue.prototype.absorbOptions = function (options) {\x0a        var newParams = options.params;\x0a        if (newParams) {\x0a            var oldParams_1 = this.options.params;\x0a            Object.keys(newParams).forEach(function (prop) {\x0a                if (oldParams_1[prop] == null) {\x0a                    oldParams_1[prop] = newParams[prop];\x0a                }\x0a            });\x0a        }\x0a    };\x0a    return StateValue;\x0a}());\x0avar VOID_VALUE = \x27void\x27;\x0avar DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);\x0avar AnimationTransitionNamespace = /** @class */ (function () {\x0a    function AnimationTransitionNamespace(id, hostElement, _engine) {\x0a        this.id = id;\x0a        this.hostElement = hostElement;\x0a        this._engine = _engine;\x0a        this.players = [];\x0a        this._triggers = {};\x0a        this._queue = [];\x0a        this._elementListeners = new Map();\x0a        this._hostClassName = \x27ng-tns-\x27 + id;\x0a        addClass(hostElement, this._hostClassName);\x0a    }\x0a    AnimationTransitionNamespace.prototype.listen = function (element, name, phase, callback) {\x0a        var _this = this;\x0a        if (!this._triggers.hasOwnProperty(name)) {\x0a            throw new Error(\x22Unable to listen on the animation trigger event \x5c\x22\x22 + phase + \x22\x5c\x22 because the animation trigger \x5c\x22\x22 + name + \x22\x5c\x22 doesn\x27t exist!\x22);\x0a        }\x0a        if (phase == null || phase.length == 0) {\x0a            throw new Error(\x22Unable to listen on the animation trigger \x5c\x22\x22 + name + \x22\x5c\x22 because the provided event is undefined!\x22);\x0a        }\x0a        if (!isTriggerEventValid(phase)) {\x0a            throw new Error(\x22The provided animation trigger event \x5c\x22\x22 + phase + \x22\x5c\x22 for the animation trigger \x5c\x22\x22 + name + \x22\x5c\x22 is not supported!\x22);\x0a        }\x0a        var listeners = getOrSetAsInMap(this._elementListeners, element, []);\x0a        var data = { name: name, phase: phase, callback: callback };\x0a        listeners.push(data);\x0a        var triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});\x0a        if (!triggersWithStates.hasOwnProperty(name)) {\x0a            addClass(element, NG_TRIGGER_CLASSNAME);\x0a            addClass(element, NG_TRIGGER_CLASSNAME + \x27-\x27 + name);\x0a            triggersWithStates[name] = DEFAULT_STATE_VALUE;\x0a        }\x0a        return function () {\x0a            // the event listener is removed AFTER the flush has occurred such\x0a            // that leave animations callbacks can fire (otherwise if the node\x0a            // is removed in between then the listeners would be deregistered)\x0a            _this._engine.afterFlush(function () {\x0a                var index = listeners.indexOf(data);\x0a                if (index \x3e= 0) {\x0a                    listeners.splice(index, 1);\x0a                }\x0a                if (!_this._triggers[name]) {\x0a                    delete triggersWithStates[name];\x0a                }\x0a            });\x0a        };\x0a    };\x0a    AnimationTransitionNamespace.prototype.register = function (name, ast) {\x0a        if (this._triggers[name]) {\x0a            // throw\x0a            return false;\x0a        }\x0a        else {\x0a            this._triggers[name] = ast;\x0a            return true;\x0a        }\x0a    };\x0a    AnimationTransitionNamespace.prototype._getTrigger = function (name) {\x0a        var trigger = this._triggers[name];\x0a        if (!trigger) {\x0a            throw new Error(\x22The provided animation trigger \x5c\x22\x22 + name + \x22\x5c\x22 has not been registered!\x22);\x0a        }\x0a        return trigger;\x0a    };\x0a    AnimationTransitionNamespace.prototype.trigger = function (element, triggerName, value, defaultToFallback) {\x0a        var _this = this;\x0a        if (defaultToFallback === void 0) { defaultToFallback = true; }\x0a        var trigger = this._getTrigger(triggerName);\x0a        var player = new TransitionAnimationPlayer(this.id, triggerName, element);\x0a        var triggersWithStates = this._engine.statesByElement.get(element);\x0a        if (!triggersWithStates) {\x0a            addClass(element, NG_TRIGGER_CLASSNAME);\x0a            addClass(element, NG_TRIGGER_CLASSNAME + \x27-\x27 + triggerName);\x0a            this._engine.statesByElement.set(element, triggersWithStates = {});\x0a        }\x0a        var fromState = triggersWithStates[triggerName];\x0a        var toState = new StateValue(value, this.id);\x0a        var isObj = value && value.hasOwnProperty(\x27value\x27);\x0a        if (!isObj && fromState) {\x0a            toState.absorbOptions(fromState.options);\x0a        }\x0a        triggersWithStates[triggerName] = toState;\x0a        if (!fromState) {\x0a            fromState = DEFAULT_STATE_VALUE;\x0a        }\x0a        var isRemoval = toState.value === VOID_VALUE;\x0a        // normally this isn\x27t reached by here, however, if an object expression\x0a        // is passed in then it may be a new object each time. Comparing the value\x0a        // is important since that will stay the same despite there being a new object.\x0a        // The removal arc here is special cased because the same element is triggered\x0a        // twice in the event that it contains animations on the outer/inner portions\x0a        // of the host container\x0a        if (!isRemoval && fromState.value === toState.value) {\x0a            // this means that despite the value not changing, some inner params\x0a            // have changed which means that the animation final styles need to be applied\x0a            if (!objEquals(fromState.params, toState.params)) {\x0a                var errors = [];\x0a                var fromStyles_1 = trigger.matchStyles(fromState.value, fromState.params, errors);\x0a                var toStyles_1 = trigger.matchStyles(toState.value, toState.params, errors);\x0a                if (errors.length) {\x0a                    this._engine.reportError(errors);\x0a                }\x0a                else {\x0a                    this._engine.afterFlush(function () {\x0a                        eraseStyles(element, fromStyles_1);\x0a                        setStyles(element, toStyles_1);\x0a                    });\x0a                }\x0a            }\x0a            return;\x0a        }\x0a        var playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);\x0a        playersOnElement.forEach(function (player) {\x0a            // only remove the player if it is queued on the EXACT same trigger/namespace\x0a            // we only also deal with queued players here because if the animation has\x0a            // started then we want to keep the player alive until the flush happens\x0a            // (which is where the previousPlayers are passed into the new palyer)\x0a            if (player.namespaceId == _this.id && player.triggerName == triggerName && player.queued) {\x0a                player.destroy();\x0a            }\x0a        });\x0a        var transition = trigger.matchTransition(fromState.value, toState.value, element, toState.params);\x0a        var isFallbackTransition = false;\x0a        if (!transition) {\x0a            if (!defaultToFallback)\x0a                return;\x0a            transition = trigger.fallbackTransition;\x0a            isFallbackTransition = true;\x0a        }\x0a        this._engine.totalQueuedPlayers++;\x0a        this._queue.push({ element: element, triggerName: triggerName, transition: transition, fromState: fromState, toState: toState, player: player, isFallbackTransition: isFallbackTransition });\x0a        if (!isFallbackTransition) {\x0a            addClass(element, QUEUED_CLASSNAME);\x0a            player.onStart(function () { removeClass(element, QUEUED_CLASSNAME); });\x0a        }\x0a        player.onDone(function () {\x0a            var index = _this.players.indexOf(player);\x0a            if (index \x3e= 0) {\x0a                _this.players.splice(index, 1);\x0a            }\x0a            var players = _this._engine.playersByElement.get(element);\x0a            if (players) {\x0a                var index_1 = players.indexOf(player);\x0a                if (index_1 \x3e= 0) {\x0a                    players.splice(index_1, 1);\x0a                }\x0a            }\x0a        });\x0a        this.players.push(player);\x0a        playersOnElement.push(player);\x0a        return player;\x0a    };\x0a    AnimationTransitionNamespace.prototype.deregister = function (name) {\x0a        var _this = this;\x0a        delete this._triggers[name];\x0a        this._engine.statesByElement.forEach(function (stateMap, element) { delete stateMap[name]; });\x0a        this._elementListeners.forEach(function (listeners, element) {\x0a            _this._elementListeners.set(element, listeners.filter(function (entry) { return entry.name != name; }));\x0a        });\x0a    };\x0a    AnimationTransitionNamespace.prototype.clearElementCache = function (element) {\x0a        this._engine.statesByElement.delete(element);\x0a        this._elementListeners.delete(element);\x0a        var elementPlayers = this._engine.playersByElement.get(element);\x0a        if (elementPlayers) {\x0a            elementPlayers.forEach(function (player) { return player.destroy(); });\x0a            this._engine.playersByElement.delete(element);\x0a        }\x0a    };\x0a    AnimationTransitionNamespace.prototype._signalRemovalForInnerTriggers = function (rootElement, context, animate) {\x0a        var _this = this;\x0a        if (animate === void 0) { animate = false; }\x0a        // emulate a leave animation for all inner nodes within this node.\x0a        // If there are no animations found for any of the nodes then clear the cache\x0a        // for the element.\x0a        this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true).forEach(function (elm) {\x0a            // this means that an inner remove() operation has already kicked off\x0a            // the animation on this element...\x0a            if (elm[REMOVAL_FLAG])\x0a                return;\x0a            var namespaces = _this._engine.fetchNamespacesByElement(elm);\x0a            if (namespaces.size) {\x0a                namespaces.forEach(function (ns) { return ns.triggerLeaveAnimation(elm, context, false, true); });\x0a            }\x0a            else {\x0a                _this.clearElementCache(elm);\x0a            }\x0a        });\x0a    };\x0a    AnimationTransitionNamespace.prototype.triggerLeaveAnimation = function (element, context, destroyAfterComplete, defaultToFallback) {\x0a        var _this = this;\x0a        var triggerStates = this._engine.statesByElement.get(element);\x0a        if (triggerStates) {\x0a            var players_1 = [];\x0a            Object.keys(triggerStates).forEach(function (triggerName) {\x0a                // this check is here in the event that an element is removed\x0a                // twice (both on the host level and the component level)\x0a                if (_this._triggers[triggerName]) {\x0a                    var player = _this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);\x0a                    if (player) {\x0a                        players_1.push(player);\x0a                    }\x0a                }\x0a            });\x0a            if (players_1.length) {\x0a                this._engine.markElementAsRemoved(this.id, element, true, context);\x0a                if (destroyAfterComplete) {\x0a                    optimizeGroupPlayer(players_1).onDone(function () { return _this._engine.processLeaveNode(element); });\x0a                }\x0a                return true;\x0a            }\x0a        }\x0a        return false;\x0a    };\x0a    AnimationTransitionNamespace.prototype.prepareLeaveAnimationListeners = function (element) {\x0a        var _this = this;\x0a        var listeners = this._elementListeners.get(element);\x0a        if (listeners) {\x0a            var visitedTriggers_1 = new Set();\x0a            listeners.forEach(function (listener) {\x0a                var triggerName = listener.name;\x0a                if (visitedTriggers_1.has(triggerName))\x0a                    return;\x0a                visitedTriggers_1.add(triggerName);\x0a                var trigger = _this._triggers[triggerName];\x0a                var transition = trigger.fallbackTransition;\x0a                var elementStates = _this._engine.statesByElement.get(element);\x0a                var fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;\x0a                var toState = new StateValue(VOID_VALUE);\x0a                var player = new TransitionAnimationPlayer(_this.id, triggerName, element);\x0a                _this._engine.totalQueuedPlayers++;\x0a                _this._queue.push({\x0a                    element: element,\x0a                    triggerName: triggerName,\x0a                    transition: transition,\x0a                    fromState: fromState,\x0a                    toState: toState,\x0a                    player: player,\x0a                    isFallbackTransition: true\x0a                });\x0a            });\x0a        }\x0a    };\x0a    AnimationTransitionNamespace.prototype.removeNode = function (element, context) {\x0a        var _this = this;\x0a        var engine = this._engine;\x0a        if (element.childElementCount) {\x0a            this._signalRemovalForInnerTriggers(element, context, true);\x0a        }\x0a        // this means that a * =\x3e VOID animation was detected and kicked off\x0a        if (this.triggerLeaveAnimation(element, context, true))\x0a            return;\x0a        // find the player that is animating and make sure that the\x0a        // removal is delayed until that player has completed\x0a        var containsPotentialParentTransition = false;\x0a        if (engine.totalAnimations) {\x0a            var currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];\x0a            // when this `if statement` does not continue forward it means that\x0a            // a previous animation query has selected the current element and\x0a            // is animating it. In this situation want to continue forwards and\x0a            // allow the element to be queued up for animation later.\x0a            if (currentPlayers && currentPlayers.length) {\x0a                containsPotentialParentTransition = true;\x0a            }\x0a            else {\x0a                var parent_1 = element;\x0a                while (parent_1 = parent_1.parentNode) {\x0a                    var triggers = engine.statesByElement.get(parent_1);\x0a                    if (triggers) {\x0a                        containsPotentialParentTransition = true;\x0a                        break;\x0a                    }\x0a                }\x0a            }\x0a        }\x0a        // at this stage we know that the element will either get removed\x0a        // during flush or will be picked up by a parent query. Either way\x0a        // we need to fire the listeners for this element when it DOES get\x0a        // removed (once the query parent animation is done or after flush)\x0a        this.prepareLeaveAnimationListeners(element);\x0a        // whether or not a parent has an animation we need to delay the deferral of the leave\x0a        // operation until we have more information (which we do after flush() has been called)\x0a        if (containsPotentialParentTransition) {\x0a            engine.markElementAsRemoved(this.id, element, false, context);\x0a        }\x0a        else {\x0a            // we do this after the flush has occurred such\x0a            // that the callbacks can be fired\x0a            engine.afterFlush(function () { return _this.clearElementCache(element); });\x0a            engine.destroyInnerAnimations(element);\x0a            engine._onRemovalComplete(element, context);\x0a        }\x0a    };\x0a    AnimationTransitionNamespace.prototype.insertNode = function (element, parent) { addClass(element, this._hostClassName); };\x0a    AnimationTransitionNamespace.prototype.drainQueuedTransitions = function (microtaskId) {\x0a        var _this = this;\x0a        var instructions = [];\x0a        this._queue.forEach(function (entry) {\x0a            var player = entry.player;\x0a            if (player.destroyed)\x0a                return;\x0a            var element = entry.element;\x0a            var listeners = _this._elementListeners.get(element);\x0a            if (listeners) {\x0a                listeners.forEach(function (listener) {\x0a                    if (listener.name == entry.triggerName) {\x0a                        var baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);\x0a                        baseEvent[\x27_data\x27] = microtaskId;\x0a                        listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);\x0a                    }\x0a                });\x0a            }\x0a            if (player.markedForDestroy) {\x0a                _this._engine.afterFlush(function () {\x0a                    // now we can destroy the element properly since the event listeners have\x0a                    // been bound to the player\x0a                    player.destroy();\x0a                });\x0a            }\x0a            else {\x0a                instructions.push(entry);\x0a            }\x0a        });\x0a        this._queue = [];\x0a        return instructions.sort(function (a, b) {\x0a            // if depCount == 0 them move to front\x0a            // otherwise if a contains b then move back\x0a            var d0 = a.transition.ast.depCount;\x0a            var d1 = b.transition.ast.depCount;\x0a            if (d0 == 0 || d1 == 0) {\x0a                return d0 - d1;\x0a            }\x0a            return _this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;\x0a        });\x0a    };\x0a    AnimationTransitionNamespace.prototype.destroy = function (context) {\x0a        this.players.forEach(function (p) { return p.destroy(); });\x0a        this._signalRemovalForInnerTriggers(this.hostElement, context);\x0a    };\x0a    AnimationTransitionNamespace.prototype.elementContainsData = function (element) {\x0a        var containsData = false;\x0a        if (this._elementListeners.has(element))\x0a            containsData = true;\x0a        containsData =\x0a            (this._queue.find(function (entry) { return entry.element === element; }) ? true : false) || containsData;\x0a        return containsData;\x0a    };\x0a    return AnimationTransitionNamespace;\x0a}());\x0avar TransitionAnimationEngine = /** @class */ (function () {\x0a    function TransitionAnimationEngine(bodyNode, driver, _normalizer) {\x0a        this.bodyNode = bodyNode;\x0a        this.driver = driver;\x0a        this._normalizer = _normalizer;\x0a        this.players = [];\x0a        this.newHostElements = new Map();\x0a        this.playersByElement = new Map();\x0a        this.playersByQueriedElement = new Map();\x0a        this.statesByElement = new Map();\x0a        this.disabledNodes = new Set();\x0a        this.totalAnimations = 0;\x0a        this.totalQueuedPlayers = 0;\x0a        this._namespaceLookup = {};\x0a        this._namespaceList = [];\x0a        this._flushFns = [];\x0a        this._whenQuietFns = [];\x0a        this.namespacesByHostElement = new Map();\x0a        this.collectedEnterElements = [];\x0a        this.collectedLeaveElements = [];\x0a        // this method is designed to be overridden by the code that uses this engine\x0a        this.onRemovalComplete = function (element, context) { };\x0a    }\x0a    /** @internal */\x0a    TransitionAnimationEngine.prototype._onRemovalComplete = function (element, context) { this.onRemovalComplete(element, context); };\x0a    Object.defineProperty(TransitionAnimationEngine.prototype, \x22queuedPlayers\x22, {\x0a        get: function () {\x0a            var players = [];\x0a            this._namespaceList.forEach(function (ns) {\x0a                ns.players.forEach(function (player) {\x0a                    if (player.queued) {\x0a                        players.push(player);\x0a                    }\x0a                });\x0a            });\x0a            return players;\x0a        },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    TransitionAnimationEngine.prototype.createNamespace = function (namespaceId, hostElement) {\x0a        var ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\x0a        if (hostElement.parentNode) {\x0a            this._balanceNamespaceList(ns, hostElement);\x0a        }\x0a        else {\x0a            // defer this later until flush during when the host element has\x0a            // been inserted so that we know exactly where to place it in\x0a            // the namespace list\x0a            this.newHostElements.set(hostElement, ns);\x0a            // given that this host element is apart of the animation code, it\x0a            // may or may not be inserted by a parent node that is an of an\x0a            // animation renderer type. If this happens then we can still have\x0a            // access to this item when we query for :enter nodes. If the parent\x0a            // is a renderer then the set data-structure will normalize the entry\x0a            this.collectEnterElement(hostElement);\x0a        }\x0a        return this._namespaceLookup[namespaceId] = ns;\x0a    };\x0a    TransitionAnimationEngine.prototype._balanceNamespaceList = function (ns, hostElement) {\x0a        var limit = this._namespaceList.length - 1;\x0a        if (limit \x3e= 0) {\x0a            var found = false;\x0a            for (var i = limit; i \x3e= 0; i--) {\x0a                var nextNamespace = this._namespaceList[i];\x0a                if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {\x0a                    this._namespaceList.splice(i + 1, 0, ns);\x0a                    found = true;\x0a                    break;\x0a                }\x0a            }\x0a            if (!found) {\x0a                this._namespaceList.splice(0, 0, ns);\x0a            }\x0a        }\x0a        else {\x0a            this._namespaceList.push(ns);\x0a        }\x0a        this.namespacesByHostElement.set(hostElement, ns);\x0a        return ns;\x0a    };\x0a    TransitionAnimationEngine.prototype.register = function (namespaceId, hostElement) {\x0a        var ns = this._namespaceLookup[namespaceId];\x0a        if (!ns) {\x0a            ns = this.createNamespace(namespaceId, hostElement);\x0a        }\x0a        return ns;\x0a    };\x0a    TransitionAnimationEngine.prototype.registerTrigger = function (namespaceId, name, trigger) {\x0a        var ns = this._namespaceLookup[namespaceId];\x0a        if (ns && ns.register(name, trigger)) {\x0a            this.totalAnimations++;\x0a        }\x0a    };\x0a    TransitionAnimationEngine.prototype.destroy = function (namespaceId, context) {\x0a        var _this = this;\x0a        if (!namespaceId)\x0a            return;\x0a        var ns = this._fetchNamespace(namespaceId);\x0a        this.afterFlush(function () {\x0a            _this.namespacesByHostElement.delete(ns.hostElement);\x0a            delete _this._namespaceLookup[namespaceId];\x0a            var index = _this._namespaceList.indexOf(ns);\x0a            if (index \x3e= 0) {\x0a                _this._namespaceList.splice(index, 1);\x0a            }\x0a        });\x0a        this.afterFlushAnimationsDone(function () { return ns.destroy(context); });\x0a    };\x0a    TransitionAnimationEngine.prototype._fetchNamespace = function (id) { return this._namespaceLookup[id]; };\x0a    TransitionAnimationEngine.prototype.fetchNamespacesByElement = function (element) {\x0a        // normally there should only be one namespace per element, however\x0a        // if @triggers are placed on both the component element and then\x0a        // its host element (within the component code) then there will be\x0a        // two namespaces returned. We use a set here to simply the dedupe\x0a        // of namespaces incase there are multiple triggers both the elm and host\x0a        var namespaces = new Set();\x0a        var elementStates = this.statesByElement.get(element);\x0a        if (elementStates) {\x0a            var keys = Object.keys(elementStates);\x0a            for (var i = 0; i \x3c keys.length; i++) {\x0a                var nsId = elementStates[keys[i]].namespaceId;\x0a                if (nsId) {\x0a                    var ns = this._fetchNamespace(nsId);\x0a                    if (ns) {\x0a                        namespaces.add(ns);\x0a                    }\x0a                }\x0a            }\x0a        }\x0a        return namespaces;\x0a    };\x0a    TransitionAnimationEngine.prototype.trigger = function (namespaceId, element, name, value) {\x0a        if (isElementNode(element)) {\x0a            var ns = this._fetchNamespace(namespaceId);\x0a            if (ns) {\x0a                ns.trigger(element, name, value);\x0a                return true;\x0a            }\x0a        }\x0a        return false;\x0a    };\x0a    TransitionAnimationEngine.prototype.insertNode = function (namespaceId, element, parent, insertBefore) {\x0a        if (!isElementNode(element))\x0a            return;\x0a        // special case for when an element is removed and reinserted (move operation)\x0a        // when this occurs we do not want to use the element for deletion later\x0a        var details = element[REMOVAL_FLAG];\x0a        if (details && details.setForRemoval) {\x0a            details.setForRemoval = false;\x0a            details.setForMove = true;\x0a            var index = this.collectedLeaveElements.indexOf(element);\x0a            if (index \x3e= 0) {\x0a                this.collectedLeaveElements.splice(index, 1);\x0a            }\x0a        }\x0a        // in the event that the namespaceId is blank then the caller\x0a        // code does not contain any animation code in it, but it is\x0a        // just being called so that the node is marked as being inserted\x0a        if (namespaceId) {\x0a            var ns = this._fetchNamespace(namespaceId);\x0a            // This if-statement is a workaround for router issue #21947.\x0a            // The router sometimes hits a race condition where while a route\x0a            // is being instantiated a new navigation arrives, triggering leave\x0a            // animation of DOM that has not been fully initialized, until this\x0a            // is resolved, we need to handle the scenario when DOM is not in a\x0a            // consistent state during the animation.\x0a            if (ns) {\x0a                ns.insertNode(element, parent);\x0a            }\x0a        }\x0a        // only *directives and host elements are inserted before\x0a        if (insertBefore) {\x0a            this.collectEnterElement(element);\x0a        }\x0a    };\x0a    TransitionAnimationEngine.prototype.collectEnterElement = function (element) { this.collectedEnterElements.push(element); };\x0a    TransitionAnimationEngine.prototype.markElementAsDisabled = function (element, value) {\x0a        if (value) {\x0a            if (!this.disabledNodes.has(element)) {\x0a                this.disabledNodes.add(element);\x0a                addClass(element, DISABLED_CLASSNAME);\x0a            }\x0a        }\x0a        else if (this.disabledNodes.has(element)) {\x0a            this.disabledNodes.delete(element);\x0a            removeClass(element, DISABLED_CLASSNAME);\x0a        }\x0a    };\x0a    TransitionAnimationEngine.prototype.removeNode = function (namespaceId, element, context) {\x0a        if (!isElementNode(element)) {\x0a            this._onRemovalComplete(element, context);\x0a            return;\x0a        }\x0a        var ns = namespaceId ? this._fetchNamespace(namespaceId) : null;\x0a        if (ns) {\x0a            ns.removeNode(element, context);\x0a        }\x0a        else {\x0a            this.markElementAsRemoved(namespaceId, element, false, context);\x0a        }\x0a    };\x0a    TransitionAnimationEngine.prototype.markElementAsRemoved = function (namespaceId, element, hasAnimation, context) {\x0a        this.collectedLeaveElements.push(element);\x0a        element[REMOVAL_FLAG] = {\x0a            namespaceId: namespaceId,\x0a            setForRemoval: context, hasAnimation: hasAnimation,\x0a            removedBeforeQueried: false\x0a        };\x0a    };\x0a    TransitionAnimationEngine.prototype.listen = function (namespaceId, element, name, phase, callback) {\x0a        if (isElementNode(element)) {\x0a            return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);\x0a        }\x0a        return function () { };\x0a    };\x0a    TransitionAnimationEngine.prototype._buildInstruction = function (entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {\x0a        return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);\x0a    };\x0a    TransitionAnimationEngine.prototype.destroyInnerAnimations = function (containerElement) {\x0a        var _this = this;\x0a        var elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);\x0a        elements.forEach(function (element) { return _this.destroyActiveAnimationsForElement(element); });\x0a        if (this.playersByQueriedElement.size == 0)\x0a            return;\x0a        elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);\x0a        elements.forEach(function (element) { return _this.finishActiveQueriedAnimationOnElement(element); });\x0a    };\x0a    TransitionAnimationEngine.prototype.destroyActiveAnimationsForElement = function (element) {\x0a        var players = this.playersByElement.get(element);\x0a        if (players) {\x0a            players.forEach(function (player) {\x0a                // special case for when an element is set for destruction, but hasn\x27t started.\x0a                // in this situation we want to delay the destruction until the flush occurs\x0a                // so that any event listeners attached to the player are triggered.\x0a                if (player.queued) {\x0a                    player.markedForDestroy = true;\x0a                }\x0a                else {\x0a                    player.destroy();\x0a                }\x0a            });\x0a        }\x0a    };\x0a    TransitionAnimationEngine.prototype.finishActiveQueriedAnimationOnElement = function (element) {\x0a        var players = this.playersByQueriedElement.get(element);\x0a        if (players) {\x0a            players.forEach(function (player) { return player.finish(); });\x0a        }\x0a    };\x0a    TransitionAnimationEngine.prototype.whenRenderingDone = function () {\x0a        var _this = this;\x0a        return new Promise(function (resolve) {\x0a            if (_this.players.length) {\x0a                return optimizeGroupPlayer(_this.players).onDone(function () { return resolve(); });\x0a            }\x0a            else {\x0a                resolve();\x0a            }\x0a        });\x0a    };\x0a    TransitionAnimationEngine.prototype.processLeaveNode = function (element) {\x0a        var _this = this;\x0a        var details = element[REMOVAL_FLAG];\x0a        if (details && details.setForRemoval) {\x0a            // this will prevent it from removing it twice\x0a            element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;\x0a            if (details.namespaceId) {\x0a                this.destroyInnerAnimations(element);\x0a                var ns = this._fetchNamespace(details.namespaceId);\x0a                if (ns) {\x0a                    ns.clearElementCache(element);\x0a                }\x0a            }\x0a            this._onRemovalComplete(element, details.setForRemoval);\x0a        }\x0a        if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {\x0a            this.markElementAsDisabled(element, false);\x0a        }\x0a        this.driver.query(element, DISABLED_SELECTOR, true).forEach(function (node) {\x0a            _this.markElementAsDisabled(element, false);\x0a        });\x0a    };\x0a    TransitionAnimationEngine.prototype.flush = function (microtaskId) {\x0a        var _this = this;\x0a        if (microtaskId === void 0) { microtaskId = -1; }\x0a        var players = [];\x0a        if (this.newHostElements.size) {\x0a            this.newHostElements.forEach(function (ns, element) { return _this._balanceNamespaceList(ns, element); });\x0a            this.newHostElements.clear();\x0a        }\x0a        if (this.totalAnimations && this.collectedEnterElements.length) {\x0a            for (var i = 0; i \x3c this.collectedEnterElements.length; i++) {\x0a                var elm = this.collectedEnterElements[i];\x0a                addClass(elm, STAR_CLASSNAME);\x0a            }\x0a        }\x0a        if (this._namespaceList.length &&\x0a            (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {\x0a            var cleanupFns = [];\x0a            try {\x0a                players = this._flushAnimations(cleanupFns, microtaskId);\x0a            }\x0a            finally {\x0a                for (var i = 0; i \x3c cleanupFns.length; i++) {\x0a                    cleanupFns[i]();\x0a                }\x0a            }\x0a        }\x0a        else {\x0a            for (var i = 0; i \x3c this.collectedLeaveElements.length; i++) {\x0a                var element = this.collectedLeaveElements[i];\x0a                this.processLeaveNode(element);\x0a            }\x0a        }\x0a        this.totalQueuedPlayers = 0;\x0a        this.collectedEnterElements.length = 0;\x0a        this.collectedLeaveElements.length = 0;\x0a        this._flushFns.forEach(function (fn) { return fn(); });\x0a        this._flushFns = [];\x0a        if (this._whenQuietFns.length) {\x0a            // we move these over to a variable so that\x0a            // if any new callbacks are registered in another\x0a            // flush they do not populate the existing set\x0a            var quietFns_1 = this._whenQuietFns;\x0a            this._whenQuietFns = [];\x0a            if (players.length) {\x0a                optimizeGroupPlayer(players).onDone(function () { quietFns_1.forEach(function (fn) { return fn(); }); });\x0a            }\x0a            else {\x0a                quietFns_1.forEach(function (fn) { return fn(); });\x0a            }\x0a        }\x0a    };\x0a    TransitionAnimationEngine.prototype.reportError = function (errors) {\x0a        throw new Error(\x22Unable to process animations due to the following failed trigger transitions\x5cn \x22 + errors.join(\x27\x5cn\x27));\x0a    };\x0a    TransitionAnimationEngine.prototype._flushAnimations = function (cleanupFns, microtaskId) {\x0a        var _this = this;\x0a        var subTimelines = new ElementInstructionMap();\x0a        var skippedPlayers = [];\x0a        var skippedPlayersMap = new Map();\x0a        var queuedInstructions = [];\x0a        var queriedElements = new Map();\x0a        var allPreStyleElements = new Map();\x0a        var allPostStyleElements = new Map();\x0a        var disabledElementsSet = new Set();\x0a        this.disabledNodes.forEach(function (node) {\x0a            disabledElementsSet.add(node);\x0a            var nodesThatAreDisabled = _this.driver.query(node, QUEUED_SELECTOR, true);\x0a            for (var i_1 = 0; i_1 \x3c nodesThatAreDisabled.length; i_1++) {\x0a                disabledElementsSet.add(nodesThatAreDisabled[i_1]);\x0a            }\x0a        });\x0a        var bodyNode = this.bodyNode;\x0a        var allTriggerElements = Array.from(this.statesByElement.keys());\x0a        var enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);\x0a        // this must occur before the instructions are built below such that\x0a        // the :enter queries match the elements (since the timeline queries\x0a        // are fired during instruction building).\x0a        var enterNodeMapIds = new Map();\x0a        var i = 0;\x0a        enterNodeMap.forEach(function (nodes, root) {\x0a            var className = ENTER_CLASSNAME + i++;\x0a            enterNodeMapIds.set(root, className);\x0a            nodes.forEach(function (node) { return addClass(node, className); });\x0a        });\x0a        var allLeaveNodes = [];\x0a        var mergedLeaveNodes = new Set();\x0a        var leaveNodesWithoutAnimations = new Set();\x0a        for (var i_2 = 0; i_2 \x3c this.collectedLeaveElements.length; i_2++) {\x0a            var element = this.collectedLeaveElements[i_2];\x0a            var details = element[REMOVAL_FLAG];\x0a            if (details && details.setForRemoval) {\x0a                allLeaveNodes.push(element);\x0a                mergedLeaveNodes.add(element);\x0a                if (details.hasAnimation) {\x0a                    this.driver.query(element, STAR_SELECTOR, true).forEach(function (elm) { return mergedLeaveNodes.add(elm); });\x0a                }\x0a                else {\x0a                    leaveNodesWithoutAnimations.add(element);\x0a                }\x0a            }\x0a        }\x0a        var leaveNodeMapIds = new Map();\x0a        var leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));\x0a        leaveNodeMap.forEach(function (nodes, root) {\x0a            var className = LEAVE_CLASSNAME + i++;\x0a            leaveNodeMapIds.set(root, className);\x0a            nodes.forEach(function (node) { return addClass(node, className); });\x0a        });\x0a        cleanupFns.push(function () {\x0a            enterNodeMap.forEach(function (nodes, root) {\x0a                var className = enterNodeMapIds.get(root);\x0a                nodes.forEach(function (node) { return removeClass(node, className); });\x0a            });\x0a            leaveNodeMap.forEach(function (nodes, root) {\x0a                var className = leaveNodeMapIds.get(root);\x0a                nodes.forEach(function (node) { return removeClass(node, className); });\x0a            });\x0a            allLeaveNodes.forEach(function (element) { _this.processLeaveNode(element); });\x0a        });\x0a        var allPlayers = [];\x0a        var erroneousTransitions = [];\x0a        for (var i_3 = this._namespaceList.length - 1; i_3 \x3e= 0; i_3--) {\x0a            var ns = this._namespaceList[i_3];\x0a            ns.drainQueuedTransitions(microtaskId).forEach(function (entry) {\x0a                var player = entry.player;\x0a                var element = entry.element;\x0a                allPlayers.push(player);\x0a                if (_this.collectedEnterElements.length) {\x0a                    var details = element[REMOVAL_FLAG];\x0a                    // move animations are currently not supported...\x0a                    if (details && details.setForMove) {\x0a                        player.destroy();\x0a                        return;\x0a                    }\x0a                }\x0a                var nodeIsOrphaned = !bodyNode || !_this.driver.containsElement(bodyNode, element);\x0a                var leaveClassName = leaveNodeMapIds.get(element);\x0a                var enterClassName = enterNodeMapIds.get(element);\x0a                var instruction = _this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);\x0a                if (instruction.errors && instruction.errors.length) {\x0a                    erroneousTransitions.push(instruction);\x0a                    return;\x0a                }\x0a                // even though the element may not be apart of the DOM, it may\x0a                // still be added at a later point (due to the mechanics of content\x0a                // projection and/or dynamic component insertion) therefore it\x27s\x0a                // important we still style the element.\x0a                if (nodeIsOrphaned) {\x0a                    player.onStart(function () { return eraseStyles(element, instruction.fromStyles); });\x0a                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });\x0a                    skippedPlayers.push(player);\x0a                    return;\x0a                }\x0a                // if a unmatched transition is queued to go then it SHOULD NOT render\x0a                // an animation and cancel the previously running animations.\x0a                if (entry.isFallbackTransition) {\x0a                    player.onStart(function () { return eraseStyles(element, instruction.fromStyles); });\x0a                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });\x0a                    skippedPlayers.push(player);\x0a                    return;\x0a                }\x0a                // this means that if a parent animation uses this animation as a sub trigger\x0a                // then it will instruct the timeline builder to not add a player delay, but\x0a                // instead stretch the first keyframe gap up until the animation starts. The\x0a                // reason this is important is to prevent extra initialization styles from being\x0a                // required by the user in the animation.\x0a                instruction.timelines.forEach(function (tl) { return tl.stretchStartingKeyframe = true; });\x0a                subTimelines.append(element, instruction.timelines);\x0a                var tuple = { instruction: instruction, player: player, element: element };\x0a                queuedInstructions.push(tuple);\x0a                instruction.queriedElements.forEach(function (element) { return getOrSetAsInMap(queriedElements, element, []).push(player); });\x0a                instruction.preStyleProps.forEach(function (stringMap, element) {\x0a                    var props = Object.keys(stringMap);\x0a                    if (props.length) {\x0a                        var setVal_1 = allPreStyleElements.get(element);\x0a                        if (!setVal_1) {\x0a                            allPreStyleElements.set(element, setVal_1 = new Set());\x0a                        }\x0a                        props.forEach(function (prop) { return setVal_1.add(prop); });\x0a                    }\x0a                });\x0a                instruction.postStyleProps.forEach(function (stringMap, element) {\x0a                    var props = Object.keys(stringMap);\x0a                    var setVal = allPostStyleElements.get(element);\x0a                    if (!setVal) {\x0a                        allPostStyleElements.set(element, setVal = new Set());\x0a                    }\x0a                    props.forEach(function (prop) { return setVal.add(prop); });\x0a                });\x0a            });\x0a        }\x0a        if (erroneousTransitions.length) {\x0a            var errors_1 = [];\x0a            erroneousTransitions.forEach(function (instruction) {\x0a                errors_1.push(\x22@\x22 + instruction.triggerName + \x22 has failed due to:\x5cn\x22);\x0a                instruction.errors.forEach(function (error) { return errors_1.push(\x22- \x22 + error + \x22\x5cn\x22); });\x0a            });\x0a            allPlayers.forEach(function (player) { return player.destroy(); });\x0a            this.reportError(errors_1);\x0a        }\x0a        var allPreviousPlayersMap = new Map();\x0a        // this map works to tell which element in the DOM tree is contained by\x0a        // which animation. Further down below this map will get populated once\x0a        // the players are built and in doing so it can efficiently figure out\x0a        // if a sub player is skipped due to a parent player having priority.\x0a        var animationElementMap = new Map();\x0a        queuedInstructions.forEach(function (entry) {\x0a            var element = entry.element;\x0a            if (subTimelines.has(element)) {\x0a                animationElementMap.set(element, element);\x0a                _this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);\x0a            }\x0a        });\x0a        skippedPlayers.forEach(function (player) {\x0a            var element = player.element;\x0a            var previousPlayers = _this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);\x0a            previousPlayers.forEach(function (prevPlayer) {\x0a                getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);\x0a                prevPlayer.destroy();\x0a            });\x0a        });\x0a        // this is a special case for nodes that will be removed (either by)\x0a        // having their own leave animations or by being queried in a container\x0a        // that will be removed once a parent animation is complete. The idea\x0a        // here is that * styles must be identical to ! styles because of\x0a        // backwards compatibility (* is also filled in by default in many places).\x0a        // Otherwise * styles will return an empty value or auto since the element\x0a        // that is being getComputedStyle\x27d will not be visible (since * = destination)\x0a        var replaceNodes = allLeaveNodes.filter(function (node) {\x0a            return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);\x0a        });\x0a        // POST STAGE: fill the * styles\x0a        var postStylesMap = new Map();\x0a        var allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22AUTO_STYLE\x22]);\x0a        allLeaveQueriedNodes.forEach(function (node) {\x0a            if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {\x0a                replaceNodes.push(node);\x0a            }\x0a        });\x0a        // PRE STAGE: fill the ! styles\x0a        var preStylesMap = new Map();\x0a        enterNodeMap.forEach(function (nodes, root) {\x0a            cloakAndComputeStyles(preStylesMap, _this.driver, new Set(nodes), allPreStyleElements, _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22\xc9\xb5PRE_STYLE\x22]);\x0a        });\x0a        replaceNodes.forEach(function (node) {\x0a            var post = postStylesMap.get(node);\x0a            var pre = preStylesMap.get(node);\x0a            postStylesMap.set(node, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__assign\x22])({}, post, pre));\x0a        });\x0a        var rootPlayers = [];\x0a        var subPlayers = [];\x0a        var NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};\x0a        queuedInstructions.forEach(function (entry) {\x0a            var element = entry.element, player = entry.player, instruction = entry.instruction;\x0a            // this means that it was never consumed by a parent animation which\x0a            // means that it is independent and therefore should be set for animation\x0a            if (subTimelines.has(element)) {\x0a                if (disabledElementsSet.has(element)) {\x0a                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });\x0a                    player.disabled = true;\x0a                    player.overrideTotalTime(instruction.totalTime);\x0a                    skippedPlayers.push(player);\x0a                    return;\x0a                }\x0a                // this will flow up the DOM and query the map to figure out\x0a                // if a parent animation has priority over it. In the situation\x0a                // that a parent is detected then it will cancel the loop. If\x0a                // nothing is detected, or it takes a few hops to find a parent,\x0a                // then it will fill in the missing nodes and signal them as having\x0a                // a detected parent (or a NO_PARENT value via a special constant).\x0a                var parentWithAnimation_1 = NO_PARENT_ANIMATION_ELEMENT_DETECTED;\x0a                if (animationElementMap.size \x3e 1) {\x0a                    var elm = element;\x0a                    var parentsToAdd = [];\x0a                    while (elm = elm.parentNode) {\x0a                        var detectedParent = animationElementMap.get(elm);\x0a                        if (detectedParent) {\x0a                            parentWithAnimation_1 = detectedParent;\x0a                            break;\x0a                        }\x0a                        parentsToAdd.push(elm);\x0a                    }\x0a                    parentsToAdd.forEach(function (parent) { return animationElementMap.set(parent, parentWithAnimation_1); });\x0a                }\x0a                var innerPlayer = _this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);\x0a                player.setRealPlayer(innerPlayer);\x0a                if (parentWithAnimation_1 === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {\x0a                    rootPlayers.push(player);\x0a                }\x0a                else {\x0a                    var parentPlayers = _this.playersByElement.get(parentWithAnimation_1);\x0a                    if (parentPlayers && parentPlayers.length) {\x0a                        player.parentPlayer = optimizeGroupPlayer(parentPlayers);\x0a                    }\x0a                    skippedPlayers.push(player);\x0a                }\x0a            }\x0a            else {\x0a                eraseStyles(element, instruction.fromStyles);\x0a                player.onDestroy(function () { return setStyles(element, instruction.toStyles); });\x0a                // there still might be a ancestor player animating this\x0a                // element therefore we will still add it as a sub player\x0a                // even if its animation may be disabled\x0a                subPlayers.push(player);\x0a                if (disabledElementsSet.has(element)) {\x0a                    skippedPlayers.push(player);\x0a                }\x0a            }\x0a        });\x0a        // find all of the sub players\x27 corresponding inner animation player\x0a        subPlayers.forEach(function (player) {\x0a            // even if any players are not found for a sub animation then it\x0a            // will still complete itself after the next tick since it\x27s Noop\x0a            var playersForElement = skippedPlayersMap.get(player.element);\x0a            if (playersForElement && playersForElement.length) {\x0a                var innerPlayer = optimizeGroupPlayer(playersForElement);\x0a                player.setRealPlayer(innerPlayer);\x0a            }\x0a        });\x0a        // the reason why we don\x27t actually play the animation is\x0a        // because all that a skipped player is designed to do is to\x0a        // fire the start/done transition callback events\x0a        skippedPlayers.forEach(function (player) {\x0a            if (player.parentPlayer) {\x0a                player.syncPlayerEvents(player.parentPlayer);\x0a            }\x0a            else {\x0a                player.destroy();\x0a            }\x0a        });\x0a        // run through all of the queued removals and see if they\x0a        // were picked up by a query. If not then perform the removal\x0a        // operation right away unless a parent animation is ongoing.\x0a        for (var i_4 = 0; i_4 \x3c allLeaveNodes.length; i_4++) {\x0a            var element = allLeaveNodes[i_4];\x0a            var details = element[REMOVAL_FLAG];\x0a            removeClass(element, LEAVE_CLASSNAME);\x0a            // this means the element has a removal animation that is being\x0a            // taken care of and therefore the inner elements will hang around\x0a            // until that animation is over (or the parent queried animation)\x0a            if (details && details.hasAnimation)\x0a                continue;\x0a            var players = [];\x0a            // if this element is queried or if it contains queried children\x0a            // then we want for the element not to be removed from the page\x0a            // until the queried animations have finished\x0a            if (queriedElements.size) {\x0a                var queriedPlayerResults = queriedElements.get(element);\x0a                if (queriedPlayerResults && queriedPlayerResults.length) {\x0a                    players.push.apply(players, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__spread\x22])(queriedPlayerResults));\x0a                }\x0a                var queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);\x0a                for (var j = 0; j \x3c queriedInnerElements.length; j++) {\x0a                    var queriedPlayers = queriedElements.get(queriedInnerElements[j]);\x0a                    if (queriedPlayers && queriedPlayers.length) {\x0a                        players.push.apply(players, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__spread\x22])(queriedPlayers));\x0a                    }\x0a                }\x0a            }\x0a            var activePlayers = players.filter(function (p) { return !p.destroyed; });\x0a            if (activePlayers.length) {\x0a                removeNodesAfterAnimationDone(this, element, activePlayers);\x0a            }\x0a            else {\x0a                this.processLeaveNode(element);\x0a            }\x0a        }\x0a        // this is required so the cleanup method doesn\x27t remove them\x0a        allLeaveNodes.length = 0;\x0a        rootPlayers.forEach(function (player) {\x0a            _this.players.push(player);\x0a            player.onDone(function () {\x0a                player.destroy();\x0a                var index = _this.players.indexOf(player);\x0a                _this.players.splice(index, 1);\x0a            });\x0a            player.play();\x0a        });\x0a        return rootPlayers;\x0a    };\x0a    TransitionAnimationEngine.prototype.elementContainsData = function (namespaceId, element) {\x0a        var containsData = false;\x0a        var details = element[REMOVAL_FLAG];\x0a        if (details && details.setForRemoval)\x0a            containsData = true;\x0a        if (this.playersByElement.has(element))\x0a            containsData = true;\x0a        if (this.playersByQueriedElement.has(element))\x0a            containsData = true;\x0a        if (this.statesByElement.has(element))\x0a            containsData = true;\x0a        return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;\x0a    };\x0a    TransitionAnimationEngine.prototype.afterFlush = function (callback) { this._flushFns.push(callback); };\x0a    TransitionAnimationEngine.prototype.afterFlushAnimationsDone = function (callback) { this._whenQuietFns.push(callback); };\x0a    TransitionAnimationEngine.prototype._getPreviousPlayers = function (element, isQueriedElement, namespaceId, triggerName, toStateValue) {\x0a        var players = [];\x0a        if (isQueriedElement) {\x0a            var queriedElementPlayers = this.playersByQueriedElement.get(element);\x0a            if (queriedElementPlayers) {\x0a                players = queriedElementPlayers;\x0a            }\x0a        }\x0a        else {\x0a            var elementPlayers = this.playersByElement.get(element);\x0a            if (elementPlayers) {\x0a                var isRemovalAnimation_1 = !toStateValue || toStateValue == VOID_VALUE;\x0a                elementPlayers.forEach(function (player) {\x0a                    if (player.queued)\x0a                        return;\x0a                    if (!isRemovalAnimation_1 && player.triggerName != triggerName)\x0a                        return;\x0a                    players.push(player);\x0a                });\x0a            }\x0a        }\x0a        if (namespaceId || triggerName) {\x0a            players = players.filter(function (player) {\x0a                if (namespaceId && namespaceId != player.namespaceId)\x0a                    return false;\x0a                if (triggerName && triggerName != player.triggerName)\x0a                    return false;\x0a                return true;\x0a            });\x0a        }\x0a        return players;\x0a    };\x0a    TransitionAnimationEngine.prototype._beforeAnimationBuild = function (namespaceId, instruction, allPreviousPlayersMap) {\x0a        var e_1, _a;\x0a        var triggerName = instruction.triggerName;\x0a        var rootElement = instruction.element;\x0a        // when a removal animation occurs, ALL previous players are collected\x0a        // and destroyed (even if they are outside of the current namespace)\x0a        var targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;\x0a        var targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;\x0a        var _loop_1 = function (timelineInstruction) {\x0a            var element = timelineInstruction.element;\x0a            var isQueriedElement = element !== rootElement;\x0a            var players = getOrSetAsInMap(allPreviousPlayersMap, element, []);\x0a            var previousPlayers = this_1._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);\x0a            previousPlayers.forEach(function (player) {\x0a                var realPlayer = player.getRealPlayer();\x0a                if (realPlayer.beforeDestroy) {\x0a                    realPlayer.beforeDestroy();\x0a                }\x0a                player.destroy();\x0a                players.push(player);\x0a            });\x0a        };\x0a        var this_1 = this;\x0a        try {\x0a            for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__values\x22])(instruction.timelines), _c = _b.next(); !_c.done; _c = _b.next()) {\x0a                var timelineInstruction = _c.value;\x0a                _loop_1(timelineInstruction);\x0a            }\x0a        }\x0a        catch (e_1_1) { e_1 = { error: e_1_1 }; }\x0a        finally {\x0a            try {\x0a                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\x0a            }\x0a            finally { if (e_1) throw e_1.error; }\x0a        }\x0a        // this needs to be done so that the PRE/POST styles can be\x0a        // computed properly without interfering with the previous animation\x0a        eraseStyles(rootElement, instruction.fromStyles);\x0a    };\x0a    TransitionAnimationEngine.prototype._buildAnimation = function (namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {\x0a        var _this = this;\x0a        var triggerName = instruction.triggerName;\x0a        var rootElement = instruction.element;\x0a        // we first run this so that the previous animation player\x0a        // data can be passed into the successive animation players\x0a        var allQueriedPlayers = [];\x0a        var allConsumedElements = new Set();\x0a        var allSubElements = new Set();\x0a        var allNewPlayers = instruction.timelines.map(function (timelineInstruction) {\x0a            var element = timelineInstruction.element;\x0a            allConsumedElements.add(element);\x0a            // FIXME (matsko): make sure to-be-removed animations are removed properly\x0a            var details = element[REMOVAL_FLAG];\x0a            if (details && details.removedBeforeQueried)\x0a                return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22NoopAnimationPlayer\x22](timelineInstruction.duration, timelineInstruction.delay);\x0a            var isQueriedElement = element !== rootElement;\x0a            var previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY)\x0a                .map(function (p) { return p.getRealPlayer(); }))\x0a                .filter(function (p) {\x0a                // the `element` is not apart of the AnimationPlayer definition, but\x0a                // Mock/WebAnimations\x0a                // use the element within their implementation. This will be added in Angular5 to\x0a                // AnimationPlayer\x0a                var pp = p;\x0a                return pp.element ? pp.element === element : false;\x0a            });\x0a            var preStyles = preStylesMap.get(element);\x0a            var postStyles = postStylesMap.get(element);\x0a            var keyframes = normalizeKeyframes(_this.driver, _this._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);\x0a            var player = _this._buildPlayer(timelineInstruction, keyframes, previousPlayers);\x0a            // this means that this particular player belongs to a sub trigger. It is\x0a            // important that we match this player up with the corresponding (@trigger.listener)\x0a            if (timelineInstruction.subTimeline && skippedPlayersMap) {\x0a                allSubElements.add(element);\x0a            }\x0a            if (isQueriedElement) {\x0a                var wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);\x0a                wrappedPlayer.setRealPlayer(player);\x0a                allQueriedPlayers.push(wrappedPlayer);\x0a            }\x0a            return player;\x0a        });\x0a        allQueriedPlayers.forEach(function (player) {\x0a            getOrSetAsInMap(_this.playersByQueriedElement, player.element, []).push(player);\x0a            player.onDone(function () { return deleteOrUnsetInMap(_this.playersByQueriedElement, player.element, player); });\x0a        });\x0a        allConsumedElements.forEach(function (element) { return addClass(element, NG_ANIMATING_CLASSNAME); });\x0a        var player = optimizeGroupPlayer(allNewPlayers);\x0a        player.onDestroy(function () {\x0a            allConsumedElements.forEach(function (element) { return removeClass(element, NG_ANIMATING_CLASSNAME); });\x0a            setStyles(rootElement, instruction.toStyles);\x0a        });\x0a        // this basically makes all of the callbacks for sub element animations\x0a        // be dependent on the upper players for when they finish\x0a        allSubElements.forEach(function (element) { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });\x0a        return player;\x0a    };\x0a    TransitionAnimationEngine.prototype._buildPlayer = function (instruction, keyframes, previousPlayers) {\x0a        if (keyframes.length \x3e 0) {\x0a            return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);\x0a        }\x0a        // special case for when an empty transition|definition is provided\x0a        // ... there is no point in rendering an empty animation\x0a        return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22NoopAnimationPlayer\x22](instruction.duration, instruction.delay);\x0a    };\x0a    return TransitionAnimationEngine;\x0a}());\x0avar TransitionAnimationPlayer = /** @class */ (function () {\x0a    function TransitionAnimationPlayer(namespaceId, triggerName, element) {\x0a        this.namespaceId = namespaceId;\x0a        this.triggerName = triggerName;\x0a        this.element = element;\x0a        this._player = new _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22NoopAnimationPlayer\x22]();\x0a        this._containsRealPlayer = false;\x0a        this._queuedCallbacks = {};\x0a        this.destroyed = false;\x0a        this.markedForDestroy = false;\x0a        this.disabled = false;\x0a        this.queued = true;\x0a        this.totalTime = 0;\x0a    }\x0a    TransitionAnimationPlayer.prototype.setRealPlayer = function (player) {\x0a        var _this = this;\x0a        if (this._containsRealPlayer)\x0a            return;\x0a        this._player = player;\x0a        Object.keys(this._queuedCallbacks).forEach(function (phase) {\x0a            _this._queuedCallbacks[phase].forEach(function (callback) { return listenOnPlayer(player, phase, undefined, callback); });\x0a        });\x0a        this._queuedCallbacks = {};\x0a        this._containsRealPlayer = true;\x0a        this.overrideTotalTime(player.totalTime);\x0a        this.queued = false;\x0a    };\x0a    TransitionAnimationPlayer.prototype.getRealPlayer = function () { return this._player; };\x0a    TransitionAnimationPlayer.prototype.overrideTotalTime = function (totalTime) { this.totalTime = totalTime; };\x0a    TransitionAnimationPlayer.prototype.syncPlayerEvents = function (player) {\x0a        var _this = this;\x0a        var p = this._player;\x0a        if (p.triggerCallback) {\x0a            player.onStart(function () { return p.triggerCallback(\x27start\x27); });\x0a        }\x0a        player.onDone(function () { return _this.finish(); });\x0a        player.onDestroy(function () { return _this.destroy(); });\x0a    };\x0a    TransitionAnimationPlayer.prototype._queueEvent = function (name, callback) {\x0a        getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);\x0a    };\x0a    TransitionAnimationPlayer.prototype.onDone = function (fn) {\x0a        if (this.queued) {\x0a            this._queueEvent(\x27done\x27, fn);\x0a        }\x0a        this._player.onDone(fn);\x0a    };\x0a    TransitionAnimationPlayer.prototype.onStart = function (fn) {\x0a        if (this.queued) {\x0a            this._queueEvent(\x27start\x27, fn);\x0a        }\x0a        this._player.onStart(fn);\x0a    };\x0a    TransitionAnimationPlayer.prototype.onDestroy = function (fn) {\x0a        if (this.queued) {\x0a            this._queueEvent(\x27destroy\x27, fn);\x0a        }\x0a        this._player.onDestroy(fn);\x0a    };\x0a    TransitionAnimationPlayer.prototype.init = function () { this._player.init(); };\x0a    TransitionAnimationPlayer.prototype.hasStarted = function () { return this.queued ? false : this._player.hasStarted(); };\x0a    TransitionAnimationPlayer.prototype.play = function () { !this.queued && this._player.play(); };\x0a    TransitionAnimationPlayer.prototype.pause = function () { !this.queued && this._player.pause(); };\x0a    TransitionAnimationPlayer.prototype.restart = function () { !this.queued && this._player.restart(); };\x0a    TransitionAnimationPlayer.prototype.finish = function () { this._player.finish(); };\x0a    TransitionAnimationPlayer.prototype.destroy = function () {\x0a        this.destroyed = true;\x0a        this._player.destroy();\x0a    };\x0a    TransitionAnimationPlayer.prototype.reset = function () { !this.queued && this._player.reset(); };\x0a    TransitionAnimationPlayer.prototype.setPosition = function (p) {\x0a        if (!this.queued) {\x0a            this._player.setPosition(p);\x0a        }\x0a    };\x0a    TransitionAnimationPlayer.prototype.getPosition = function () { return this.queued ? 0 : this._player.getPosition(); };\x0a    /** @internal */\x0a    TransitionAnimationPlayer.prototype.triggerCallback = function (phaseName) {\x0a        var p = this._player;\x0a        if (p.triggerCallback) {\x0a            p.triggerCallback(phaseName);\x0a        }\x0a    };\x0a    return TransitionAnimationPlayer;\x0a}());\x0afunction deleteOrUnsetInMap(map, key, value) {\x0a    var currentValues;\x0a    if (map instanceof Map) {\x0a        currentValues = map.get(key);\x0a        if (currentValues) {\x0a            if (currentValues.length) {\x0a                var index = currentValues.indexOf(value);\x0a                currentValues.splice(index, 1);\x0a            }\x0a            if (currentValues.length == 0) {\x0a                map.delete(key);\x0a            }\x0a        }\x0a    }\x0a    else {\x0a        currentValues = map[key];\x0a        if (currentValues) {\x0a            if (currentValues.length) {\x0a                var index = currentValues.indexOf(value);\x0a                currentValues.splice(index, 1);\x0a            }\x0a            if (currentValues.length == 0) {\x0a                delete map[key];\x0a            }\x0a        }\x0a    }\x0a    return currentValues;\x0a}\x0afunction normalizeTriggerValue(value) {\x0a    // we use `!= null` here because it\x27s the most simple\x0a    // way to test against a \x22falsy\x22 value without mixing\x0a    // in empty strings or a zero value. DO NOT OPTIMIZE.\x0a    return value != null ? value : null;\x0a}\x0afunction isElementNode(node) {\x0a    return node && node[\x27nodeType\x27] === 1;\x0a}\x0afunction isTriggerEventValid(eventName) {\x0a    return eventName == \x27start\x27 || eventName == \x27done\x27;\x0a}\x0afunction cloakElement(element, value) {\x0a    var oldValue = element.style.display;\x0a    element.style.display = value != null ? value : \x27none\x27;\x0a    return oldValue;\x0a}\x0afunction cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {\x0a    var cloakVals = [];\x0a    elements.forEach(function (element) { return cloakVals.push(cloakElement(element)); });\x0a    var failedElements = [];\x0a    elementPropsMap.forEach(function (props, element) {\x0a        var styles = {};\x0a        props.forEach(function (prop) {\x0a            var value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);\x0a            // there is no easy way to detect this because a sub element could be removed\x0a            // by a parent animation element being detached.\x0a            if (!value || value.length == 0) {\x0a                element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;\x0a                failedElements.push(element);\x0a            }\x0a        });\x0a        valuesMap.set(element, styles);\x0a    });\x0a    // we use a index variable here since Set.forEach(a, i) does not return\x0a    // an index value for the closure (but instead just the value)\x0a    var i = 0;\x0a    elements.forEach(function (element) { return cloakElement(element, cloakVals[i++]); });\x0a    return failedElements;\x0a}\x0a/*\x0aSince the Angular renderer code will return a collection of inserted\x0anodes in all areas of a DOM tree, it\x27s up to this algorithm to figure\x0aout which nodes are roots for each animation @trigger.\x0a\x0aBy placing each inserted node into a Set and traversing upwards, it\x0ais possible to find the @trigger elements and well any direct *star\x0ainsertion nodes, if a @trigger root is found then the enter element\x0ais placed into the Map[@trigger] spot.\x0a */\x0afunction buildRootMap(roots, nodes) {\x0a    var rootMap = new Map();\x0a    roots.forEach(function (root) { return rootMap.set(root, []); });\x0a    if (nodes.length == 0)\x0a        return rootMap;\x0a    var NULL_NODE = 1;\x0a    var nodeSet = new Set(nodes);\x0a    var localRootMap = new Map();\x0a    function getRoot(node) {\x0a        if (!node)\x0a            return NULL_NODE;\x0a        var root = localRootMap.get(node);\x0a        if (root)\x0a            return root;\x0a        var parent = node.parentNode;\x0a        if (rootMap.has(parent)) { // ngIf inside @trigger\x0a            root = parent;\x0a        }\x0a        else if (nodeSet.has(parent)) { // ngIf inside ngIf\x0a            root = NULL_NODE;\x0a        }\x0a        else { // recurse upwards\x0a            root = getRoot(parent);\x0a        }\x0a        localRootMap.set(node, root);\x0a        return root;\x0a    }\x0a    nodes.forEach(function (node) {\x0a        var root = getRoot(node);\x0a        if (root !== NULL_NODE) {\x0a            rootMap.get(root).push(node);\x0a        }\x0a    });\x0a    return rootMap;\x0a}\x0avar CLASSES_CACHE_KEY = \x27$$classes\x27;\x0afunction addClass(element, className) {\x0a    if (element.classList) {\x0a        element.classList.add(className);\x0a    }\x0a    else {\x0a        var classes = element[CLASSES_CACHE_KEY];\x0a        if (!classes) {\x0a            classes = element[CLASSES_CACHE_KEY] = {};\x0a        }\x0a        classes[className] = true;\x0a    }\x0a}\x0afunction removeClass(element, className) {\x0a    if (element.classList) {\x0a        element.classList.remove(className);\x0a    }\x0a    else {\x0a        var classes = element[CLASSES_CACHE_KEY];\x0a        if (classes) {\x0a            delete classes[className];\x0a        }\x0a    }\x0a}\x0afunction removeNodesAfterAnimationDone(engine, element, players) {\x0a    optimizeGroupPlayer(players).onDone(function () { return engine.processLeaveNode(element); });\x0a}\x0afunction flattenGroupPlayers(players) {\x0a    var finalPlayers = [];\x0a    _flattenGroupPlayersRecur(players, finalPlayers);\x0a    return finalPlayers;\x0a}\x0afunction _flattenGroupPlayersRecur(players, finalPlayers) {\x0a    for (var i = 0; i \x3c players.length; i++) {\x0a        var player = players[i];\x0a        if (player instanceof _angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22\xc9\xb5AnimationGroupPlayer\x22]) {\x0a            _flattenGroupPlayersRecur(player.players, finalPlayers);\x0a        }\x0a        else {\x0a            finalPlayers.push(player);\x0a        }\x0a    }\x0a}\x0afunction objEquals(a, b) {\x0a    var k1 = Object.keys(a);\x0a    var k2 = Object.keys(b);\x0a    if (k1.length != k2.length)\x0a        return false;\x0a    for (var i = 0; i \x3c k1.length; i++) {\x0a        var prop = k1[i];\x0a        if (!b.hasOwnProperty(prop) || a[prop] !== b[prop])\x0a            return false;\x0a    }\x0a    return true;\x0a}\x0afunction replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {\x0a    var postEntry = allPostStyleElements.get(element);\x0a    if (!postEntry)\x0a        return false;\x0a    var preEntry = allPreStyleElements.get(element);\x0a    if (preEntry) {\x0a        postEntry.forEach(function (data) { return preEntry.add(data); });\x0a    }\x0a    else {\x0a        allPreStyleElements.set(element, postEntry);\x0a    }\x0a    allPostStyleElements.delete(element);\x0a    return true;\x0a}\x0a\x0avar AnimationEngine = /** @class */ (function () {\x0a    function AnimationEngine(bodyNode, _driver, normalizer) {\x0a        var _this = this;\x0a        this.bodyNode = bodyNode;\x0a        this._driver = _driver;\x0a        this._triggerCache = {};\x0a        // this method is designed to be overridden by the code that uses this engine\x0a        this.onRemovalComplete = function (element, context) { };\x0a        this._transitionEngine = new TransitionAnimationEngine(bodyNode, _driver, normalizer);\x0a        this._timelineEngine = new TimelineAnimationEngine(bodyNode, _driver, normalizer);\x0a        this._transitionEngine.onRemovalComplete = function (element, context) {\x0a            return _this.onRemovalComplete(element, context);\x0a        };\x0a    }\x0a    AnimationEngine.prototype.registerTrigger = function (componentId, namespaceId, hostElement, name, metadata) {\x0a        var cacheKey = componentId + \x27-\x27 + name;\x0a        var trigger = this._triggerCache[cacheKey];\x0a        if (!trigger) {\x0a            var errors = [];\x0a            var ast = buildAnimationAst(this._driver, metadata, errors);\x0a            if (errors.length) {\x0a                throw new Error(\x22The animation trigger \x5c\x22\x22 + name + \x22\x5c\x22 has failed to build due to the following errors:\x5cn - \x22 + errors.join(\x22\x5cn - \x22));\x0a            }\x0a            trigger = buildTrigger(name, ast);\x0a            this._triggerCache[cacheKey] = trigger;\x0a        }\x0a        this._transitionEngine.registerTrigger(namespaceId, name, trigger);\x0a    };\x0a    AnimationEngine.prototype.register = function (namespaceId, hostElement) {\x0a        this._transitionEngine.register(namespaceId, hostElement);\x0a    };\x0a    AnimationEngine.prototype.destroy = function (namespaceId, context) {\x0a        this._transitionEngine.destroy(namespaceId, context);\x0a    };\x0a    AnimationEngine.prototype.onInsert = function (namespaceId, element, parent, insertBefore) {\x0a        this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);\x0a    };\x0a    AnimationEngine.prototype.onRemove = function (namespaceId, element, context) {\x0a        this._transitionEngine.removeNode(namespaceId, element, context);\x0a    };\x0a    AnimationEngine.prototype.disableAnimations = function (element, disable) {\x0a        this._transitionEngine.markElementAsDisabled(element, disable);\x0a    };\x0a    AnimationEngine.prototype.process = function (namespaceId, element, property, value) {\x0a        if (property.charAt(0) == \x27@\x27) {\x0a            var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__read\x22])(parseTimelineCommand(property), 2), id = _a[0], action = _a[1];\x0a            var args = value;\x0a            this._timelineEngine.command(id, element, action, args);\x0a        }\x0a        else {\x0a            this._transitionEngine.trigger(namespaceId, element, property, value);\x0a        }\x0a    };\x0a    AnimationEngine.prototype.listen = function (namespaceId, element, eventName, eventPhase, callback) {\x0a        // @@listen\x0a        if (eventName.charAt(0) == \x27@\x27) {\x0a            var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__read\x22])(parseTimelineCommand(eventName), 2), id = _a[0], action = _a[1];\x0a            return this._timelineEngine.listen(id, element, action, callback);\x0a        }\x0a        return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);\x0a    };\x0a    AnimationEngine.prototype.flush = function (microtaskId) {\x0a        if (microtaskId === void 0) { microtaskId = -1; }\x0a        this._transitionEngine.flush(microtaskId);\x0a    };\x0a    Object.defineProperty(AnimationEngine.prototype, \x22players\x22, {\x0a        get: function () {\x0a            return this._transitionEngine.players\x0a                .concat(this._timelineEngine.players);\x0a        },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    AnimationEngine.prototype.whenRenderingDone = function () { return this._transitionEngine.whenRenderingDone(); };\x0a    return AnimationEngine;\x0a}());\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0avar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\x0avar ANIMATION_PROP = \x27animation\x27;\x0avar ANIMATIONEND_EVENT = \x27animationend\x27;\x0avar ONE_SECOND$1 = 1000;\x0avar ElementAnimationStyleHandler = /** @class */ (function () {\x0a    function ElementAnimationStyleHandler(_element, _name, _duration, _delay, _easing, _fillMode, _onDoneFn) {\x0a        var _this = this;\x0a        this._element = _element;\x0a        this._name = _name;\x0a        this._duration = _duration;\x0a        this._delay = _delay;\x0a        this._easing = _easing;\x0a        this._fillMode = _fillMode;\x0a        this._onDoneFn = _onDoneFn;\x0a        this._finished = false;\x0a        this._destroyed = false;\x0a        this._startTime = 0;\x0a        this._position = 0;\x0a        this._eventFn = function (e) { return _this._handleCallback(e); };\x0a    }\x0a    ElementAnimationStyleHandler.prototype.apply = function () {\x0a        applyKeyframeAnimation(this._element, this._duration + \x22ms \x22 + this._easing + \x22 \x22 + this._delay + \x22ms 1 normal \x22 + this._fillMode + \x22 \x22 + this._name);\x0a        addRemoveAnimationEvent(this._element, this._eventFn, false);\x0a        this._startTime = Date.now();\x0a    };\x0a    ElementAnimationStyleHandler.prototype.pause = function () { playPauseAnimation(this._element, this._name, \x27paused\x27); };\x0a    ElementAnimationStyleHandler.prototype.resume = function () { playPauseAnimation(this._element, this._name, \x27running\x27); };\x0a    ElementAnimationStyleHandler.prototype.setPosition = function (position) {\x0a        var index = findIndexForAnimation(this._element, this._name);\x0a        this._position = position * this._duration;\x0a        setAnimationStyle(this._element, \x27Delay\x27, \x22-\x22 + this._position + \x22ms\x22, index);\x0a    };\x0a    ElementAnimationStyleHandler.prototype.getPosition = function () { return this._position; };\x0a    ElementAnimationStyleHandler.prototype._handleCallback = function (event) {\x0a        var timestamp = event._ngTestManualTimestamp || Date.now();\x0a        var elapsedTime = parseFloat(event.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES)) * ONE_SECOND$1;\x0a        if (event.animationName == this._name &&\x0a            Math.max(timestamp - this._startTime, 0) \x3e= this._delay && elapsedTime \x3e= this._duration) {\x0a            this.finish();\x0a        }\x0a    };\x0a    ElementAnimationStyleHandler.prototype.finish = function () {\x0a        if (this._finished)\x0a            return;\x0a        this._finished = true;\x0a        this._onDoneFn();\x0a        addRemoveAnimationEvent(this._element, this._eventFn, true);\x0a    };\x0a    ElementAnimationStyleHandler.prototype.destroy = function () {\x0a        if (this._destroyed)\x0a            return;\x0a        this._destroyed = true;\x0a        this.finish();\x0a        removeKeyframeAnimation(this._element, this._name);\x0a    };\x0a    return ElementAnimationStyleHandler;\x0a}());\x0afunction playPauseAnimation(element, name, status) {\x0a    var index = findIndexForAnimation(element, name);\x0a    setAnimationStyle(element, \x27PlayState\x27, status, index);\x0a}\x0afunction applyKeyframeAnimation(element, value) {\x0a    var anim = getAnimationStyle(element, \x27\x27).trim();\x0a    var index = 0;\x0a    if (anim.length) {\x0a        index = countChars(anim, \x27,\x27) + 1;\x0a        value = anim + \x22, \x22 + value;\x0a    }\x0a    setAnimationStyle(element, \x27\x27, value);\x0a    return index;\x0a}\x0afunction removeKeyframeAnimation(element, name) {\x0a    var anim = getAnimationStyle(element, \x27\x27);\x0a    var tokens = anim.split(\x27,\x27);\x0a    var index = findMatchingTokenIndex(tokens, name);\x0a    if (index \x3e= 0) {\x0a        tokens.splice(index, 1);\x0a        var newValue = tokens.join(\x27,\x27);\x0a        setAnimationStyle(element, \x27\x27, newValue);\x0a    }\x0a}\x0afunction findIndexForAnimation(element, value) {\x0a    var anim = getAnimationStyle(element, \x27\x27);\x0a    if (anim.indexOf(\x27,\x27) \x3e 0) {\x0a        var tokens = anim.split(\x27,\x27);\x0a        return findMatchingTokenIndex(tokens, value);\x0a    }\x0a    return findMatchingTokenIndex([anim], value);\x0a}\x0afunction findMatchingTokenIndex(tokens, searchToken) {\x0a    for (var i = 0; i \x3c tokens.length; i++) {\x0a        if (tokens[i].indexOf(searchToken) \x3e= 0) {\x0a            return i;\x0a        }\x0a    }\x0a    return -1;\x0a}\x0afunction addRemoveAnimationEvent(element, fn, doRemove) {\x0a    doRemove ? element.removeEventListener(ANIMATIONEND_EVENT, fn) :\x0a        element.addEventListener(ANIMATIONEND_EVENT, fn);\x0a}\x0afunction setAnimationStyle(element, name, value, index) {\x0a    var prop = ANIMATION_PROP + name;\x0a    if (index != null) {\x0a        var oldValue = element.style[prop];\x0a        if (oldValue.length) {\x0a            var tokens = oldValue.split(\x27,\x27);\x0a            tokens[index] = value;\x0a            value = tokens.join(\x27,\x27);\x0a        }\x0a    }\x0a    element.style[prop] = value;\x0a}\x0afunction getAnimationStyle(element, name) {\x0a    return element.style[ANIMATION_PROP + name];\x0a}\x0afunction countChars(value, char) {\x0a    var count = 0;\x0a    for (var i = 0; i \x3c value.length; i++) {\x0a        var c = value.charAt(i);\x0a        if (c === char)\x0a            count++;\x0a    }\x0a    return count;\x0a}\x0a\x0avar DEFAULT_FILL_MODE = \x27forwards\x27;\x0avar DEFAULT_EASING = \x27linear\x27;\x0avar CssKeyframesPlayer = /** @class */ (function () {\x0a    function CssKeyframesPlayer(element, keyframes, animationName, _duration, _delay, easing, _finalStyles) {\x0a        this.element = element;\x0a        this.keyframes = keyframes;\x0a        this.animationName = animationName;\x0a        this._duration = _duration;\x0a        this._delay = _delay;\x0a        this._finalStyles = _finalStyles;\x0a        this._onDoneFns = [];\x0a        this._onStartFns = [];\x0a        this._onDestroyFns = [];\x0a        this._started = false;\x0a        this.currentSnapshot = {};\x0a        this._state = 0;\x0a        this.easing = easing || DEFAULT_EASING;\x0a        this.totalTime = _duration + _delay;\x0a        this._buildStyler();\x0a    }\x0a    CssKeyframesPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\x0a    CssKeyframesPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\x0a    CssKeyframesPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };\x0a    CssKeyframesPlayer.prototype.destroy = function () {\x0a        this.init();\x0a        if (this._state \x3e= 4 /* DESTROYED */)\x0a            return;\x0a        this._state = 4 /* DESTROYED */;\x0a        this._styler.destroy();\x0a        this._flushStartFns();\x0a        this._flushDoneFns();\x0a        this._onDestroyFns.forEach(function (fn) { return fn(); });\x0a        this._onDestroyFns = [];\x0a    };\x0a    CssKeyframesPlayer.prototype._flushDoneFns = function () {\x0a        this._onDoneFns.forEach(function (fn) { return fn(); });\x0a        this._onDoneFns = [];\x0a    };\x0a    CssKeyframesPlayer.prototype._flushStartFns = function () {\x0a        this._onStartFns.forEach(function (fn) { return fn(); });\x0a        this._onStartFns = [];\x0a    };\x0a    CssKeyframesPlayer.prototype.finish = function () {\x0a        this.init();\x0a        if (this._state \x3e= 3 /* FINISHED */)\x0a            return;\x0a        this._state = 3 /* FINISHED */;\x0a        this._styler.finish();\x0a        this._flushStartFns();\x0a        this._flushDoneFns();\x0a    };\x0a    CssKeyframesPlayer.prototype.setPosition = function (value) { this._styler.setPosition(value); };\x0a    CssKeyframesPlayer.prototype.getPosition = function () { return this._styler.getPosition(); };\x0a    CssKeyframesPlayer.prototype.hasStarted = function () { return this._state \x3e= 2 /* STARTED */; };\x0a    CssKeyframesPlayer.prototype.init = function () {\x0a        if (this._state \x3e= 1 /* INITIALIZED */)\x0a            return;\x0a        this._state = 1 /* INITIALIZED */;\x0a        var elm = this.element;\x0a        this._styler.apply();\x0a        if (this._delay) {\x0a            this._styler.pause();\x0a        }\x0a    };\x0a    CssKeyframesPlayer.prototype.play = function () {\x0a        this.init();\x0a        if (!this.hasStarted()) {\x0a            this._flushStartFns();\x0a            this._state = 2 /* STARTED */;\x0a        }\x0a        this._styler.resume();\x0a    };\x0a    CssKeyframesPlayer.prototype.pause = function () {\x0a        this.init();\x0a        this._styler.pause();\x0a    };\x0a    CssKeyframesPlayer.prototype.restart = function () {\x0a        this.reset();\x0a        this.play();\x0a    };\x0a    CssKeyframesPlayer.prototype.reset = function () {\x0a        this._styler.destroy();\x0a        this._buildStyler();\x0a        this._styler.apply();\x0a    };\x0a    CssKeyframesPlayer.prototype._buildStyler = function () {\x0a        var _this = this;\x0a        this._styler = new ElementAnimationStyleHandler(this.element, this.animationName, this._duration, this._delay, this.easing, DEFAULT_FILL_MODE, function () { return _this.finish(); });\x0a    };\x0a    /** @internal */\x0a    CssKeyframesPlayer.prototype.triggerCallback = function (phaseName) {\x0a        var methods = phaseName == \x27start\x27 ? this._onStartFns : this._onDoneFns;\x0a        methods.forEach(function (fn) { return fn(); });\x0a        methods.length = 0;\x0a    };\x0a    CssKeyframesPlayer.prototype.beforeDestroy = function () {\x0a        var _this = this;\x0a        this.init();\x0a        var styles = {};\x0a        if (this.hasStarted()) {\x0a            var finished_1 = this._state \x3e= 3 /* FINISHED */;\x0a            Object.keys(this._finalStyles).forEach(function (prop) {\x0a                if (prop != \x27offset\x27) {\x0a                    styles[prop] = finished_1 ? _this._finalStyles[prop] : computeStyle(_this.element, prop);\x0a                }\x0a            });\x0a        }\x0a        this.currentSnapshot = styles;\x0a    };\x0a    return CssKeyframesPlayer;\x0a}());\x0a\x0avar DirectStylePlayer = /** @class */ (function (_super) {\x0a    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__extends\x22])(DirectStylePlayer, _super);\x0a    function DirectStylePlayer(element, styles) {\x0a        var _this = _super.call(this) || this;\x0a        _this.element = element;\x0a        _this._startingStyles = {};\x0a        _this.__initialized = false;\x0a        _this._styles = hypenatePropsObject(styles);\x0a        return _this;\x0a    }\x0a    DirectStylePlayer.prototype.init = function () {\x0a        var _this = this;\x0a        if (this.__initialized || !this._startingStyles)\x0a            return;\x0a        this.__initialized = true;\x0a        Object.keys(this._styles).forEach(function (prop) {\x0a            _this._startingStyles[prop] = _this.element.style[prop];\x0a        });\x0a        _super.prototype.init.call(this);\x0a    };\x0a    DirectStylePlayer.prototype.play = function () {\x0a        var _this = this;\x0a        if (!this._startingStyles)\x0a            return;\x0a        this.init();\x0a        Object.keys(this._styles)\x0a            .forEach(function (prop) { return _this.element.style.setProperty(prop, _this._styles[prop]); });\x0a        _super.prototype.play.call(this);\x0a    };\x0a    DirectStylePlayer.prototype.destroy = function () {\x0a        var _this = this;\x0a        if (!this._startingStyles)\x0a            return;\x0a        Object.keys(this._startingStyles).forEach(function (prop) {\x0a            var value = _this._startingStyles[prop];\x0a            if (value) {\x0a                _this.element.style.setProperty(prop, value);\x0a            }\x0a            else {\x0a                _this.element.style.removeProperty(prop);\x0a            }\x0a        });\x0a        this._startingStyles = null;\x0a        _super.prototype.destroy.call(this);\x0a    };\x0a    return DirectStylePlayer;\x0a}(_angular_animations__WEBPACK_IMPORTED_MODULE_1__[\x22NoopAnimationPlayer\x22]));\x0a\x0avar KEYFRAMES_NAME_PREFIX = \x27gen_css_kf_\x27;\x0avar TAB_SPACE = \x27 \x27;\x0avar CssKeyframesDriver = /** @class */ (function () {\x0a    function CssKeyframesDriver() {\x0a        this._count = 0;\x0a        this._head = document.querySelector(\x27head\x27);\x0a        this._warningIssued = false;\x0a    }\x0a    CssKeyframesDriver.prototype.validateStyleProperty = function (prop) { return validateStyleProperty(prop); };\x0a    CssKeyframesDriver.prototype.matchesElement = function (element, selector) {\x0a        return matchesElement(element, selector);\x0a    };\x0a    CssKeyframesDriver.prototype.containsElement = function (elm1, elm2) { return containsElement(elm1, elm2); };\x0a    CssKeyframesDriver.prototype.query = function (element, selector, multi) {\x0a        return invokeQuery(element, selector, multi);\x0a    };\x0a    CssKeyframesDriver.prototype.computeStyle = function (element, prop, defaultValue) {\x0a        return window.getComputedStyle(element)[prop];\x0a    };\x0a    CssKeyframesDriver.prototype.buildKeyframeElement = function (element, name, keyframes) {\x0a        keyframes = keyframes.map(function (kf) { return hypenatePropsObject(kf); });\x0a        var keyframeStr = \x22@keyframes \x22 + name + \x22 {\x5cn\x22;\x0a        var tab = \x27\x27;\x0a        keyframes.forEach(function (kf) {\x0a            tab = TAB_SPACE;\x0a            var offset = parseFloat(kf.offset);\x0a            keyframeStr += \x22\x22 + tab + offset * 100 + \x22% {\x5cn\x22;\x0a            tab += TAB_SPACE;\x0a            Object.keys(kf).forEach(function (prop) {\x0a                var value = kf[prop];\x0a                switch (prop) {\x0a                    case \x27offset\x27:\x0a                        return;\x0a                    case \x27easing\x27:\x0a                        if (value) {\x0a                            keyframeStr += tab + \x22animation-timing-function: \x22 + value + \x22;\x5cn\x22;\x0a                        }\x0a                        return;\x0a                    default:\x0a                        keyframeStr += \x22\x22 + tab + prop + \x22: \x22 + value + \x22;\x5cn\x22;\x0a                        return;\x0a                }\x0a            });\x0a            keyframeStr += tab + \x22}\x5cn\x22;\x0a        });\x0a        keyframeStr += \x22}\x5cn\x22;\x0a        var kfElm = document.createElement(\x27style\x27);\x0a        kfElm.innerHTML = keyframeStr;\x0a        return kfElm;\x0a    };\x0a    CssKeyframesDriver.prototype.animate = function (element, keyframes, duration, delay, easing, previousPlayers, scrubberAccessRequested) {\x0a        if (previousPlayers === void 0) { previousPlayers = []; }\x0a        if (scrubberAccessRequested) {\x0a            this._notifyFaultyScrubber();\x0a        }\x0a        var previousCssKeyframePlayers = previousPlayers.filter(function (player) { return player instanceof CssKeyframesPlayer; });\x0a        var previousStyles = {};\x0a        if (allowPreviousPlayerStylesMerge(duration, delay)) {\x0a            previousCssKeyframePlayers.forEach(function (player) {\x0a                var styles = player.currentSnapshot;\x0a                Object.keys(styles).forEach(function (prop) { return previousStyles[prop] = styles[prop]; });\x0a            });\x0a        }\x0a        keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles);\x0a        var finalStyles = flattenKeyframesIntoStyles(keyframes);\x0a        // if there is no animation then there is no point in applying\x0a        // styles and waiting for an event to get fired. This causes lag.\x0a        // It\x27s better to just directly apply the styles to the element\x0a        // via the direct styling animation player.\x0a        if (duration == 0) {\x0a            return new DirectStylePlayer(element, finalStyles);\x0a        }\x0a        var animationName = \x22\x22 + KEYFRAMES_NAME_PREFIX + this._count++;\x0a        var kfElm = this.buildKeyframeElement(element, animationName, keyframes);\x0a        document.querySelector(\x27head\x27).appendChild(kfElm);\x0a        var player = new CssKeyframesPlayer(element, keyframes, animationName, duration, delay, easing, finalStyles);\x0a        player.onDestroy(function () { return removeElement(kfElm); });\x0a        return player;\x0a    };\x0a    CssKeyframesDriver.prototype._notifyFaultyScrubber = function () {\x0a        if (!this._warningIssued) {\x0a            console.warn(\x27@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\x5cn\x27, \x27  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill.\x27);\x0a            this._warningIssued = true;\x0a        }\x0a    };\x0a    return CssKeyframesDriver;\x0a}());\x0afunction flattenKeyframesIntoStyles(keyframes) {\x0a    var flatKeyframes = {};\x0a    if (keyframes) {\x0a        var kfs = Array.isArray(keyframes) ? keyframes : [keyframes];\x0a        kfs.forEach(function (kf) {\x0a            Object.keys(kf).forEach(function (prop) {\x0a                if (prop == \x27offset\x27 || prop == \x27easing\x27)\x0a                    return;\x0a                flatKeyframes[prop] = kf[prop];\x0a            });\x0a        });\x0a    }\x0a    return flatKeyframes;\x0a}\x0afunction removeElement(node) {\x0a    node.parentNode.removeChild(node);\x0a}\x0a\x0avar WebAnimationsPlayer = /** @class */ (function () {\x0a    function WebAnimationsPlayer(element, keyframes, options) {\x0a        this.element = element;\x0a        this.keyframes = keyframes;\x0a        this.options = options;\x0a        this._onDoneFns = [];\x0a        this._onStartFns = [];\x0a        this._onDestroyFns = [];\x0a        this._initialized = false;\x0a        this._finished = false;\x0a        this._started = false;\x0a        this._destroyed = false;\x0a        this.time = 0;\x0a        this.parentPlayer = null;\x0a        this.currentSnapshot = {};\x0a        this._duration = options[\x27duration\x27];\x0a        this._delay = options[\x27delay\x27] || 0;\x0a        this.time = this._duration + this._delay;\x0a    }\x0a    WebAnimationsPlayer.prototype._onFinish = function () {\x0a        if (!this._finished) {\x0a            this._finished = true;\x0a            this._onDoneFns.forEach(function (fn) { return fn(); });\x0a            this._onDoneFns = [];\x0a        }\x0a    };\x0a    WebAnimationsPlayer.prototype.init = function () {\x0a        this._buildPlayer();\x0a        this._preparePlayerBeforeStart();\x0a    };\x0a    WebAnimationsPlayer.prototype._buildPlayer = function () {\x0a        var _this = this;\x0a        if (this._initialized)\x0a            return;\x0a        this._initialized = true;\x0a        var keyframes = this.keyframes;\x0a        this.domPlayer =\x0a            this._triggerWebAnimation(this.element, keyframes, this.options);\x0a        this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};\x0a        this.domPlayer.addEventListener(\x27finish\x27, function () { return _this._onFinish(); });\x0a    };\x0a    WebAnimationsPlayer.prototype._preparePlayerBeforeStart = function () {\x0a        // this is required so that the player doesn\x27t start to animate right away\x0a        if (this._delay) {\x0a            this._resetDomPlayerState();\x0a        }\x0a        else {\x0a            this.domPlayer.pause();\x0a        }\x0a    };\x0a    /** @internal */\x0a    WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {\x0a        // jscompiler doesn\x27t seem to know animate is a native property because it\x27s not fully\x0a        // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]\x0a        return element[\x27animate\x27](keyframes, options);\x0a    };\x0a    WebAnimationsPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\x0a    WebAnimationsPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\x0a    WebAnimationsPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };\x0a    WebAnimationsPlayer.prototype.play = function () {\x0a        this._buildPlayer();\x0a        if (!this.hasStarted()) {\x0a            this._onStartFns.forEach(function (fn) { return fn(); });\x0a            this._onStartFns = [];\x0a            this._started = true;\x0a        }\x0a        this.domPlayer.play();\x0a    };\x0a    WebAnimationsPlayer.prototype.pause = function () {\x0a        this.init();\x0a        this.domPlayer.pause();\x0a    };\x0a    WebAnimationsPlayer.prototype.finish = function () {\x0a        this.init();\x0a        this._onFinish();\x0a        this.domPlayer.finish();\x0a    };\x0a    WebAnimationsPlayer.prototype.reset = function () {\x0a        this._resetDomPlayerState();\x0a        this._destroyed = false;\x0a        this._finished = false;\x0a        this._started = false;\x0a    };\x0a    WebAnimationsPlayer.prototype._resetDomPlayerState = function () {\x0a        if (this.domPlayer) {\x0a            this.domPlayer.cancel();\x0a        }\x0a    };\x0a    WebAnimationsPlayer.prototype.restart = function () {\x0a        this.reset();\x0a        this.play();\x0a    };\x0a    WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };\x0a    WebAnimationsPlayer.prototype.destroy = function () {\x0a        if (!this._destroyed) {\x0a            this._destroyed = true;\x0a            this._resetDomPlayerState();\x0a            this._onFinish();\x0a            this._onDestroyFns.forEach(function (fn) { return fn(); });\x0a            this._onDestroyFns = [];\x0a        }\x0a    };\x0a    WebAnimationsPlayer.prototype.setPosition = function (p) { this.domPlayer.currentTime = p * this.time; };\x0a    WebAnimationsPlayer.prototype.getPosition = function () { return this.domPlayer.currentTime / this.time; };\x0a    Object.defineProperty(WebAnimationsPlayer.prototype, \x22totalTime\x22, {\x0a        get: function () { return this._delay + this._duration; },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    WebAnimationsPlayer.prototype.beforeDestroy = function () {\x0a        var _this = this;\x0a        var styles = {};\x0a        if (this.hasStarted()) {\x0a            Object.keys(this._finalKeyframe).forEach(function (prop) {\x0a                if (prop != \x27offset\x27) {\x0a                    styles[prop] =\x0a                        _this._finished ? _this._finalKeyframe[prop] : computeStyle(_this.element, prop);\x0a                }\x0a            });\x0a        }\x0a        this.currentSnapshot = styles;\x0a    };\x0a    /** @internal */\x0a    WebAnimationsPlayer.prototype.triggerCallback = function (phaseName) {\x0a        var methods = phaseName == \x27start\x27 ? this._onStartFns : this._onDoneFns;\x0a        methods.forEach(function (fn) { return fn(); });\x0a        methods.length = 0;\x0a    };\x0a    return WebAnimationsPlayer;\x0a}());\x0a\x0avar WebAnimationsDriver = /** @class */ (function () {\x0a    function WebAnimationsDriver() {\x0a        this._isNativeImpl = /\x5c{\x5cs*\x5c[native\x5cs+code\x5c]\x5cs*\x5c}/.test(getElementAnimateFn().toString());\x0a        this._cssKeyframesDriver = new CssKeyframesDriver();\x0a    }\x0a    WebAnimationsDriver.prototype.validateStyleProperty = function (prop) { return validateStyleProperty(prop); };\x0a    WebAnimationsDriver.prototype.matchesElement = function (element, selector) {\x0a        return matchesElement(element, selector);\x0a    };\x0a    WebAnimationsDriver.prototype.containsElement = function (elm1, elm2) { return containsElement(elm1, elm2); };\x0a    WebAnimationsDriver.prototype.query = function (element, selector, multi) {\x0a        return invokeQuery(element, selector, multi);\x0a    };\x0a    WebAnimationsDriver.prototype.computeStyle = function (element, prop, defaultValue) {\x0a        return window.getComputedStyle(element)[prop];\x0a    };\x0a    WebAnimationsDriver.prototype.overrideWebAnimationsSupport = function (supported) { this._isNativeImpl = supported; };\x0a    WebAnimationsDriver.prototype.animate = function (element, keyframes, duration, delay, easing, previousPlayers, scrubberAccessRequested) {\x0a        if (previousPlayers === void 0) { previousPlayers = []; }\x0a        var useKeyframes = !scrubberAccessRequested && !this._isNativeImpl;\x0a        if (useKeyframes) {\x0a            return this._cssKeyframesDriver.animate(element, keyframes, duration, delay, easing, previousPlayers);\x0a        }\x0a        var fill = delay == 0 ? \x27both\x27 : \x27forwards\x27;\x0a        var playerOptions = { duration: duration, delay: delay, fill: fill };\x0a        // we check for this to avoid having a null|undefined value be present\x0a        // for the easing (which results in an error for certain browsers #9752)\x0a        if (easing) {\x0a            playerOptions[\x27easing\x27] = easing;\x0a        }\x0a        var previousStyles = {};\x0a        var previousWebAnimationPlayers = previousPlayers.filter(function (player) { return player instanceof WebAnimationsPlayer; });\x0a        if (allowPreviousPlayerStylesMerge(duration, delay)) {\x0a            previousWebAnimationPlayers.forEach(function (player) {\x0a                var styles = player.currentSnapshot;\x0a                Object.keys(styles).forEach(function (prop) { return previousStyles[prop] = styles[prop]; });\x0a            });\x0a        }\x0a        keyframes = keyframes.map(function (styles) { return copyStyles(styles, false); });\x0a        keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles);\x0a        return new WebAnimationsPlayer(element, keyframes, playerOptions);\x0a    };\x0a    return WebAnimationsDriver;\x0a}());\x0afunction supportsWebAnimations() {\x0a    return typeof getElementAnimateFn() === \x27function\x27;\x0a}\x0afunction getElementAnimateFn() {\x0a    return (isBrowser() && Element.prototype[\x27animate\x27]) || {};\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a/**\x0a * Generated bundle index. Do not edit.\x0a */\x0a\x0a\x0a//# sourceMappingURL=browser.js.map\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/@angular/cdk/esm5/a11y.es5.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/@angular/cdk/esm5/a11y.es5.js ***!\x0a  \x5c****************************************************/\x0a/*! exports provided: ARIA_DESCRIBER_PROVIDER_FACTORY, MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER, ActiveDescendantKeyManager, FocusKeyManager, ListKeyManager, FocusTrap, FocusTrapFactory, CdkTrapFocus, InteractivityChecker, LIVE_ANNOUNCER_PROVIDER_FACTORY, LiveAnnouncer, CdkAriaLive, LIVE_ANNOUNCER_PROVIDER, LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY, LIVE_ANNOUNCER_ELEMENT_TOKEN, FOCUS_MONITOR_PROVIDER_FACTORY, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER, isFakeMousedownFromScreenReader, A11yModule */\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22ARIA_DESCRIBER_PROVIDER_FACTORY\x22, function() { return ARIA_DESCRIBER_PROVIDER_FACTORY; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22MESSAGES_CONTAINER_ID\x22, function() { return MESSAGES_CONTAINER_ID; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22CDK_DESCRIBEDBY_ID_PREFIX\x22, function() { return CDK_DESCRIBEDBY_ID_PREFIX; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22CDK_DESCRIBEDBY_HOST_ATTRIBUTE\x22, function() { return CDK_DESCRIBEDBY_HOST_ATTRIBUTE; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22AriaDescriber\x22, function() { return AriaDescriber; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22ARIA_DESCRIBER_PROVIDER\x22, function() { return ARIA_DESCRIBER_PROVIDER; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22ActiveDescendantKeyManager\x22, function() { return ActiveDescendantKeyManager; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22FocusKeyManager\x22, function() { return FocusKeyManager; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22ListKeyManager\x22, function() { return ListKeyManager; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22FocusTrap\x22, function() { return FocusTrap; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22FocusTrapFactory\x22, function() { return FocusTrapFactory; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22CdkTrapFocus\x22, function() { return CdkTrapFocus; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22InteractivityChecker\x22, function() { return InteractivityChecker; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22LIVE_ANNOUNCER_PROVIDER_FACTORY\x22, function() { return LIVE_ANNOUNCER_PROVIDER_FACTORY; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22LiveAnnouncer\x22, function() { return LiveAnnouncer; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22CdkAriaLive\x22, function() { return CdkAriaLive; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22LIVE_ANNOUNCER_PROVIDER\x22, function() { return LIVE_ANNOUNCER_PROVIDER; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY\x22, function() { return LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22LIVE_ANNOUNCER_ELEMENT_TOKEN\x22, function() { return LIVE_ANNOUNCER_ELEMENT_TOKEN; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22FOCUS_MONITOR_PROVIDER_FACTORY\x22, function() { return FOCUS_MONITOR_PROVIDER_FACTORY; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22TOUCH_BUFFER_MS\x22, function() { return TOUCH_BUFFER_MS; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22FocusMonitor\x22, function() { return FocusMonitor; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22CdkMonitorFocus\x22, function() { return CdkMonitorFocus; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22FOCUS_MONITOR_PROVIDER\x22, function() { return FOCUS_MONITOR_PROVIDER; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22isFakeMousedownFromScreenReader\x22, function() { return isFakeMousedownFromScreenReader; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22A11yModule\x22, function() { return A11yModule; });\x0a/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/common */ \x22./node_modules/@angular/common/fesm5/common.js\x22);\x0a/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \x22./node_modules/@angular/core/fesm5/core.js\x22);\x0a/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \x22./node_modules/rxjs/_esm5/index.js\x22);\x0a/* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/keycodes */ \x22./node_modules/@angular/cdk/esm5/keycodes.es5.js\x22);\x0a/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \x22./node_modules/rxjs/_esm5/operators/index.js\x22);\x0a/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ \x22./node_modules/tslib/tslib.es6.js\x22);\x0a/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/platform */ \x22./node_modules/@angular/cdk/esm5/platform.es5.js\x22);\x0a/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/coercion */ \x22./node_modules/@angular/cdk/esm5/coercion.es5.js\x22);\x0a/* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/observers */ \x22./node_modules/@angular/cdk/esm5/observers.es5.js\x22);\x0a/**\x0a * @license\x0a * Copyright Google LLC All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/** *\x0a * IDs are deliminated by an empty space, as per the spec.\x0a  @type {?} */\x0avar ID_DELIMINATOR = \x27 \x27;\x0a/**\x0a * Adds the given ID to the specified ARIA attribute on an element.\x0a * Used for attributes such as aria-labelledby, aria-owns, etc.\x0a * @param {?} el\x0a * @param {?} attr\x0a * @param {?} id\x0a * @return {?}\x0a */\x0afunction addAriaReferencedId(el, attr, id) {\x0a    /** @type {?} */\x0a    var ids = getAriaReferenceIds(el, attr);\x0a    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\x0a        return;\x0a    }\x0a    ids.push(id.trim());\x0a    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\x0a}\x0a/**\x0a * Removes the given ID from the specified ARIA attribute on an element.\x0a * Used for attributes such as aria-labelledby, aria-owns, etc.\x0a * @param {?} el\x0a * @param {?} attr\x0a * @param {?} id\x0a * @return {?}\x0a */\x0afunction removeAriaReferencedId(el, attr, id) {\x0a    /** @type {?} */\x0a    var ids = getAriaReferenceIds(el, attr);\x0a    /** @type {?} */\x0a    var filteredIds = ids.filter(function (val) { return val != id.trim(); });\x0a    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\x0a}\x0a/**\x0a * Gets the list of IDs referenced by the given ARIA attribute on an element.\x0a * Used for attributes such as aria-labelledby, aria-owns, etc.\x0a * @param {?} el\x0a * @param {?} attr\x0a * @return {?}\x0a */\x0afunction getAriaReferenceIds(el, attr) {\x0a    // Get string array of all individual ids (whitespace deliminated) in the attribute value\x0a    return (el.getAttribute(attr) || \x27\x27).match(/\x5cS+/g) || [];\x0a}\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/** *\x0a * ID used for the body container where all messages are appended.\x0a  @type {?} */\x0avar MESSAGES_CONTAINER_ID = \x27cdk-describedby-message-container\x27;\x0a/** *\x0a * ID prefix used for each created message element.\x0a  @type {?} */\x0avar CDK_DESCRIBEDBY_ID_PREFIX = \x27cdk-describedby-message\x27;\x0a/** *\x0a * Attribute given to each host element that is described by a message element.\x0a  @type {?} */\x0avar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = \x27cdk-describedby-host\x27;\x0a/** *\x0a * Global incremental identifier for each registered message element.\x0a  @type {?} */\x0avar nextId = 0;\x0a/** *\x0a * Global map of all registered message elements that have been placed into the document.\x0a  @type {?} */\x0avar messageRegistry = new Map();\x0a/** *\x0a * Container for all registered messages.\x0a  @type {?} */\x0avar messagesContainer = null;\x0a/**\x0a * Utility that creates visually hidden elements with a message content. Useful for elements that\x0a * want to use aria-describedby to further describe themselves without adding additional visual\x0a * content.\x0a * \x5c@docs-private\x0a */\x0avar AriaDescriber = /** @class */ (function () {\x0a    function AriaDescriber(_document) {\x0a        this._document = _document;\x0a    }\x0a    /**\x0a     * Adds to the host element an aria-describedby reference to a hidden element that contains\x0a     * the message. If the same message has already been registered, then it will reuse the created\x0a     * message element.\x0a     */\x0a    /**\x0a     * Adds to the host element an aria-describedby reference to a hidden element that contains\x0a     * the message. If the same message has already been registered, then it will reuse the created\x0a     * message element.\x0a     * @param {?} hostElement\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype.describe = /**\x0a     * Adds to the host element an aria-describedby reference to a hidden element that contains\x0a     * the message. If the same message has already been registered, then it will reuse the created\x0a     * message element.\x0a     * @param {?} hostElement\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    function (hostElement, message) {\x0a        if (!this._canBeDescribed(hostElement, message)) {\x0a            return;\x0a        }\x0a        if (!messageRegistry.has(message)) {\x0a            this._createMessageElement(message);\x0a        }\x0a        if (!this._isElementDescribedByMessage(hostElement, message)) {\x0a            this._addMessageReference(hostElement, message);\x0a        }\x0a    };\x0a    /** Removes the host element\x27s aria-describedby reference to the message element. */\x0a    /**\x0a     * Removes the host element\x27s aria-describedby reference to the message element.\x0a     * @param {?} hostElement\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype.removeDescription = /**\x0a     * Removes the host element\x27s aria-describedby reference to the message element.\x0a     * @param {?} hostElement\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    function (hostElement, message) {\x0a        if (!this._canBeDescribed(hostElement, message)) {\x0a            return;\x0a        }\x0a        if (this._isElementDescribedByMessage(hostElement, message)) {\x0a            this._removeMessageReference(hostElement, message);\x0a        }\x0a        /** @type {?} */\x0a        var registeredMessage = messageRegistry.get(message);\x0a        if (registeredMessage && registeredMessage.referenceCount === 0) {\x0a            this._deleteMessageElement(message);\x0a        }\x0a        if (messagesContainer && messagesContainer.childNodes.length === 0) {\x0a            this._deleteMessagesContainer();\x0a        }\x0a    };\x0a    /** Unregisters all created message elements and removes the message container. */\x0a    /**\x0a     * Unregisters all created message elements and removes the message container.\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype.ngOnDestroy = /**\x0a     * Unregisters all created message elements and removes the message container.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        /** @type {?} */\x0a        var describedElements = this._document.querySelectorAll(\x22[\x22 + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \x22]\x22);\x0a        for (var i = 0; i \x3c describedElements.length; i++) {\x0a            this._removeCdkDescribedByReferenceIds(describedElements[i]);\x0a            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\x0a        }\x0a        if (messagesContainer) {\x0a            this._deleteMessagesContainer();\x0a        }\x0a        messageRegistry.clear();\x0a    };\x0a    /**\x0a     * Creates a new element in the visually hidden message container element with the message\x0a     * as its content and adds it to the message registry.\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype._createMessageElement = /**\x0a     * Creates a new element in the visually hidden message container element with the message\x0a     * as its content and adds it to the message registry.\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    function (message) {\x0a        /** @type {?} */\x0a        var messageElement = this._document.createElement(\x27div\x27);\x0a        messageElement.setAttribute(\x27id\x27, CDK_DESCRIBEDBY_ID_PREFIX + \x22-\x22 + nextId++);\x0a        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\x0a        this._createMessagesContainer(); /** @type {?} */\x0a        ((messagesContainer)).appendChild(messageElement);\x0a        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\x0a    };\x0a    /**\x0a     * Deletes the message element from the global messages container.\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype._deleteMessageElement = /**\x0a     * Deletes the message element from the global messages container.\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    function (message) {\x0a        /** @type {?} */\x0a        var registeredMessage = messageRegistry.get(message);\x0a        /** @type {?} */\x0a        var messageElement = registeredMessage && registeredMessage.messageElement;\x0a        if (messagesContainer && messageElement) {\x0a            messagesContainer.removeChild(messageElement);\x0a        }\x0a        messageRegistry.delete(message);\x0a    };\x0a    /**\x0a     * Creates the global container for all aria-describedby messages.\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype._createMessagesContainer = /**\x0a     * Creates the global container for all aria-describedby messages.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        if (!messagesContainer) {\x0a            /** @type {?} */\x0a            var preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\x0a            // When going from the server to the client, we may end up in a situation where there\x27s\x0a            // already a container on the page, but we don\x27t have a reference to it. Clear the\x0a            // old container so we don\x27t get duplicates. Doing this, instead of emptying the previous\x0a            // container, should be slightly faster.\x0a            if (preExistingContainer) {\x0a                /** @type {?} */ ((preExistingContainer.parentNode)).removeChild(preExistingContainer);\x0a            }\x0a            messagesContainer = this._document.createElement(\x27div\x27);\x0a            messagesContainer.id = MESSAGES_CONTAINER_ID;\x0a            messagesContainer.setAttribute(\x27aria-hidden\x27, \x27true\x27);\x0a            messagesContainer.style.display = \x27none\x27;\x0a            this._document.body.appendChild(messagesContainer);\x0a        }\x0a    };\x0a    /**\x0a     * Deletes the global messages container.\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype._deleteMessagesContainer = /**\x0a     * Deletes the global messages container.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        if (messagesContainer && messagesContainer.parentNode) {\x0a            messagesContainer.parentNode.removeChild(messagesContainer);\x0a            messagesContainer = null;\x0a        }\x0a    };\x0a    /**\x0a     * Removes all cdk-describedby messages that are hosted through the element.\x0a     * @param {?} element\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\x0a     * Removes all cdk-describedby messages that are hosted through the element.\x0a     * @param {?} element\x0a     * @return {?}\x0a     */\x0a    function (element) {\x0a        /** @type {?} */\x0a        var originalReferenceIds = getAriaReferenceIds(element, \x27aria-describedby\x27)\x0a            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\x0a        element.setAttribute(\x27aria-describedby\x27, originalReferenceIds.join(\x27 \x27));\x0a    };\x0a    /**\x0a     * Adds a message reference to the element using aria-describedby and increments the registered\x0a     * message\x27s reference count.\x0a     * @param {?} element\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype._addMessageReference = /**\x0a     * Adds a message reference to the element using aria-describedby and increments the registered\x0a     * message\x27s reference count.\x0a     * @param {?} element\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    function (element, message) {\x0a        /** @type {?} */\x0a        var registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\x0a        // Add the aria-describedby reference and set the\x0a        // describedby_host attribute to mark the element.\x0a        addAriaReferencedId(element, \x27aria-describedby\x27, registeredMessage.messageElement.id);\x0a        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, \x27\x27);\x0a        registeredMessage.referenceCount++;\x0a    };\x0a    /**\x0a     * Removes a message reference from the element using aria-describedby\x0a     * and decrements the registered message\x27s reference count.\x0a     * @param {?} element\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype._removeMessageReference = /**\x0a     * Removes a message reference from the element using aria-describedby\x0a     * and decrements the registered message\x27s reference count.\x0a     * @param {?} element\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    function (element, message) {\x0a        /** @type {?} */\x0a        var registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\x0a        registeredMessage.referenceCount--;\x0a        removeAriaReferencedId(element, \x27aria-describedby\x27, registeredMessage.messageElement.id);\x0a        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\x0a    };\x0a    /**\x0a     * Returns true if the element has been described by the provided message ID.\x0a     * @param {?} element\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype._isElementDescribedByMessage = /**\x0a     * Returns true if the element has been described by the provided message ID.\x0a     * @param {?} element\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    function (element, message) {\x0a        /** @type {?} */\x0a        var referenceIds = getAriaReferenceIds(element, \x27aria-describedby\x27);\x0a        /** @type {?} */\x0a        var registeredMessage = messageRegistry.get(message);\x0a        /** @type {?} */\x0a        var messageId = registeredMessage && registeredMessage.messageElement.id;\x0a        return !!messageId && referenceIds.indexOf(messageId) != -1;\x0a    };\x0a    /**\x0a     * Determines whether a message can be described on a particular element.\x0a     * @param {?} element\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    AriaDescriber.prototype._canBeDescribed = /**\x0a     * Determines whether a message can be described on a particular element.\x0a     * @param {?} element\x0a     * @param {?} message\x0a     * @return {?}\x0a     */\x0a    function (element, message) {\x0a        return element.nodeType === this._document.ELEMENT_NODE && message != null &&\x0a            !!(\x22\x22 + message).trim();\x0a    };\x0a    AriaDescriber.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Injectable\x22], args: [{ providedIn: \x27root\x27 },] },\x0a    ];\x0a    /** @nocollapse */\x0a    AriaDescriber.ctorParameters = function () { return [\x0a        { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Inject\x22], args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22DOCUMENT\x22],] }] }\x0a    ]; };\x0a    /** @nocollapse */ AriaDescriber.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22defineInjectable\x22])({ factory: function AriaDescriber_Factory() { return new AriaDescriber(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(_angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22DOCUMENT\x22])); }, token: AriaDescriber, providedIn: \x22root\x22 });\x0a    return AriaDescriber;\x0a}());\x0a/**\x0a * \x5c@docs-private \x5c@deprecated \x5c@breaking-change 8.0.0\x0a * @param {?} parentDispatcher\x0a * @param {?} _document\x0a * @return {?}\x0a */\x0afunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\x0a    return parentDispatcher || new AriaDescriber(_document);\x0a}\x0a/** *\x0a * \x5c@docs-private \x5c@deprecated \x5c@breaking-change 8.0.0\x0a  @type {?} */\x0avar ARIA_DESCRIBER_PROVIDER = {\x0a    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\x0a    provide: AriaDescriber,\x0a    deps: [\x0a        [new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Optional\x22](), new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22SkipSelf\x22](), AriaDescriber],\x0a        /** @type {?} */ (_angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22DOCUMENT\x22])\x0a    ],\x0a    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\x0a};\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a// unsupported: template constraints.\x0a/**\x0a * This class manages keyboard events for selectable lists. If you pass it a query list\x0a * of items, it will set the active item correctly when arrow events occur.\x0a * @template T\x0a */\x0avar  \x0a// unsupported: template constraints.\x0a/**\x0a * This class manages keyboard events for selectable lists. If you pass it a query list\x0a * of items, it will set the active item correctly when arrow events occur.\x0a * @template T\x0a */\x0aListKeyManager = /** @class */ (function () {\x0a    function ListKeyManager(_items) {\x0a        var _this = this;\x0a        this._items = _items;\x0a        this._activeItemIndex = -1;\x0a        this._wrap = false;\x0a        this._letterKeyStream = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\x22Subject\x22]();\x0a        this._typeaheadSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__[\x22Subscription\x22].EMPTY;\x0a        this._vertical = true;\x0a        /**\x0a         * Predicate function that can be used to check whether an item should be skipped\x0a         * by the key manager. By default, disabled items are skipped.\x0a         */\x0a        this._skipPredicateFn = function (item) { return item.disabled; };\x0a        this._pressedLetters = [];\x0a        /**\x0a         * Stream that emits any time the TAB key is pressed, so components can react\x0a         * when focus is shifted off of the list.\x0a         */\x0a        this.tabOut = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\x22Subject\x22]();\x0a        /**\x0a         * Stream that emits whenever the active item of the list manager changes.\x0a         */\x0a        this.change = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\x22Subject\x22]();\x0a        // We allow for the items to be an array because, in some cases, the consumer may\x0a        // not have access to a QueryList of the items they want to manage (e.g. when the\x0a        // items aren\x27t being collected via `ViewChildren` or `ContentChildren`).\x0a        if (_items instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22QueryList\x22]) {\x0a            _items.changes.subscribe(function (newItems) {\x0a                if (_this._activeItem) {\x0a                    /** @type {?} */\x0a                    var itemArray = newItems.toArray();\x0a                    /** @type {?} */\x0a                    var newIndex = itemArray.indexOf(_this._activeItem);\x0a                    if (newIndex \x3e -1 && newIndex !== _this._activeItemIndex) {\x0a                        _this._activeItemIndex = newIndex;\x0a                    }\x0a                }\x0a            });\x0a        }\x0a    }\x0a    /**\x0a     * Sets the predicate function that determines which items should be skipped by the\x0a     * list key manager.\x0a     * @param predicate Function that determines whether the given item should be skipped.\x0a     */\x0a    /**\x0a     * Sets the predicate function that determines which items should be skipped by the\x0a     * list key manager.\x0a     * @param {?} predicate Function that determines whether the given item should be skipped.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.skipPredicate = /**\x0a     * Sets the predicate function that determines which items should be skipped by the\x0a     * list key manager.\x0a     * @param {?} predicate Function that determines whether the given item should be skipped.\x0a     * @return {?}\x0a     */\x0a    function (predicate) {\x0a        this._skipPredicateFn = predicate;\x0a        return this;\x0a    };\x0a    /**\x0a     * Configures wrapping mode, which determines whether the active item will wrap to\x0a     * the other end of list when there are no more items in the given direction.\x0a     * @param shouldWrap Whether the list should wrap when reaching the end.\x0a     */\x0a    /**\x0a     * Configures wrapping mode, which determines whether the active item will wrap to\x0a     * the other end of list when there are no more items in the given direction.\x0a     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.withWrap = /**\x0a     * Configures wrapping mode, which determines whether the active item will wrap to\x0a     * the other end of list when there are no more items in the given direction.\x0a     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.\x0a     * @return {?}\x0a     */\x0a    function (shouldWrap) {\x0a        if (shouldWrap === void 0) { shouldWrap = true; }\x0a        this._wrap = shouldWrap;\x0a        return this;\x0a    };\x0a    /**\x0a     * Configures whether the key manager should be able to move the selection vertically.\x0a     * @param enabled Whether vertical selection should be enabled.\x0a     */\x0a    /**\x0a     * Configures whether the key manager should be able to move the selection vertically.\x0a     * @param {?=} enabled Whether vertical selection should be enabled.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.withVerticalOrientation = /**\x0a     * Configures whether the key manager should be able to move the selection vertically.\x0a     * @param {?=} enabled Whether vertical selection should be enabled.\x0a     * @return {?}\x0a     */\x0a    function (enabled) {\x0a        if (enabled === void 0) { enabled = true; }\x0a        this._vertical = enabled;\x0a        return this;\x0a    };\x0a    /**\x0a     * Configures the key manager to move the selection horizontally.\x0a     * Passing in `null` will disable horizontal movement.\x0a     * @param direction Direction in which the selection can be moved.\x0a     */\x0a    /**\x0a     * Configures the key manager to move the selection horizontally.\x0a     * Passing in `null` will disable horizontal movement.\x0a     * @param {?} direction Direction in which the selection can be moved.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.withHorizontalOrientation = /**\x0a     * Configures the key manager to move the selection horizontally.\x0a     * Passing in `null` will disable horizontal movement.\x0a     * @param {?} direction Direction in which the selection can be moved.\x0a     * @return {?}\x0a     */\x0a    function (direction) {\x0a        this._horizontal = direction;\x0a        return this;\x0a    };\x0a    /**\x0a     * Turns on typeahead mode which allows users to set the active item by typing.\x0a     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\x0a     */\x0a    /**\x0a     * Turns on typeahead mode which allows users to set the active item by typing.\x0a     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.withTypeAhead = /**\x0a     * Turns on typeahead mode which allows users to set the active item by typing.\x0a     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\x0a     * @return {?}\x0a     */\x0a    function (debounceInterval) {\x0a        var _this = this;\x0a        if (debounceInterval === void 0) { debounceInterval = 200; }\x0a        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== \x27function\x27; })) {\x0a            throw Error(\x27ListKeyManager items in typeahead mode must implement the `getLabel` method.\x27);\x0a        }\x0a        this._typeaheadSubscription.unsubscribe();\x0a        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\x0a        // and convert those letters back into a string. Afterwards find the first item that starts\x0a        // with that string and select it.\x0a        this._typeaheadSubscription = this._letterKeyStream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\x22tap\x22])(function (keyCode) { return _this._pressedLetters.push(keyCode); }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\x22debounceTime\x22])(debounceInterval), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\x22filter\x22])(function () { return _this._pressedLetters.length \x3e 0; }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\x22map\x22])(function () { return _this._pressedLetters.join(\x27\x27); })).subscribe(function (inputString) {\x0a            /** @type {?} */\x0a            var items = _this._getItemsArray();\x0a            // Start at 1 because we want to start searching at the item immediately\x0a            // following the current active item.\x0a            for (var i = 1; i \x3c items.length + 1; i++) {\x0a                /** @type {?} */\x0a                var index = (_this._activeItemIndex + i) % items.length;\x0a                /** @type {?} */\x0a                var item = items[index];\x0a                if (!_this._skipPredicateFn(item) && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\x0a                    _this.setActiveItem(index);\x0a                    break;\x0a                }\x0a            }\x0a            _this._pressedLetters = [];\x0a        });\x0a        return this;\x0a    };\x0a    /**\x0a     * @param {?} item\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.setActiveItem = /**\x0a     * @param {?} item\x0a     * @return {?}\x0a     */\x0a    function (item) {\x0a        /** @type {?} */\x0a        var previousIndex = this._activeItemIndex;\x0a        this.updateActiveItem(item);\x0a        if (this._activeItemIndex !== previousIndex) {\x0a            this.change.next(this._activeItemIndex);\x0a        }\x0a    };\x0a    /**\x0a     * Sets the active item depending on the key event passed in.\x0a     * @param event Keyboard event to be used for determining which element should be active.\x0a     */\x0a    /**\x0a     * Sets the active item depending on the key event passed in.\x0a     * @param {?} event Keyboard event to be used for determining which element should be active.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.onKeydown = /**\x0a     * Sets the active item depending on the key event passed in.\x0a     * @param {?} event Keyboard event to be used for determining which element should be active.\x0a     * @return {?}\x0a     */\x0a    function (event) {\x0a        /** @type {?} */\x0a        var keyCode = event.keyCode;\x0a        switch (keyCode) {\x0a            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__[\x22TAB\x22]:\x0a                this.tabOut.next();\x0a                return;\x0a            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__[\x22DOWN_ARROW\x22]:\x0a                if (this._vertical) {\x0a                    this.setNextItemActive();\x0a                    break;\x0a                }\x0a                else {\x0a                    return;\x0a                }\x0a            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__[\x22UP_ARROW\x22]:\x0a                if (this._vertical) {\x0a                    this.setPreviousItemActive();\x0a                    break;\x0a                }\x0a                else {\x0a                    return;\x0a                }\x0a            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__[\x22RIGHT_ARROW\x22]:\x0a                if (this._horizontal === \x27ltr\x27) {\x0a                    this.setNextItemActive();\x0a                    break;\x0a                }\x0a                else if (this._horizontal === \x27rtl\x27) {\x0a                    this.setPreviousItemActive();\x0a                    break;\x0a                }\x0a                else {\x0a                    return;\x0a                }\x0a            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__[\x22LEFT_ARROW\x22]:\x0a                if (this._horizontal === \x27ltr\x27) {\x0a                    this.setPreviousItemActive();\x0a                    break;\x0a                }\x0a                else if (this._horizontal === \x27rtl\x27) {\x0a                    this.setNextItemActive();\x0a                    break;\x0a                }\x0a                else {\x0a                    return;\x0a                }\x0a            default:\x0a                // Attempt to use the `event.key` which also maps it to the user\x27s keyboard language,\x0a                // otherwise fall back to resolving alphanumeric characters via the keyCode.\x0a                if (event.key && event.key.length === 1) {\x0a                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\x0a                }\x0a                else if ((keyCode \x3e= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__[\x22A\x22] && keyCode \x3c= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__[\x22Z\x22]) || (keyCode \x3e= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__[\x22ZERO\x22] && keyCode \x3c= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__[\x22NINE\x22])) {\x0a                    this._letterKeyStream.next(String.fromCharCode(keyCode));\x0a                }\x0a                // Note that we return here, in order to avoid preventing\x0a                // the default action of non-navigational keys.\x0a                return;\x0a        }\x0a        this._pressedLetters = [];\x0a        event.preventDefault();\x0a    };\x0a    Object.defineProperty(ListKeyManager.prototype, \x22activeItemIndex\x22, {\x0a        /** Index of the currently active item. */\x0a        get: /**\x0a         * Index of the currently active item.\x0a         * @return {?}\x0a         */\x0a        function () {\x0a            return this._activeItemIndex;\x0a        },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    Object.defineProperty(ListKeyManager.prototype, \x22activeItem\x22, {\x0a        /** The active item. */\x0a        get: /**\x0a         * The active item.\x0a         * @return {?}\x0a         */\x0a        function () {\x0a            return this._activeItem;\x0a        },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    /** Sets the active item to the first enabled item in the list. */\x0a    /**\x0a     * Sets the active item to the first enabled item in the list.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.setFirstItemActive = /**\x0a     * Sets the active item to the first enabled item in the list.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._setActiveItemByIndex(0, 1);\x0a    };\x0a    /** Sets the active item to the last enabled item in the list. */\x0a    /**\x0a     * Sets the active item to the last enabled item in the list.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.setLastItemActive = /**\x0a     * Sets the active item to the last enabled item in the list.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._setActiveItemByIndex(this._items.length - 1, -1);\x0a    };\x0a    /** Sets the active item to the next enabled item in the list. */\x0a    /**\x0a     * Sets the active item to the next enabled item in the list.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.setNextItemActive = /**\x0a     * Sets the active item to the next enabled item in the list.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._activeItemIndex \x3c 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\x0a    };\x0a    /** Sets the active item to a previous enabled item in the list. */\x0a    /**\x0a     * Sets the active item to a previous enabled item in the list.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.setPreviousItemActive = /**\x0a     * Sets the active item to a previous enabled item in the list.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._activeItemIndex \x3c 0 && this._wrap ? this.setLastItemActive()\x0a            : this._setActiveItemByDelta(-1);\x0a    };\x0a    /**\x0a     * @param {?} item\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.updateActiveItem = /**\x0a     * @param {?} item\x0a     * @return {?}\x0a     */\x0a    function (item) {\x0a        /** @type {?} */\x0a        var itemArray = this._getItemsArray();\x0a        /** @type {?} */\x0a        var index = typeof item === \x27number\x27 ? item : itemArray.indexOf(item);\x0a        this._activeItemIndex = index;\x0a        this._activeItem = itemArray[index];\x0a    };\x0a    /**\x0a     * Allows setting of the activeItemIndex without any other effects.\x0a     * @param index The new activeItemIndex.\x0a     * @deprecated Use `updateActiveItem` instead.\x0a     * @breaking-change 8.0.0\x0a     */\x0a    /**\x0a     * Allows setting of the activeItemIndex without any other effects.\x0a     * @deprecated Use `updateActiveItem` instead.\x0a     * \x5c@breaking-change 8.0.0\x0a     * @param {?} index The new activeItemIndex.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype.updateActiveItemIndex = /**\x0a     * Allows setting of the activeItemIndex without any other effects.\x0a     * @deprecated Use `updateActiveItem` instead.\x0a     * \x5c@breaking-change 8.0.0\x0a     * @param {?} index The new activeItemIndex.\x0a     * @return {?}\x0a     */\x0a    function (index) {\x0a        this.updateActiveItem(index);\x0a    };\x0a    /**\x0a     * This method sets the active item, given a list of items and the delta between the\x0a     * currently active item and the new active item. It will calculate differently\x0a     * depending on whether wrap mode is turned on.\x0a     * @param {?} delta\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype._setActiveItemByDelta = /**\x0a     * This method sets the active item, given a list of items and the delta between the\x0a     * currently active item and the new active item. It will calculate differently\x0a     * depending on whether wrap mode is turned on.\x0a     * @param {?} delta\x0a     * @return {?}\x0a     */\x0a    function (delta) {\x0a        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\x0a    };\x0a    /**\x0a     * Sets the active item properly given \x22wrap\x22 mode. In other words, it will continue to move\x0a     * down the list until it finds an item that is not disabled, and it will wrap if it\x0a     * encounters either end of the list.\x0a     * @param {?} delta\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype._setActiveInWrapMode = /**\x0a     * Sets the active item properly given \x22wrap\x22 mode. In other words, it will continue to move\x0a     * down the list until it finds an item that is not disabled, and it will wrap if it\x0a     * encounters either end of the list.\x0a     * @param {?} delta\x0a     * @return {?}\x0a     */\x0a    function (delta) {\x0a        /** @type {?} */\x0a        var items = this._getItemsArray();\x0a        for (var i = 1; i \x3c= items.length; i++) {\x0a            /** @type {?} */\x0a            var index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\x0a            /** @type {?} */\x0a            var item = items[index];\x0a            if (!this._skipPredicateFn(item)) {\x0a                this.setActiveItem(index);\x0a                return;\x0a            }\x0a        }\x0a    };\x0a    /**\x0a     * Sets the active item properly given the default mode. In other words, it will\x0a     * continue to move down the list until it finds an item that is not disabled. If\x0a     * it encounters either end of the list, it will stop and not wrap.\x0a     * @param {?} delta\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype._setActiveInDefaultMode = /**\x0a     * Sets the active item properly given the default mode. In other words, it will\x0a     * continue to move down the list until it finds an item that is not disabled. If\x0a     * it encounters either end of the list, it will stop and not wrap.\x0a     * @param {?} delta\x0a     * @return {?}\x0a     */\x0a    function (delta) {\x0a        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\x0a    };\x0a    /**\x0a     * Sets the active item to the first enabled item starting at the index specified. If the\x0a     * item is disabled, it will move in the fallbackDelta direction until it either\x0a     * finds an enabled item or encounters the end of the list.\x0a     * @param {?} index\x0a     * @param {?} fallbackDelta\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype._setActiveItemByIndex = /**\x0a     * Sets the active item to the first enabled item starting at the index specified. If the\x0a     * item is disabled, it will move in the fallbackDelta direction until it either\x0a     * finds an enabled item or encounters the end of the list.\x0a     * @param {?} index\x0a     * @param {?} fallbackDelta\x0a     * @return {?}\x0a     */\x0a    function (index, fallbackDelta) {\x0a        /** @type {?} */\x0a        var items = this._getItemsArray();\x0a        if (!items[index]) {\x0a            return;\x0a        }\x0a        while (this._skipPredicateFn(items[index])) {\x0a            index += fallbackDelta;\x0a            if (!items[index]) {\x0a                return;\x0a            }\x0a        }\x0a        this.setActiveItem(index);\x0a    };\x0a    /**\x0a     * Returns the items as an array.\x0a     * @return {?}\x0a     */\x0a    ListKeyManager.prototype._getItemsArray = /**\x0a     * Returns the items as an array.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        return this._items instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22QueryList\x22] ? this._items.toArray() : this._items;\x0a    };\x0a    return ListKeyManager;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/**\x0a * @template T\x0a */\x0avar  /**\x0a * @template T\x0a */\x0aActiveDescendantKeyManager = /** @class */ (function (_super) {\x0a    Object(tslib__WEBPACK_IMPORTED_MODULE_5__[\x22__extends\x22])(ActiveDescendantKeyManager, _super);\x0a    function ActiveDescendantKeyManager() {\x0a        return _super !== null && _super.apply(this, arguments) || this;\x0a    }\x0a    /**\x0a     * @param {?} index\x0a     * @return {?}\x0a     */\x0a    ActiveDescendantKeyManager.prototype.setActiveItem = /**\x0a     * @param {?} index\x0a     * @return {?}\x0a     */\x0a    function (index) {\x0a        if (this.activeItem) {\x0a            this.activeItem.setInactiveStyles();\x0a        }\x0a        _super.prototype.setActiveItem.call(this, index);\x0a        if (this.activeItem) {\x0a            this.activeItem.setActiveStyles();\x0a        }\x0a    };\x0a    return ActiveDescendantKeyManager;\x0a}(ListKeyManager));\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/**\x0a * @template T\x0a */\x0avar  /**\x0a * @template T\x0a */\x0aFocusKeyManager = /** @class */ (function (_super) {\x0a    Object(tslib__WEBPACK_IMPORTED_MODULE_5__[\x22__extends\x22])(FocusKeyManager, _super);\x0a    function FocusKeyManager() {\x0a        var _this = _super !== null && _super.apply(this, arguments) || this;\x0a        _this._origin = \x27program\x27;\x0a        return _this;\x0a    }\x0a    /**\x0a     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\x0a     * @param origin Focus origin to be used when focusing items.\x0a     */\x0a    /**\x0a     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\x0a     * @param {?} origin Focus origin to be used when focusing items.\x0a     * @return {?}\x0a     */\x0a    FocusKeyManager.prototype.setFocusOrigin = /**\x0a     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\x0a     * @param {?} origin Focus origin to be used when focusing items.\x0a     * @return {?}\x0a     */\x0a    function (origin) {\x0a        this._origin = origin;\x0a        return this;\x0a    };\x0a    /**\x0a     * @param {?} item\x0a     * @return {?}\x0a     */\x0a    FocusKeyManager.prototype.setActiveItem = /**\x0a     * @param {?} item\x0a     * @return {?}\x0a     */\x0a    function (item) {\x0a        _super.prototype.setActiveItem.call(this, item);\x0a        if (this.activeItem) {\x0a            this.activeItem.focus(this._origin);\x0a        }\x0a    };\x0a    return FocusKeyManager;\x0a}(ListKeyManager));\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/**\x0a * Utility for checking the interactivity of an element, such as whether is is focusable or\x0a * tabbable.\x0a */\x0avar InteractivityChecker = /** @class */ (function () {\x0a    function InteractivityChecker(_platform) {\x0a        this._platform = _platform;\x0a    }\x0a    /**\x0a     * Gets whether an element is disabled.\x0a     *\x0a     * @param element Element to be checked.\x0a     * @returns Whether the element is disabled.\x0a     */\x0a    /**\x0a     * Gets whether an element is disabled.\x0a     *\x0a     * @param {?} element Element to be checked.\x0a     * @return {?} Whether the element is disabled.\x0a     */\x0a    InteractivityChecker.prototype.isDisabled = /**\x0a     * Gets whether an element is disabled.\x0a     *\x0a     * @param {?} element Element to be checked.\x0a     * @return {?} Whether the element is disabled.\x0a     */\x0a    function (element) {\x0a        // This does not capture some cases, such as a non-form control with a disabled attribute or\x0a        // a form control inside of a disabled form, but should capture the most common cases.\x0a        return element.hasAttribute(\x27disabled\x27);\x0a    };\x0a    /**\x0a     * Gets whether an element is visible for the purposes of interactivity.\x0a     *\x0a     * This will capture states like `display: none` and `visibility: hidden`, but not things like\x0a     * being clipped by an `overflow: hidden` parent or being outside the viewport.\x0a     *\x0a     * @returns Whether the element is visible.\x0a     */\x0a    /**\x0a     * Gets whether an element is visible for the purposes of interactivity.\x0a     *\x0a     * This will capture states like `display: none` and `visibility: hidden`, but not things like\x0a     * being clipped by an `overflow: hidden` parent or being outside the viewport.\x0a     *\x0a     * @param {?} element\x0a     * @return {?} Whether the element is visible.\x0a     */\x0a    InteractivityChecker.prototype.isVisible = /**\x0a     * Gets whether an element is visible for the purposes of interactivity.\x0a     *\x0a     * This will capture states like `display: none` and `visibility: hidden`, but not things like\x0a     * being clipped by an `overflow: hidden` parent or being outside the viewport.\x0a     *\x0a     * @param {?} element\x0a     * @return {?} Whether the element is visible.\x0a     */\x0a    function (element) {\x0a        return hasGeometry(element) && getComputedStyle(element).visibility === \x27visible\x27;\x0a    };\x0a    /**\x0a     * Gets whether an element can be reached via Tab key.\x0a     * Assumes that the element has already been checked with isFocusable.\x0a     *\x0a     * @param element Element to be checked.\x0a     * @returns Whether the element is tabbable.\x0a     */\x0a    /**\x0a     * Gets whether an element can be reached via Tab key.\x0a     * Assumes that the element has already been checked with isFocusable.\x0a     *\x0a     * @param {?} element Element to be checked.\x0a     * @return {?} Whether the element is tabbable.\x0a     */\x0a    InteractivityChecker.prototype.isTabbable = /**\x0a     * Gets whether an element can be reached via Tab key.\x0a     * Assumes that the element has already been checked with isFocusable.\x0a     *\x0a     * @param {?} element Element to be checked.\x0a     * @return {?} Whether the element is tabbable.\x0a     */\x0a    function (element) {\x0a        // Nothing is tabbable on the the server \xf0\x9f\x98\x8e\x0a        if (!this._platform.isBrowser) {\x0a            return false;\x0a        }\x0a        /** @type {?} */\x0a        var frameElement = getFrameElement(getWindow(element));\x0a        if (frameElement) {\x0a            /** @type {?} */\x0a            var frameType = frameElement && frameElement.nodeName.toLowerCase();\x0a            // Frame elements inherit their tabindex onto all child elements.\x0a            if (getTabIndexValue(frameElement) === -1) {\x0a                return false;\x0a            }\x0a            // Webkit and Blink consider anything inside of an \x3cobject\x3e element as non-tabbable.\x0a            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === \x27object\x27) {\x0a                return false;\x0a            }\x0a            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\x0a            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\x0a                return false;\x0a            }\x0a        }\x0a        /** @type {?} */\x0a        var nodeName = element.nodeName.toLowerCase();\x0a        /** @type {?} */\x0a        var tabIndexValue = getTabIndexValue(element);\x0a        if (element.hasAttribute(\x27contenteditable\x27)) {\x0a            return tabIndexValue !== -1;\x0a        }\x0a        if (nodeName === \x27iframe\x27) {\x0a            // The frames may be tabbable depending on content, but it\x27s not possibly to reliably\x0a            // investigate the content of the frames.\x0a            return false;\x0a        }\x0a        if (nodeName === \x27audio\x27) {\x0a            if (!element.hasAttribute(\x27controls\x27)) {\x0a                // By default an \x3caudio\x3e element without the controls enabled is not tabbable.\x0a                return false;\x0a            }\x0a            else if (this._platform.BLINK) {\x0a                // In Blink \x3caudio controls\x3e elements are always tabbable.\x0a                return true;\x0a            }\x0a        }\x0a        if (nodeName === \x27video\x27) {\x0a            if (!element.hasAttribute(\x27controls\x27) && this._platform.TRIDENT) {\x0a                // In Trident a \x3cvideo\x3e element without the controls enabled is not tabbable.\x0a                return false;\x0a            }\x0a            else if (this._platform.BLINK || this._platform.FIREFOX) {\x0a                // In Chrome and Firefox \x3cvideo controls\x3e elements are always tabbable.\x0a                return true;\x0a            }\x0a        }\x0a        if (nodeName === \x27object\x27 && (this._platform.BLINK || this._platform.WEBKIT)) {\x0a            // In all Blink and WebKit based browsers \x3cobject\x3e elements are never tabbable.\x0a            return false;\x0a        }\x0a        // In iOS the browser only considers some specific elements as tabbable.\x0a        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\x0a            return false;\x0a        }\x0a        return element.tabIndex \x3e= 0;\x0a    };\x0a    /**\x0a     * Gets whether an element can be focused by the user.\x0a     *\x0a     * @param element Element to be checked.\x0a     * @returns Whether the element is focusable.\x0a     */\x0a    /**\x0a     * Gets whether an element can be focused by the user.\x0a     *\x0a     * @param {?} element Element to be checked.\x0a     * @return {?} Whether the element is focusable.\x0a     */\x0a    InteractivityChecker.prototype.isFocusable = /**\x0a     * Gets whether an element can be focused by the user.\x0a     *\x0a     * @param {?} element Element to be checked.\x0a     * @return {?} Whether the element is focusable.\x0a     */\x0a    function (element) {\x0a        // Perform checks in order of left to most expensive.\x0a        // Again, naive approach that does not capture many edge cases and browser quirks.\x0a        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\x0a    };\x0a    InteractivityChecker.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Injectable\x22], args: [{ providedIn: \x27root\x27 },] },\x0a    ];\x0a    /** @nocollapse */\x0a    InteractivityChecker.ctorParameters = function () { return [\x0a        { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__[\x22Platform\x22] }\x0a    ]; };\x0a    /** @nocollapse */ InteractivityChecker.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22defineInjectable\x22])({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__[\x22Platform\x22])); }, token: InteractivityChecker, providedIn: \x22root\x22 });\x0a    return InteractivityChecker;\x0a}());\x0a/**\x0a * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\x0a * the frameElement property is being accessed from a different host address, this property\x0a * should be accessed carefully.\x0a * @param {?} window\x0a * @return {?}\x0a */\x0afunction getFrameElement(window) {\x0a    try {\x0a        return /** @type {?} */ (window.frameElement);\x0a    }\x0a    catch (_a) {\x0a        return null;\x0a    }\x0a}\x0a/**\x0a * Checks whether the specified element has any geometry / rectangles.\x0a * @param {?} element\x0a * @return {?}\x0a */\x0afunction hasGeometry(element) {\x0a    // Use logic from jQuery to check for an invisible element.\x0a    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\x0a    return !!(element.offsetWidth || element.offsetHeight ||\x0a        (typeof element.getClientRects === \x27function\x27 && element.getClientRects().length));\x0a}\x0a/**\x0a * Gets whether an element\x27s\x0a * @param {?} element\x0a * @return {?}\x0a */\x0afunction isNativeFormElement(element) {\x0a    /** @type {?} */\x0a    var nodeName = element.nodeName.toLowerCase();\x0a    return nodeName === \x27input\x27 ||\x0a        nodeName === \x27select\x27 ||\x0a        nodeName === \x27button\x27 ||\x0a        nodeName === \x27textarea\x27;\x0a}\x0a/**\x0a * Gets whether an element is an `\x3cinput type=\x22hidden\x22\x3e`.\x0a * @param {?} element\x0a * @return {?}\x0a */\x0afunction isHiddenInput(element) {\x0a    return isInputElement(element) && element.type == \x27hidden\x27;\x0a}\x0a/**\x0a * Gets whether an element is an anchor that has an href attribute.\x0a * @param {?} element\x0a * @return {?}\x0a */\x0afunction isAnchorWithHref(element) {\x0a    return isAnchorElement(element) && element.hasAttribute(\x27href\x27);\x0a}\x0a/**\x0a * Gets whether an element is an input element.\x0a * @param {?} element\x0a * @return {?}\x0a */\x0afunction isInputElement(element) {\x0a    return element.nodeName.toLowerCase() == \x27input\x27;\x0a}\x0a/**\x0a * Gets whether an element is an anchor element.\x0a * @param {?} element\x0a * @return {?}\x0a */\x0afunction isAnchorElement(element) {\x0a    return element.nodeName.toLowerCase() == \x27a\x27;\x0a}\x0a/**\x0a * Gets whether an element has a valid tabindex.\x0a * @param {?} element\x0a * @return {?}\x0a */\x0afunction hasValidTabIndex(element) {\x0a    if (!element.hasAttribute(\x27tabindex\x27) || element.tabIndex === undefined) {\x0a        return false;\x0a    }\x0a    /** @type {?} */\x0a    var tabIndex = element.getAttribute(\x27tabindex\x27);\x0a    // IE11 parses tabindex=\x22\x22 as the value \x22-32768\x22\x0a    if (tabIndex == \x27-32768\x27) {\x0a        return false;\x0a    }\x0a    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\x0a}\x0a/**\x0a * Returns the parsed tabindex from the element attributes instead of returning the\x0a * evaluated tabindex from the browsers defaults.\x0a * @param {?} element\x0a * @return {?}\x0a */\x0afunction getTabIndexValue(element) {\x0a    if (!hasValidTabIndex(element)) {\x0a        return null;\x0a    }\x0a    /** @type {?} */\x0a    var tabIndex = parseInt(element.getAttribute(\x27tabindex\x27) || \x27\x27, 10);\x0a    return isNaN(tabIndex) ? -1 : tabIndex;\x0a}\x0a/**\x0a * Checks whether the specified element is potentially tabbable on iOS\x0a * @param {?} element\x0a * @return {?}\x0a */\x0afunction isPotentiallyTabbableIOS(element) {\x0a    /** @type {?} */\x0a    var nodeName = element.nodeName.toLowerCase();\x0a    /** @type {?} */\x0a    var inputType = nodeName === \x27input\x27 && (/** @type {?} */ (element)).type;\x0a    return inputType === \x27text\x27\x0a        || inputType === \x27password\x27\x0a        || nodeName === \x27select\x27\x0a        || nodeName === \x27textarea\x27;\x0a}\x0a/**\x0a * Gets whether an element is potentially focusable without taking current visible/disabled state\x0a * into account.\x0a * @param {?} element\x0a * @return {?}\x0a */\x0afunction isPotentiallyFocusable(element) {\x0a    // Inputs are potentially focusable *unless* they\x27re type=\x22hidden\x22.\x0a    if (isHiddenInput(element)) {\x0a        return false;\x0a    }\x0a    return isNativeFormElement(element) ||\x0a        isAnchorWithHref(element) ||\x0a        element.hasAttribute(\x27contenteditable\x27) ||\x0a        hasValidTabIndex(element);\x0a}\x0a/**\x0a * Gets the parent window of a DOM node with regards of being inside of an iframe.\x0a * @param {?} node\x0a * @return {?}\x0a */\x0afunction getWindow(node) {\x0a    // ownerDocument is null if `node` itself *is* a document.\x0a    return node.ownerDocument && node.ownerDocument.defaultView || window;\x0a}\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/**\x0a * Class that allows for trapping focus within a DOM element.\x0a *\x0a * This class currently uses a relatively simple approach to focus trapping.\x0a * It assumes that the tab order is the same as DOM order, which is not necessarily true.\x0a * Things like `tabIndex \x3e 0`, flex `order`, and shadow roots can cause to two to misalign.\x0a */\x0avar  /**\x0a * Class that allows for trapping focus within a DOM element.\x0a *\x0a * This class currently uses a relatively simple approach to focus trapping.\x0a * It assumes that the tab order is the same as DOM order, which is not necessarily true.\x0a * Things like `tabIndex \x3e 0`, flex `order`, and shadow roots can cause to two to misalign.\x0a */\x0aFocusTrap = /** @class */ (function () {\x0a    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\x0a        if (deferAnchors === void 0) { deferAnchors = false; }\x0a        this._element = _element;\x0a        this._checker = _checker;\x0a        this._ngZone = _ngZone;\x0a        this._document = _document;\x0a        this._hasAttached = false;\x0a        this._enabled = true;\x0a        if (!deferAnchors) {\x0a            this.attachAnchors();\x0a        }\x0a    }\x0a    Object.defineProperty(FocusTrap.prototype, \x22enabled\x22, {\x0a        /** Whether the focus trap is active. */\x0a        get: /**\x0a         * Whether the focus trap is active.\x0a         * @return {?}\x0a         */\x0a        function () { return this._enabled; },\x0a        set: /**\x0a         * @param {?} value\x0a         * @return {?}\x0a         */\x0a        function (value) {\x0a            this._enabled = value;\x0a            if (this._startAnchor && this._endAnchor) {\x0a                this._toggleAnchorTabIndex(value, this._startAnchor);\x0a                this._toggleAnchorTabIndex(value, this._endAnchor);\x0a            }\x0a        },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    /** Destroys the focus trap by cleaning up the anchors. */\x0a    /**\x0a     * Destroys the focus trap by cleaning up the anchors.\x0a     * @return {?}\x0a     */\x0a    FocusTrap.prototype.destroy = /**\x0a     * Destroys the focus trap by cleaning up the anchors.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        if (this._startAnchor && this._startAnchor.parentNode) {\x0a            this._startAnchor.parentNode.removeChild(this._startAnchor);\x0a        }\x0a        if (this._endAnchor && this._endAnchor.parentNode) {\x0a            this._endAnchor.parentNode.removeChild(this._endAnchor);\x0a        }\x0a        this._startAnchor = this._endAnchor = null;\x0a    };\x0a    /**\x0a     * Inserts the anchors into the DOM. This is usually done automatically\x0a     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\x0a     * @returns Whether the focus trap managed to attach successfuly. This may not be the case\x0a     * if the target element isn\x27t currently in the DOM.\x0a     */\x0a    /**\x0a     * Inserts the anchors into the DOM. This is usually done automatically\x0a     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\x0a     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case\x0a     * if the target element isn\x27t currently in the DOM.\x0a     */\x0a    FocusTrap.prototype.attachAnchors = /**\x0a     * Inserts the anchors into the DOM. This is usually done automatically\x0a     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\x0a     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case\x0a     * if the target element isn\x27t currently in the DOM.\x0a     */\x0a    function () {\x0a        var _this = this;\x0a        // If we\x27re not on the browser, there can be no focus to trap.\x0a        if (this._hasAttached) {\x0a            return true;\x0a        }\x0a        this._ngZone.runOutsideAngular(function () {\x0a            if (!_this._startAnchor) {\x0a                _this._startAnchor = _this._createAnchor(); /** @type {?} */\x0a                ((_this._startAnchor)).addEventListener(\x27focus\x27, function () { return _this.focusLastTabbableElement(); });\x0a            }\x0a            if (!_this._endAnchor) {\x0a                _this._endAnchor = _this._createAnchor(); /** @type {?} */\x0a                ((_this._endAnchor)).addEventListener(\x27focus\x27, function () { return _this.focusFirstTabbableElement(); });\x0a            }\x0a        });\x0a        if (this._element.parentNode) {\x0a            this._element.parentNode.insertBefore(/** @type {?} */ ((this._startAnchor)), this._element);\x0a            this._element.parentNode.insertBefore(/** @type {?} */ ((this._endAnchor)), this._element.nextSibling);\x0a            this._hasAttached = true;\x0a        }\x0a        return this._hasAttached;\x0a    };\x0a    /**\x0a     * Waits for the zone to stabilize, then either focuses the first element that the\x0a     * user specified, or the first tabbable element.\x0a     * @returns Returns a promise that resolves with a boolean, depending\x0a     * on whether focus was moved successfuly.\x0a     */\x0a    /**\x0a     * Waits for the zone to stabilize, then either focuses the first element that the\x0a     * user specified, or the first tabbable element.\x0a     * @return {?} Returns a promise that resolves with a boolean, depending\x0a     * on whether focus was moved successfuly.\x0a     */\x0a    FocusTrap.prototype.focusInitialElementWhenReady = /**\x0a     * Waits for the zone to stabilize, then either focuses the first element that the\x0a     * user specified, or the first tabbable element.\x0a     * @return {?} Returns a promise that resolves with a boolean, depending\x0a     * on whether focus was moved successfuly.\x0a     */\x0a    function () {\x0a        var _this = this;\x0a        return new Promise(function (resolve) {\x0a            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\x0a        });\x0a    };\x0a    /**\x0a     * Waits for the zone to stabilize, then focuses\x0a     * the first tabbable element within the focus trap region.\x0a     * @returns Returns a promise that resolves with a boolean, depending\x0a     * on whether focus was moved successfuly.\x0a     */\x0a    /**\x0a     * Waits for the zone to stabilize, then focuses\x0a     * the first tabbable element within the focus trap region.\x0a     * @return {?} Returns a promise that resolves with a boolean, depending\x0a     * on whether focus was moved successfuly.\x0a     */\x0a    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\x0a     * Waits for the zone to stabilize, then focuses\x0a     * the first tabbable element within the focus trap region.\x0a     * @return {?} Returns a promise that resolves with a boolean, depending\x0a     * on whether focus was moved successfuly.\x0a     */\x0a    function () {\x0a        var _this = this;\x0a        return new Promise(function (resolve) {\x0a            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\x0a        });\x0a    };\x0a    /**\x0a     * Waits for the zone to stabilize, then focuses\x0a     * the last tabbable element within the focus trap region.\x0a     * @returns Returns a promise that resolves with a boolean, depending\x0a     * on whether focus was moved successfuly.\x0a     */\x0a    /**\x0a     * Waits for the zone to stabilize, then focuses\x0a     * the last tabbable element within the focus trap region.\x0a     * @return {?} Returns a promise that resolves with a boolean, depending\x0a     * on whether focus was moved successfuly.\x0a     */\x0a    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\x0a     * Waits for the zone to stabilize, then focuses\x0a     * the last tabbable element within the focus trap region.\x0a     * @return {?} Returns a promise that resolves with a boolean, depending\x0a     * on whether focus was moved successfuly.\x0a     */\x0a    function () {\x0a        var _this = this;\x0a        return new Promise(function (resolve) {\x0a            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\x0a        });\x0a    };\x0a    /**\x0a     * Get the specified boundary element of the trapped region.\x0a     * @param {?} bound The boundary to get (start or end of trapped region).\x0a     * @return {?} The boundary element.\x0a     */\x0a    FocusTrap.prototype._getRegionBoundary = /**\x0a     * Get the specified boundary element of the trapped region.\x0a     * @param {?} bound The boundary to get (start or end of trapped region).\x0a     * @return {?} The boundary element.\x0a     */\x0a    function (bound) {\x0a        /** @type {?} */\x0a        var markers = /** @type {?} */ (this._element.querySelectorAll(\x22[cdk-focus-region-\x22 + bound + \x22], \x22 +\x0a            (\x22[cdkFocusRegion\x22 + bound + \x22], \x22) +\x0a            (\x22[cdk-focus-\x22 + bound + \x22]\x22)));\x0a        for (var i = 0; i \x3c markers.length; i++) {\x0a            // @breaking-change 8.0.0\x0a            if (markers[i].hasAttribute(\x22cdk-focus-\x22 + bound)) {\x0a                console.warn(\x22Found use of deprecated attribute \x27cdk-focus-\x22 + bound + \x22\x27, \x22 +\x0a                    (\x22use \x27cdkFocusRegion\x22 + bound + \x22\x27 instead. The deprecated \x22) +\x0a                    \x22attribute will be removed in 8.0.0.\x22, markers[i]);\x0a            }\x0a            else if (markers[i].hasAttribute(\x22cdk-focus-region-\x22 + bound)) {\x0a                console.warn(\x22Found use of deprecated attribute \x27cdk-focus-region-\x22 + bound + \x22\x27, \x22 +\x0a                    (\x22use \x27cdkFocusRegion\x22 + bound + \x22\x27 instead. The deprecated attribute \x22) +\x0a                    \x22will be removed in 8.0.0.\x22, markers[i]);\x0a            }\x0a        }\x0a        if (bound == \x27start\x27) {\x0a            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\x0a        }\x0a        return markers.length ?\x0a            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\x0a    };\x0a    /**\x0a     * Focuses the element that should be focused when the focus trap is initialized.\x0a     * @returns Whether focus was moved successfuly.\x0a     */\x0a    /**\x0a     * Focuses the element that should be focused when the focus trap is initialized.\x0a     * @return {?} Whether focus was moved successfuly.\x0a     */\x0a    FocusTrap.prototype.focusInitialElement = /**\x0a     * Focuses the element that should be focused when the focus trap is initialized.\x0a     * @return {?} Whether focus was moved successfuly.\x0a     */\x0a    function () {\x0a        /** @type {?} */\x0a        var redirectToElement = /** @type {?} */ (this._element.querySelector(\x22[cdk-focus-initial], \x22 +\x0a            \x22[cdkFocusInitial]\x22));\x0a        if (redirectToElement) {\x0a            // @breaking-change 8.0.0\x0a            if (redirectToElement.hasAttribute(\x22cdk-focus-initial\x22)) {\x0a                console.warn(\x22Found use of deprecated attribute \x27cdk-focus-initial\x27, \x22 +\x0a                    \x22use \x27cdkFocusInitial\x27 instead. The deprecated attribute \x22 +\x0a                    \x22will be removed in 8.0.0\x22, redirectToElement);\x0a            }\x0a            redirectToElement.focus();\x0a            return true;\x0a        }\x0a        return this.focusFirstTabbableElement();\x0a    };\x0a    /**\x0a     * Focuses the first tabbable element within the focus trap region.\x0a     * @returns Whether focus was moved successfuly.\x0a     */\x0a    /**\x0a     * Focuses the first tabbable element within the focus trap region.\x0a     * @return {?} Whether focus was moved successfuly.\x0a     */\x0a    FocusTrap.prototype.focusFirstTabbableElement = /**\x0a     * Focuses the first tabbable element within the focus trap region.\x0a     * @return {?} Whether focus was moved successfuly.\x0a     */\x0a    function () {\x0a        /** @type {?} */\x0a        var redirectToElement = this._getRegionBoundary(\x27start\x27);\x0a        if (redirectToElement) {\x0a            redirectToElement.focus();\x0a        }\x0a        return !!redirectToElement;\x0a    };\x0a    /**\x0a     * Focuses the last tabbable element within the focus trap region.\x0a     * @returns Whether focus was moved successfuly.\x0a     */\x0a    /**\x0a     * Focuses the last tabbable element within the focus trap region.\x0a     * @return {?} Whether focus was moved successfuly.\x0a     */\x0a    FocusTrap.prototype.focusLastTabbableElement = /**\x0a     * Focuses the last tabbable element within the focus trap region.\x0a     * @return {?} Whether focus was moved successfuly.\x0a     */\x0a    function () {\x0a        /** @type {?} */\x0a        var redirectToElement = this._getRegionBoundary(\x27end\x27);\x0a        if (redirectToElement) {\x0a            redirectToElement.focus();\x0a        }\x0a        return !!redirectToElement;\x0a    };\x0a    /**\x0a     * Checks whether the focus trap has successfuly been attached.\x0a     */\x0a    /**\x0a     * Checks whether the focus trap has successfuly been attached.\x0a     * @return {?}\x0a     */\x0a    FocusTrap.prototype.hasAttached = /**\x0a     * Checks whether the focus trap has successfuly been attached.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        return this._hasAttached;\x0a    };\x0a    /**\x0a     * Get the first tabbable element from a DOM subtree (inclusive).\x0a     * @param {?} root\x0a     * @return {?}\x0a     */\x0a    FocusTrap.prototype._getFirstTabbableElement = /**\x0a     * Get the first tabbable element from a DOM subtree (inclusive).\x0a     * @param {?} root\x0a     * @return {?}\x0a     */\x0a    function (root) {\x0a        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\x0a            return root;\x0a        }\x0a        /** @type {?} */\x0a        var children = root.children || root.childNodes;\x0a        for (var i = 0; i \x3c children.length; i++) {\x0a            /** @type {?} */\x0a            var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\x0a                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\x0a                null;\x0a            if (tabbableChild) {\x0a                return tabbableChild;\x0a            }\x0a        }\x0a        return null;\x0a    };\x0a    /**\x0a     * Get the last tabbable element from a DOM subtree (inclusive).\x0a     * @param {?} root\x0a     * @return {?}\x0a     */\x0a    FocusTrap.prototype._getLastTabbableElement = /**\x0a     * Get the last tabbable element from a DOM subtree (inclusive).\x0a     * @param {?} root\x0a     * @return {?}\x0a     */\x0a    function (root) {\x0a        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\x0a            return root;\x0a        }\x0a        /** @type {?} */\x0a        var children = root.children || root.childNodes;\x0a        for (var i = children.length - 1; i \x3e= 0; i--) {\x0a            /** @type {?} */\x0a            var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\x0a                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\x0a                null;\x0a            if (tabbableChild) {\x0a                return tabbableChild;\x0a            }\x0a        }\x0a        return null;\x0a    };\x0a    /**\x0a     * Creates an anchor element.\x0a     * @return {?}\x0a     */\x0a    FocusTrap.prototype._createAnchor = /**\x0a     * Creates an anchor element.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        /** @type {?} */\x0a        var anchor = this._document.createElement(\x27div\x27);\x0a        this._toggleAnchorTabIndex(this._enabled, anchor);\x0a        anchor.classList.add(\x27cdk-visually-hidden\x27);\x0a        anchor.classList.add(\x27cdk-focus-trap-anchor\x27);\x0a        return anchor;\x0a    };\x0a    /**\x0a     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\x0a     * @param {?} isEnabled Whether the focus trap is enabled.\x0a     * @param {?} anchor Anchor on which to toggle the tabindex.\x0a     * @return {?}\x0a     */\x0a    FocusTrap.prototype._toggleAnchorTabIndex = /**\x0a     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\x0a     * @param {?} isEnabled Whether the focus trap is enabled.\x0a     * @param {?} anchor Anchor on which to toggle the tabindex.\x0a     * @return {?}\x0a     */\x0a    function (isEnabled, anchor) {\x0a        // Remove the tabindex completely, rather than setting it to -1, because if the\x0a        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\x0a        isEnabled ? anchor.setAttribute(\x27tabindex\x27, \x270\x27) : anchor.removeAttribute(\x27tabindex\x27);\x0a    };\x0a    /**\x0a     * Executes a function when the zone is stable.\x0a     * @param {?} fn\x0a     * @return {?}\x0a     */\x0a    FocusTrap.prototype._executeOnStable = /**\x0a     * Executes a function when the zone is stable.\x0a     * @param {?} fn\x0a     * @return {?}\x0a     */\x0a    function (fn) {\x0a        if (this._ngZone.isStable) {\x0a            fn();\x0a        }\x0a        else {\x0a            this._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\x22take\x22])(1)).subscribe(fn);\x0a        }\x0a    };\x0a    return FocusTrap;\x0a}());\x0a/**\x0a * Factory that allows easy instantiation of focus traps.\x0a */\x0avar FocusTrapFactory = /** @class */ (function () {\x0a    function FocusTrapFactory(_checker, _ngZone, _document) {\x0a        this._checker = _checker;\x0a        this._ngZone = _ngZone;\x0a        this._document = _document;\x0a    }\x0a    /**\x0a     * Creates a focus-trapped region around the given element.\x0a     * @param element The element around which focus will be trapped.\x0a     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\x0a     *     manually by the user.\x0a     * @returns The created focus trap instance.\x0a     */\x0a    /**\x0a     * Creates a focus-trapped region around the given element.\x0a     * @param {?} element The element around which focus will be trapped.\x0a     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\x0a     *     manually by the user.\x0a     * @return {?} The created focus trap instance.\x0a     */\x0a    FocusTrapFactory.prototype.create = /**\x0a     * Creates a focus-trapped region around the given element.\x0a     * @param {?} element The element around which focus will be trapped.\x0a     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\x0a     *     manually by the user.\x0a     * @return {?} The created focus trap instance.\x0a     */\x0a    function (element, deferCaptureElements) {\x0a        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\x0a        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\x0a    };\x0a    FocusTrapFactory.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Injectable\x22], args: [{ providedIn: \x27root\x27 },] },\x0a    ];\x0a    /** @nocollapse */\x0a    FocusTrapFactory.ctorParameters = function () { return [\x0a        { type: InteractivityChecker },\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgZone\x22] },\x0a        { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Inject\x22], args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22DOCUMENT\x22],] }] }\x0a    ]; };\x0a    /** @nocollapse */ FocusTrapFactory.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22defineInjectable\x22])({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(InteractivityChecker), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgZone\x22]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(_angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22DOCUMENT\x22])); }, token: FocusTrapFactory, providedIn: \x22root\x22 });\x0a    return FocusTrapFactory;\x0a}());\x0a/**\x0a * Directive for trapping focus within a region.\x0a */\x0avar CdkTrapFocus = /** @class */ (function () {\x0a    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\x0a        this._elementRef = _elementRef;\x0a        this._focusTrapFactory = _focusTrapFactory;\x0a        /**\x0a         * Previously focused element to restore focus to upon destroy when using autoCapture.\x0a         */\x0a        this._previouslyFocusedElement = null;\x0a        this._document = _document;\x0a        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\x0a    }\x0a    Object.defineProperty(CdkTrapFocus.prototype, \x22enabled\x22, {\x0a        /** Whether the focus trap is active. */\x0a        get: /**\x0a         * Whether the focus trap is active.\x0a         * @return {?}\x0a         */\x0a        function () { return this.focusTrap.enabled; },\x0a        set: /**\x0a         * @param {?} value\x0a         * @return {?}\x0a         */\x0a        function (value) { this.focusTrap.enabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__[\x22coerceBooleanProperty\x22])(value); },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    Object.defineProperty(CdkTrapFocus.prototype, \x22autoCapture\x22, {\x0a        /**\x0a         * Whether the directive should automatially move focus into the trapped region upon\x0a         * initialization and return focus to the previous activeElement upon destruction.\x0a         */\x0a        get: /**\x0a         * Whether the directive should automatially move focus into the trapped region upon\x0a         * initialization and return focus to the previous activeElement upon destruction.\x0a         * @return {?}\x0a         */\x0a        function () { return this._autoCapture; },\x0a        set: /**\x0a         * @param {?} value\x0a         * @return {?}\x0a         */\x0a        function (value) { this._autoCapture = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__[\x22coerceBooleanProperty\x22])(value); },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    /**\x0a     * @return {?}\x0a     */\x0a    CdkTrapFocus.prototype.ngOnDestroy = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this.focusTrap.destroy();\x0a        // If we stored a previously focused element when using autoCapture, return focus to that\x0a        // element now that the trapped region is being destroyed.\x0a        if (this._previouslyFocusedElement) {\x0a            this._previouslyFocusedElement.focus();\x0a            this._previouslyFocusedElement = null;\x0a        }\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    CdkTrapFocus.prototype.ngAfterContentInit = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this.focusTrap.attachAnchors();\x0a        if (this.autoCapture) {\x0a            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\x0a            this.focusTrap.focusInitialElementWhenReady();\x0a        }\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    CdkTrapFocus.prototype.ngDoCheck = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        if (!this.focusTrap.hasAttached()) {\x0a            this.focusTrap.attachAnchors();\x0a        }\x0a    };\x0a    CdkTrapFocus.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Directive\x22], args: [{\x0a                    selector: \x27[cdkTrapFocus]\x27,\x0a                    exportAs: \x27cdkTrapFocus\x27,\x0a                },] },\x0a    ];\x0a    /** @nocollapse */\x0a    CdkTrapFocus.ctorParameters = function () { return [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22ElementRef\x22] },\x0a        { type: FocusTrapFactory },\x0a        { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Inject\x22], args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22DOCUMENT\x22],] }] }\x0a    ]; };\x0a    CdkTrapFocus.propDecorators = {\x0a        enabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Input\x22], args: [\x27cdkTrapFocus\x27,] }],\x0a        autoCapture: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Input\x22], args: [\x27cdkTrapFocusAutoCapture\x27,] }]\x0a    };\x0a    return CdkTrapFocus;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/** @type {?} */\x0avar LIVE_ANNOUNCER_ELEMENT_TOKEN = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22InjectionToken\x22](\x27liveAnnouncerElement\x27, {\x0a    providedIn: \x27root\x27,\x0a    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\x0a});\x0a/**\x0a * \x5c@docs-private\x0a * @return {?}\x0a */\x0afunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\x0a    return null;\x0a}\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0avar LiveAnnouncer = /** @class */ (function () {\x0a    function LiveAnnouncer(elementToken, _ngZone, _document) {\x0a        this._ngZone = _ngZone;\x0a        // We inject the live element and document as `any` because the constructor signature cannot\x0a        // reference browser globals (HTMLElement, Document) on non-browser environments, since having\x0a        // a class decorator causes TypeScript to preserve the constructor signature types.\x0a        this._document = _document;\x0a        this._liveElement = elementToken || this._createLiveElement();\x0a    }\x0a    /**\x0a     * Announces a message to screenreaders.\x0a     * @param message Message to be announced to the screenreader\x0a     * @param politeness The politeness of the announcer element\x0a     * @returns Promise that will be resolved when the message is added to the DOM.\x0a     */\x0a    /**\x0a     * Announces a message to screenreaders.\x0a     * @param {?} message Message to be announced to the screenreader\x0a     * @param {?=} politeness The politeness of the announcer element\x0a     * @return {?} Promise that will be resolved when the message is added to the DOM.\x0a     */\x0a    LiveAnnouncer.prototype.announce = /**\x0a     * Announces a message to screenreaders.\x0a     * @param {?} message Message to be announced to the screenreader\x0a     * @param {?=} politeness The politeness of the announcer element\x0a     * @return {?} Promise that will be resolved when the message is added to the DOM.\x0a     */\x0a    function (message, politeness) {\x0a        var _this = this;\x0a        if (politeness === void 0) { politeness = \x27polite\x27; }\x0a        this._liveElement.textContent = \x27\x27;\x0a        // TODO: ensure changing the politeness works on all environments we support.\x0a        this._liveElement.setAttribute(\x27aria-live\x27, politeness);\x0a        // This 100ms timeout is necessary for some browser + screen-reader combinations:\x0a        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\x0a        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won\x27t be read a\x0a        //   second time without clearing and then using a non-zero delay.\x0a        // (using JAWS 17 at time of this writing).\x0a        return this._ngZone.runOutsideAngular(function () {\x0a            return new Promise(function (resolve) {\x0a                setTimeout(function () {\x0a                    _this._liveElement.textContent = message;\x0a                    resolve();\x0a                }, 100);\x0a            });\x0a        });\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    LiveAnnouncer.prototype.ngOnDestroy = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        if (this._liveElement && this._liveElement.parentNode) {\x0a            this._liveElement.parentNode.removeChild(this._liveElement);\x0a        }\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    LiveAnnouncer.prototype._createLiveElement = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        /** @type {?} */\x0a        var elementClass = \x27cdk-live-announcer-element\x27;\x0a        /** @type {?} */\x0a        var previousElements = this._document.getElementsByClassName(elementClass);\x0a        /** @type {?} */\x0a        var liveEl = this._document.createElement(\x27div\x27);\x0a        // Remove any old containers. This can happen when coming in from a server-side-rendered page.\x0a        for (var i = 0; i \x3c previousElements.length; i++) {\x0a            /** @type {?} */ ((previousElements[i].parentNode)).removeChild(previousElements[i]);\x0a        }\x0a        liveEl.classList.add(elementClass);\x0a        liveEl.classList.add(\x27cdk-visually-hidden\x27);\x0a        liveEl.setAttribute(\x27aria-atomic\x27, \x27true\x27);\x0a        liveEl.setAttribute(\x27aria-live\x27, \x27polite\x27);\x0a        this._document.body.appendChild(liveEl);\x0a        return liveEl;\x0a    };\x0a    LiveAnnouncer.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Injectable\x22], args: [{ providedIn: \x27root\x27 },] },\x0a    ];\x0a    /** @nocollapse */\x0a    LiveAnnouncer.ctorParameters = function () { return [\x0a        { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Optional\x22] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Inject\x22], args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] }] },\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgZone\x22] },\x0a        { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Inject\x22], args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22DOCUMENT\x22],] }] }\x0a    ]; };\x0a    /** @nocollapse */ LiveAnnouncer.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22defineInjectable\x22])({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgZone\x22]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(_angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22DOCUMENT\x22])); }, token: LiveAnnouncer, providedIn: \x22root\x22 });\x0a    return LiveAnnouncer;\x0a}());\x0a/**\x0a * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\x0a * with a wider range of browsers and screen readers.\x0a */\x0avar CdkAriaLive = /** @class */ (function () {\x0a    function CdkAriaLive(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\x0a        this._elementRef = _elementRef;\x0a        this._liveAnnouncer = _liveAnnouncer;\x0a        this._contentObserver = _contentObserver;\x0a        this._ngZone = _ngZone;\x0a        this._politeness = \x27off\x27;\x0a    }\x0a    Object.defineProperty(CdkAriaLive.prototype, \x22politeness\x22, {\x0a        /** The aria-live politeness level to use when announcing messages. */\x0a        get: /**\x0a         * The aria-live politeness level to use when announcing messages.\x0a         * @return {?}\x0a         */\x0a        function () { return this._politeness; },\x0a        set: /**\x0a         * @param {?} value\x0a         * @return {?}\x0a         */\x0a        function (value) {\x0a            var _this = this;\x0a            this._politeness = value === \x27polite\x27 || value === \x27assertive\x27 ? value : \x27off\x27;\x0a            if (this._politeness === \x27off\x27) {\x0a                if (this._subscription) {\x0a                    this._subscription.unsubscribe();\x0a                    this._subscription = null;\x0a                }\x0a            }\x0a            else if (!this._subscription) {\x0a                this._subscription = this._ngZone.runOutsideAngular(function () {\x0a                    return _this._contentObserver\x0a                        .observe(_this._elementRef)\x0a                        .subscribe(function () {\x0a                        /** @type {?} */\x0a                        var element = _this._elementRef.nativeElement;\x0a                        _this._liveAnnouncer.announce(element.textContent, _this._politeness);\x0a                    });\x0a                });\x0a            }\x0a        },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    /**\x0a     * @return {?}\x0a     */\x0a    CdkAriaLive.prototype.ngOnDestroy = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        if (this._subscription) {\x0a            this._subscription.unsubscribe();\x0a        }\x0a    };\x0a    CdkAriaLive.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Directive\x22], args: [{\x0a                    selector: \x27[cdkAriaLive]\x27,\x0a                    exportAs: \x27cdkAriaLive\x27,\x0a                },] },\x0a    ];\x0a    /** @nocollapse */\x0a    CdkAriaLive.ctorParameters = function () { return [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22ElementRef\x22] },\x0a        { type: LiveAnnouncer },\x0a        { type: _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_8__[\x22ContentObserver\x22] },\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgZone\x22] }\x0a    ]; };\x0a    CdkAriaLive.propDecorators = {\x0a        politeness: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Input\x22], args: [\x27cdkAriaLive\x27,] }]\x0a    };\x0a    return CdkAriaLive;\x0a}());\x0a/**\x0a * \x5c@docs-private \x5c@deprecated \x5c@breaking-change 8.0.0\x0a * @param {?} parentDispatcher\x0a * @param {?} liveElement\x0a * @param {?} _document\x0a * @param {?} ngZone\x0a * @return {?}\x0a */\x0afunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document, ngZone) {\x0a    return parentDispatcher || new LiveAnnouncer(liveElement, _document, ngZone);\x0a}\x0a/** *\x0a * \x5c@docs-private \x5c@deprecated \x5c@breaking-change 8.0.0\x0a  @type {?} */\x0avar LIVE_ANNOUNCER_PROVIDER = {\x0a    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\x0a    provide: LiveAnnouncer,\x0a    deps: [\x0a        [new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Optional\x22](), new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22SkipSelf\x22](), LiveAnnouncer],\x0a        [new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Optional\x22](), new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Inject\x22](LIVE_ANNOUNCER_ELEMENT_TOKEN)],\x0a        _angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22DOCUMENT\x22],\x0a        _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgZone\x22],\x0a    ],\x0a    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\x0a};\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/** @type {?} */\x0avar TOUCH_BUFFER_MS = 650;\x0a/**\x0a * Monitors mouse and keyboard events to determine the cause of focus events.\x0a */\x0avar FocusMonitor = /** @class */ (function () {\x0a    function FocusMonitor(_ngZone, _platform) {\x0a        this._ngZone = _ngZone;\x0a        this._platform = _platform;\x0a        /**\x0a         * The focus origin that the next focus event is a result of.\x0a         */\x0a        this._origin = null;\x0a        /**\x0a         * Whether the window has just been focused.\x0a         */\x0a        this._windowFocused = false;\x0a        /**\x0a         * Map of elements being monitored to their info.\x0a         */\x0a        this._elementInfo = new Map();\x0a        /**\x0a         * A map of global objects to lists of current listeners.\x0a         */\x0a        this._unregisterGlobalListeners = function () { };\x0a        /**\x0a         * The number of elements currently being monitored.\x0a         */\x0a        this._monitoredElementCount = 0;\x0a    }\x0a    /**\x0a     * @param {?} element\x0a     * @param {?=} checkChildren\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype.monitor = /**\x0a     * @param {?} element\x0a     * @param {?=} checkChildren\x0a     * @return {?}\x0a     */\x0a    function (element, checkChildren) {\x0a        var _this = this;\x0a        if (checkChildren === void 0) { checkChildren = false; }\x0a        // Do nothing if we\x27re not on the browser platform.\x0a        if (!this._platform.isBrowser) {\x0a            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[\x22of\x22])(null);\x0a        }\x0a        /** @type {?} */\x0a        var nativeElement = this._getNativeElement(element);\x0a        // Check if we\x27re already monitoring this element.\x0a        if (this._elementInfo.has(nativeElement)) {\x0a            /** @type {?} */\x0a            var cachedInfo = this._elementInfo.get(nativeElement); /** @type {?} */\x0a            ((cachedInfo)).checkChildren = checkChildren;\x0a            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\x0a        }\x0a        /** @type {?} */\x0a        var info = {\x0a            unlisten: function () { },\x0a            checkChildren: checkChildren,\x0a            subject: new rxjs__WEBPACK_IMPORTED_MODULE_2__[\x22Subject\x22]()\x0a        };\x0a        this._elementInfo.set(nativeElement, info);\x0a        this._incrementMonitoredElementCount();\x0a        /** @type {?} */\x0a        var focusListener = function (event) { return _this._onFocus(event, nativeElement); };\x0a        /** @type {?} */\x0a        var blurListener = function (event) { return _this._onBlur(event, nativeElement); };\x0a        this._ngZone.runOutsideAngular(function () {\x0a            nativeElement.addEventListener(\x27focus\x27, focusListener, true);\x0a            nativeElement.addEventListener(\x27blur\x27, blurListener, true);\x0a        });\x0a        // Create an unlisten function for later.\x0a        info.unlisten = function () {\x0a            nativeElement.removeEventListener(\x27focus\x27, focusListener, true);\x0a            nativeElement.removeEventListener(\x27blur\x27, blurListener, true);\x0a        };\x0a        return info.subject.asObservable();\x0a    };\x0a    /**\x0a     * @param {?} element\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype.stopMonitoring = /**\x0a     * @param {?} element\x0a     * @return {?}\x0a     */\x0a    function (element) {\x0a        /** @type {?} */\x0a        var nativeElement = this._getNativeElement(element);\x0a        /** @type {?} */\x0a        var elementInfo = this._elementInfo.get(nativeElement);\x0a        if (elementInfo) {\x0a            elementInfo.unlisten();\x0a            elementInfo.subject.complete();\x0a            this._setClasses(nativeElement);\x0a            this._elementInfo.delete(nativeElement);\x0a            this._decrementMonitoredElementCount();\x0a        }\x0a    };\x0a    /**\x0a     * @param {?} element\x0a     * @param {?} origin\x0a     * @param {?=} options\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype.focusVia = /**\x0a     * @param {?} element\x0a     * @param {?} origin\x0a     * @param {?=} options\x0a     * @return {?}\x0a     */\x0a    function (element, origin, options) {\x0a        /** @type {?} */\x0a        var nativeElement = this._getNativeElement(element);\x0a        this._setOriginForCurrentEventQueue(origin);\x0a        // `focus` isn\x27t available on the server\x0a        if (typeof nativeElement.focus === \x27function\x27) {\x0a            // Cast the element to `any`, because the TS typings don\x27t have the `options` parameter yet.\x0a            (/** @type {?} */ (nativeElement)).focus(options);\x0a        }\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype.ngOnDestroy = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        var _this = this;\x0a        this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });\x0a    };\x0a    /**\x0a     * Register necessary event listeners on the document and window.\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype._registerGlobalListeners = /**\x0a     * Register necessary event listeners on the document and window.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        var _this = this;\x0a        // Do nothing if we\x27re not on the browser platform.\x0a        if (!this._platform.isBrowser) {\x0a            return;\x0a        }\x0a        /** @type {?} */\x0a        var documentKeydownListener = function () {\x0a            _this._lastTouchTarget = null;\x0a            _this._setOriginForCurrentEventQueue(\x27keyboard\x27);\x0a        };\x0a        /** @type {?} */\x0a        var documentMousedownListener = function () {\x0a            if (!_this._lastTouchTarget) {\x0a                _this._setOriginForCurrentEventQueue(\x27mouse\x27);\x0a            }\x0a        };\x0a        /** @type {?} */\x0a        var documentTouchstartListener = function (event) {\x0a            if (_this._touchTimeoutId != null) {\x0a                clearTimeout(_this._touchTimeoutId);\x0a            }\x0a            _this._lastTouchTarget = event.target;\x0a            _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\x0a        };\x0a        /** @type {?} */\x0a        var windowFocusListener = function () {\x0a            _this._windowFocused = true;\x0a            _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; });\x0a        };\x0a        /** @type {?} */\x0a        var captureEventListenerOptions = Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__[\x22normalizePassiveListenerOptions\x22])({\x0a            passive: true,\x0a            capture: true\x0a        });\x0a        // Note: we listen to events in the capture phase so we can detect them even if the user stops\x0a        // propagation.\x0a        this._ngZone.runOutsideAngular(function () {\x0a            document.addEventListener(\x27keydown\x27, documentKeydownListener, captureEventListenerOptions);\x0a            document.addEventListener(\x27mousedown\x27, documentMousedownListener, captureEventListenerOptions);\x0a            document.addEventListener(\x27touchstart\x27, documentTouchstartListener, captureEventListenerOptions);\x0a            window.addEventListener(\x27focus\x27, windowFocusListener);\x0a        });\x0a        this._unregisterGlobalListeners = function () {\x0a            document.removeEventListener(\x27keydown\x27, documentKeydownListener, captureEventListenerOptions);\x0a            document.removeEventListener(\x27mousedown\x27, documentMousedownListener, captureEventListenerOptions);\x0a            document.removeEventListener(\x27touchstart\x27, documentTouchstartListener, captureEventListenerOptions);\x0a            window.removeEventListener(\x27focus\x27, windowFocusListener);\x0a            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\x0a            clearTimeout(_this._windowFocusTimeoutId);\x0a            clearTimeout(_this._touchTimeoutId);\x0a            clearTimeout(_this._originTimeoutId);\x0a        };\x0a    };\x0a    /**\x0a     * @param {?} element\x0a     * @param {?} className\x0a     * @param {?} shouldSet\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype._toggleClass = /**\x0a     * @param {?} element\x0a     * @param {?} className\x0a     * @param {?} shouldSet\x0a     * @return {?}\x0a     */\x0a    function (element, className, shouldSet) {\x0a        if (shouldSet) {\x0a            element.classList.add(className);\x0a        }\x0a        else {\x0a            element.classList.remove(className);\x0a        }\x0a    };\x0a    /**\x0a     * Sets the focus classes on the element based on the given focus origin.\x0a     * @param {?} element The element to update the classes on.\x0a     * @param {?=} origin The focus origin.\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype._setClasses = /**\x0a     * Sets the focus classes on the element based on the given focus origin.\x0a     * @param {?} element The element to update the classes on.\x0a     * @param {?=} origin The focus origin.\x0a     * @return {?}\x0a     */\x0a    function (element, origin) {\x0a        /** @type {?} */\x0a        var elementInfo = this._elementInfo.get(element);\x0a        if (elementInfo) {\x0a            this._toggleClass(element, \x27cdk-focused\x27, !!origin);\x0a            this._toggleClass(element, \x27cdk-touch-focused\x27, origin === \x27touch\x27);\x0a            this._toggleClass(element, \x27cdk-keyboard-focused\x27, origin === \x27keyboard\x27);\x0a            this._toggleClass(element, \x27cdk-mouse-focused\x27, origin === \x27mouse\x27);\x0a            this._toggleClass(element, \x27cdk-program-focused\x27, origin === \x27program\x27);\x0a        }\x0a    };\x0a    /**\x0a     * Sets the origin and schedules an async function to clear it at the end of the event queue.\x0a     * @param {?} origin The origin to set.\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\x0a     * Sets the origin and schedules an async function to clear it at the end of the event queue.\x0a     * @param {?} origin The origin to set.\x0a     * @return {?}\x0a     */\x0a    function (origin) {\x0a        var _this = this;\x0a        this._ngZone.runOutsideAngular(function () {\x0a            _this._origin = origin;\x0a            // Sometimes the focus origin won\x27t be valid in Firefox because Firefox seems to focus *one*\x0a            // tick after the interaction event fired. To ensure the focus origin is always correct,\x0a            // the focus origin will be determined at the beginning of the next tick.\x0a            _this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 1);\x0a        });\x0a    };\x0a    /**\x0a     * Checks whether the given focus event was caused by a touchstart event.\x0a     * @param {?} event The focus event to check.\x0a     * @return {?} Whether the event was caused by a touch.\x0a     */\x0a    FocusMonitor.prototype._wasCausedByTouch = /**\x0a     * Checks whether the given focus event was caused by a touchstart event.\x0a     * @param {?} event The focus event to check.\x0a     * @return {?} Whether the event was caused by a touch.\x0a     */\x0a    function (event) {\x0a        /** @type {?} */\x0a        var focusTarget = event.target;\x0a        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\x0a            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\x0a    };\x0a    /**\x0a     * Handles focus events on a registered element.\x0a     * @param {?} event The focus event.\x0a     * @param {?} element The monitored element.\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype._onFocus = /**\x0a     * Handles focus events on a registered element.\x0a     * @param {?} event The focus event.\x0a     * @param {?} element The monitored element.\x0a     * @return {?}\x0a     */\x0a    function (event, element) {\x0a        /** @type {?} */\x0a        var elementInfo = this._elementInfo.get(element);\x0a        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\x0a            return;\x0a        }\x0a        /** @type {?} */\x0a        var origin = this._origin;\x0a        if (!origin) {\x0a            if (this._windowFocused && this._lastFocusOrigin) {\x0a                origin = this._lastFocusOrigin;\x0a            }\x0a            else if (this._wasCausedByTouch(event)) {\x0a                origin = \x27touch\x27;\x0a            }\x0a            else {\x0a                origin = \x27program\x27;\x0a            }\x0a        }\x0a        this._setClasses(element, origin);\x0a        this._emitOrigin(elementInfo.subject, origin);\x0a        this._lastFocusOrigin = origin;\x0a    };\x0a    /**\x0a     * Handles blur events on a registered element.\x0a     * @param event The blur event.\x0a     * @param element The monitored element.\x0a     */\x0a    /**\x0a     * Handles blur events on a registered element.\x0a     * @param {?} event The blur event.\x0a     * @param {?} element The monitored element.\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype._onBlur = /**\x0a     * Handles blur events on a registered element.\x0a     * @param {?} event The blur event.\x0a     * @param {?} element The monitored element.\x0a     * @return {?}\x0a     */\x0a    function (event, element) {\x0a        /** @type {?} */\x0a        var elementInfo = this._elementInfo.get(element);\x0a        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\x0a            element.contains(event.relatedTarget))) {\x0a            return;\x0a        }\x0a        this._setClasses(element);\x0a        this._emitOrigin(elementInfo.subject, null);\x0a    };\x0a    /**\x0a     * @param {?} subject\x0a     * @param {?} origin\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype._emitOrigin = /**\x0a     * @param {?} subject\x0a     * @param {?} origin\x0a     * @return {?}\x0a     */\x0a    function (subject, origin) {\x0a        this._ngZone.run(function () { return subject.next(origin); });\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype._incrementMonitoredElementCount = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        // Register global listeners when first element is monitored.\x0a        if (++this._monitoredElementCount == 1) {\x0a            this._registerGlobalListeners();\x0a        }\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype._decrementMonitoredElementCount = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        // Unregister global listeners when last element is unmonitored.\x0a        if (!--this._monitoredElementCount) {\x0a            this._unregisterGlobalListeners();\x0a            this._unregisterGlobalListeners = function () { };\x0a        }\x0a    };\x0a    /**\x0a     * @param {?} element\x0a     * @return {?}\x0a     */\x0a    FocusMonitor.prototype._getNativeElement = /**\x0a     * @param {?} element\x0a     * @return {?}\x0a     */\x0a    function (element) {\x0a        return element instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22ElementRef\x22] ? element.nativeElement : element;\x0a    };\x0a    FocusMonitor.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Injectable\x22], args: [{ providedIn: \x27root\x27 },] },\x0a    ];\x0a    /** @nocollapse */\x0a    FocusMonitor.ctorParameters = function () { return [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgZone\x22] },\x0a        { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__[\x22Platform\x22] }\x0a    ]; };\x0a    /** @nocollapse */ FocusMonitor.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22defineInjectable\x22])({ factory: function FocusMonitor_Factory() { return new FocusMonitor(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgZone\x22]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__[\x22Platform\x22])); }, token: FocusMonitor, providedIn: \x22root\x22 });\x0a    return FocusMonitor;\x0a}());\x0a/**\x0a * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\x0a * programmatically) and adds corresponding classes to the element.\x0a *\x0a * There are two variants of this directive:\x0a * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\x0a *    focused.\x0a * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\x0a */\x0avar CdkMonitorFocus = /** @class */ (function () {\x0a    function CdkMonitorFocus(_elementRef, _focusMonitor) {\x0a        var _this = this;\x0a        this._elementRef = _elementRef;\x0a        this._focusMonitor = _focusMonitor;\x0a        this.cdkFocusChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22EventEmitter\x22]();\x0a        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef, this._elementRef.nativeElement.hasAttribute(\x27cdkMonitorSubtreeFocus\x27))\x0a            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\x0a    }\x0a    /**\x0a     * @return {?}\x0a     */\x0a    CdkMonitorFocus.prototype.ngOnDestroy = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._focusMonitor.stopMonitoring(this._elementRef);\x0a        this._monitorSubscription.unsubscribe();\x0a    };\x0a    CdkMonitorFocus.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Directive\x22], args: [{\x0a                    selector: \x27[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]\x27,\x0a                },] },\x0a    ];\x0a    /** @nocollapse */\x0a    CdkMonitorFocus.ctorParameters = function () { return [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22ElementRef\x22] },\x0a        { type: FocusMonitor }\x0a    ]; };\x0a    CdkMonitorFocus.propDecorators = {\x0a        cdkFocusChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Output\x22] }]\x0a    };\x0a    return CdkMonitorFocus;\x0a}());\x0a/**\x0a * \x5c@docs-private \x5c@deprecated \x5c@breaking-change 8.0.0\x0a * @param {?} parentDispatcher\x0a * @param {?} ngZone\x0a * @param {?} platform\x0a * @return {?}\x0a */\x0afunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\x0a    return parentDispatcher || new FocusMonitor(ngZone, platform);\x0a}\x0a/** *\x0a * \x5c@docs-private \x5c@deprecated \x5c@breaking-change 8.0.0\x0a  @type {?} */\x0avar FOCUS_MONITOR_PROVIDER = {\x0a    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\x0a    provide: FocusMonitor,\x0a    deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Optional\x22](), new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22SkipSelf\x22](), FocusMonitor], _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgZone\x22], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__[\x22Platform\x22]],\x0a    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\x0a};\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * Screenreaders will often fire fake mousedown events when a focusable element\x0a * is activated using the keyboard. We can typically distinguish between these faked\x0a * mousedown events and real mousedown events using the \x22buttons\x22 property. While\x0a * real mousedowns will indicate the mouse button that was pressed (e.g. \x221\x22 for\x0a * the left mouse button), faked mousedowns will usually set the property value to 0.\x0a * @param {?} event\x0a * @return {?}\x0a */\x0afunction isFakeMousedownFromScreenReader(event) {\x0a    return event.buttons === 0;\x0a}\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0avar A11yModule = /** @class */ (function () {\x0a    function A11yModule() {\x0a    }\x0a    A11yModule.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgModule\x22], args: [{\x0a                    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22CommonModule\x22], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__[\x22PlatformModule\x22], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_8__[\x22ObserversModule\x22]],\x0a                    declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\x0a                    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\x0a                },] },\x0a    ];\x0a    return A11yModule;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a\x0a//# sourceMappingURL=a11y.es5.js.map\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/@angular/cdk/esm5/accordion.es5.js\x22:\x0a/*!*********************************************************!*\x5c\x0a  !*** ./node_modules/@angular/cdk/esm5/accordion.es5.js ***!\x0a  \x5c*********************************************************/\x0a/*! exports provided: CdkAccordionItem, CdkAccordion, CdkAccordionModule */\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22CdkAccordionItem\x22, function() { return CdkAccordionItem; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22CdkAccordion\x22, function() { return CdkAccordion; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22CdkAccordionModule\x22, function() { return CdkAccordionModule; });\x0a/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ \x22./node_modules/@angular/cdk/esm5/coercion.es5.js\x22);\x0a/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \x22./node_modules/@angular/core/fesm5/core.js\x22);\x0a/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \x22./node_modules/rxjs/_esm5/index.js\x22);\x0a/* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/collections */ \x22./node_modules/@angular/cdk/esm5/collections.es5.js\x22);\x0a/**\x0a * @license\x0a * Copyright Google LLC All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a\x0a\x0a\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/** *\x0a * Used to generate unique ID for each accordion.\x0a  @type {?} */\x0avar nextId = 0;\x0a/**\x0a * Directive whose purpose is to manage the expanded state of CdkAccordionItem children.\x0a */\x0avar CdkAccordion = /** @class */ (function () {\x0a    function CdkAccordion() {\x0a        /**\x0a         * Emits when the state of the accordion changes\x0a         */\x0a        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\x22Subject\x22]();\x0a        /**\x0a         * Stream that emits true/false when openAll/closeAll is triggered.\x0a         */\x0a        this._openCloseAllActions = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\x22Subject\x22]();\x0a        /**\x0a         * A readonly id value to use for unique selection coordination.\x0a         */\x0a        this.id = \x22cdk-accordion-\x22 + nextId++;\x0a        this._multi = false;\x0a    }\x0a    Object.defineProperty(CdkAccordion.prototype, \x22multi\x22, {\x0a        /** Whether the accordion should allow multiple expanded accordion items simultaneously. */\x0a        get: /**\x0a         * Whether the accordion should allow multiple expanded accordion items simultaneously.\x0a         * @return {?}\x0a         */\x0a        function () { return this._multi; },\x0a        set: /**\x0a         * @param {?} multi\x0a         * @return {?}\x0a         */\x0a        function (multi) { this._multi = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__[\x22coerceBooleanProperty\x22])(multi); },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    /** Opens all enabled accordion items in an accordion where multi is enabled. */\x0a    /**\x0a     * Opens all enabled accordion items in an accordion where multi is enabled.\x0a     * @return {?}\x0a     */\x0a    CdkAccordion.prototype.openAll = /**\x0a     * Opens all enabled accordion items in an accordion where multi is enabled.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._openCloseAll(true);\x0a    };\x0a    /** Closes all enabled accordion items in an accordion where multi is enabled. */\x0a    /**\x0a     * Closes all enabled accordion items in an accordion where multi is enabled.\x0a     * @return {?}\x0a     */\x0a    CdkAccordion.prototype.closeAll = /**\x0a     * Closes all enabled accordion items in an accordion where multi is enabled.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._openCloseAll(false);\x0a    };\x0a    /**\x0a     * @param {?} changes\x0a     * @return {?}\x0a     */\x0a    CdkAccordion.prototype.ngOnChanges = /**\x0a     * @param {?} changes\x0a     * @return {?}\x0a     */\x0a    function (changes) {\x0a        this._stateChanges.next(changes);\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    CdkAccordion.prototype.ngOnDestroy = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._stateChanges.complete();\x0a    };\x0a    /**\x0a     * @param {?} expanded\x0a     * @return {?}\x0a     */\x0a    CdkAccordion.prototype._openCloseAll = /**\x0a     * @param {?} expanded\x0a     * @return {?}\x0a     */\x0a    function (expanded) {\x0a        if (this.multi) {\x0a            this._openCloseAllActions.next(expanded);\x0a        }\x0a    };\x0a    CdkAccordion.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Directive\x22], args: [{\x0a                    selector: \x27cdk-accordion, [cdkAccordion]\x27,\x0a                    exportAs: \x27cdkAccordion\x27,\x0a                },] },\x0a    ];\x0a    CdkAccordion.propDecorators = {\x0a        multi: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Input\x22] }]\x0a    };\x0a    return CdkAccordion;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/** *\x0a * Used to generate unique ID for each accordion item.\x0a  @type {?} */\x0avar nextId$1 = 0;\x0avar \xc9\xb50 = undefined;\x0a/**\x0a * An basic directive expected to be extended and decorated as a component.  Sets up all\x0a * events and attributes needed to be managed by a CdkAccordion parent.\x0a */\x0avar CdkAccordionItem = /** @class */ (function () {\x0a    function CdkAccordionItem(accordion, _changeDetectorRef, _expansionDispatcher) {\x0a        var _this = this;\x0a        this.accordion = accordion;\x0a        this._changeDetectorRef = _changeDetectorRef;\x0a        this._expansionDispatcher = _expansionDispatcher;\x0a        /**\x0a         * Subscription to openAll/closeAll events.\x0a         */\x0a        this._openCloseAllSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__[\x22Subscription\x22].EMPTY;\x0a        /**\x0a         * Event emitted every time the AccordionItem is closed.\x0a         */\x0a        this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22EventEmitter\x22]();\x0a        /**\x0a         * Event emitted every time the AccordionItem is opened.\x0a         */\x0a        this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22EventEmitter\x22]();\x0a        /**\x0a         * Event emitted when the AccordionItem is destroyed.\x0a         */\x0a        this.destroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22EventEmitter\x22]();\x0a        /**\x0a         * Emits whenever the expanded state of the accordion changes.\x0a         * Primarily used to facilitate two-way binding.\x0a         * \x5c@docs-private\x0a         */\x0a        this.expandedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22EventEmitter\x22]();\x0a        /**\x0a         * The unique AccordionItem id.\x0a         */\x0a        this.id = \x22cdk-accordion-child-\x22 + nextId$1++;\x0a        this._expanded = false;\x0a        this._disabled = false;\x0a        /**\x0a         * Unregister function for _expansionDispatcher.\x0a         */\x0a        this._removeUniqueSelectionListener = function () { };\x0a        this._removeUniqueSelectionListener =\x0a            _expansionDispatcher.listen(function (id, accordionId) {\x0a                if (_this.accordion && !_this.accordion.multi &&\x0a                    _this.accordion.id === accordionId && _this.id !== id) {\x0a                    _this.expanded = false;\x0a                }\x0a            });\x0a        // When an accordion item is hosted in an accordion, subscribe to open/close events.\x0a        if (this.accordion) {\x0a            this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions();\x0a        }\x0a    }\x0a    Object.defineProperty(CdkAccordionItem.prototype, \x22expanded\x22, {\x0a        /** Whether the AccordionItem is expanded. */\x0a        get: /**\x0a         * Whether the AccordionItem is expanded.\x0a         * @return {?}\x0a         */\x0a        function () { return this._expanded; },\x0a        set: /**\x0a         * @param {?} expanded\x0a         * @return {?}\x0a         */\x0a        function (expanded) {\x0a            expanded = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__[\x22coerceBooleanProperty\x22])(expanded);\x0a            // Only emit events and update the internal value if the value changes.\x0a            if (this._expanded !== expanded) {\x0a                this._expanded = expanded;\x0a                this.expandedChange.emit(expanded);\x0a                if (expanded) {\x0a                    this.opened.emit();\x0a                    /** *\x0a                     * In the unique selection dispatcher, the id parameter is the id of the CdkAccordionItem,\x0a                     * the name value is the id of the accordion.\x0a                      @type {?} */\x0a                    var accordionId = this.accordion ? this.accordion.id : this.id;\x0a                    this._expansionDispatcher.notify(this.id, accordionId);\x0a                }\x0a                else {\x0a                    this.closed.emit();\x0a                }\x0a                // Ensures that the animation will run when the value is set outside of an `@Input`.\x0a                // This includes cases like the open, close and toggle methods.\x0a                this._changeDetectorRef.markForCheck();\x0a            }\x0a        },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    Object.defineProperty(CdkAccordionItem.prototype, \x22disabled\x22, {\x0a        /** Whether the AccordionItem is disabled. */\x0a        get: /**\x0a         * Whether the AccordionItem is disabled.\x0a         * @return {?}\x0a         */\x0a        function () { return this._disabled; },\x0a        set: /**\x0a         * @param {?} disabled\x0a         * @return {?}\x0a         */\x0a        function (disabled) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__[\x22coerceBooleanProperty\x22])(disabled); },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    /** Emits an event for the accordion item being destroyed. */\x0a    /**\x0a     * Emits an event for the accordion item being destroyed.\x0a     * @return {?}\x0a     */\x0a    CdkAccordionItem.prototype.ngOnDestroy = /**\x0a     * Emits an event for the accordion item being destroyed.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this.opened.complete();\x0a        this.closed.complete();\x0a        this.destroyed.emit();\x0a        this.destroyed.complete();\x0a        this._removeUniqueSelectionListener();\x0a        this._openCloseAllSubscription.unsubscribe();\x0a    };\x0a    /** Toggles the expanded state of the accordion item. */\x0a    /**\x0a     * Toggles the expanded state of the accordion item.\x0a     * @return {?}\x0a     */\x0a    CdkAccordionItem.prototype.toggle = /**\x0a     * Toggles the expanded state of the accordion item.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        if (!this.disabled) {\x0a            this.expanded = !this.expanded;\x0a        }\x0a    };\x0a    /** Sets the expanded state of the accordion item to false. */\x0a    /**\x0a     * Sets the expanded state of the accordion item to false.\x0a     * @return {?}\x0a     */\x0a    CdkAccordionItem.prototype.close = /**\x0a     * Sets the expanded state of the accordion item to false.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        if (!this.disabled) {\x0a            this.expanded = false;\x0a        }\x0a    };\x0a    /** Sets the expanded state of the accordion item to true. */\x0a    /**\x0a     * Sets the expanded state of the accordion item to true.\x0a     * @return {?}\x0a     */\x0a    CdkAccordionItem.prototype.open = /**\x0a     * Sets the expanded state of the accordion item to true.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        if (!this.disabled) {\x0a            this.expanded = true;\x0a        }\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    CdkAccordionItem.prototype._subscribeToOpenCloseAllActions = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        var _this = this;\x0a        return this.accordion._openCloseAllActions.subscribe(function (expanded) {\x0a            // Only change expanded state if item is enabled\x0a            if (!_this.disabled) {\x0a                _this.expanded = expanded;\x0a            }\x0a        });\x0a    };\x0a    CdkAccordionItem.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Directive\x22], args: [{\x0a                    selector: \x27cdk-accordion-item, [cdkAccordionItem]\x27,\x0a                    exportAs: \x27cdkAccordionItem\x27,\x0a                    providers: [\x0a                        // Provide CdkAccordion as undefined to prevent nested accordion items from registering\x0a                        // to the same accordion.\x0a                        { provide: CdkAccordion, useValue: \xc9\xb50 },\x0a                    ],\x0a                },] },\x0a    ];\x0a    /** @nocollapse */\x0a    CdkAccordionItem.ctorParameters = function () { return [\x0a        { type: CdkAccordion, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Optional\x22] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22SkipSelf\x22] }] },\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22ChangeDetectorRef\x22] },\x0a        { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__[\x22UniqueSelectionDispatcher\x22] }\x0a    ]; };\x0a    CdkAccordionItem.propDecorators = {\x0a        closed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Output\x22] }],\x0a        opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Output\x22] }],\x0a        destroyed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Output\x22] }],\x0a        expandedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Output\x22] }],\x0a        expanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Input\x22] }],\x0a        disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Input\x22] }]\x0a    };\x0a    return CdkAccordionItem;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0avar CdkAccordionModule = /** @class */ (function () {\x0a    function CdkAccordionModule() {\x0a    }\x0a    CdkAccordionModule.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgModule\x22], args: [{\x0a                    exports: [CdkAccordion, CdkAccordionItem],\x0a                    declarations: [CdkAccordion, CdkAccordionItem],\x0a                },] },\x0a    ];\x0a    return CdkAccordionModule;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a\x0a//# sourceMappingURL=accordion.es5.js.map\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/@angular/cdk/esm5/bidi.es5.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/@angular/cdk/esm5/bidi.es5.js ***!\x0a  \x5c****************************************************/\x0a/*! exports provided: Directionality, DIR_DOCUMENT, Dir, BidiModule, \xc9\xb5a */\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22Directionality\x22, function() { return Directionality; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22DIR_DOCUMENT\x22, function() { return DIR_DOCUMENT; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22Dir\x22, function() { return Dir; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22BidiModule\x22, function() { return BidiModule; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22\xc9\xb5a\x22, function() { return DIR_DOCUMENT_FACTORY; });\x0a/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/common */ \x22./node_modules/@angular/common/fesm5/common.js\x22);\x0a/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \x22./node_modules/@angular/core/fesm5/core.js\x22);\x0a/**\x0a * @license\x0a * Copyright Google LLC All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/** *\x0a * Injection token used to inject the document into Directionality.\x0a * This is used so that the value can be faked in tests.\x0a *\x0a * We can\x27t use the real document in tests because changing the real `dir` causes geometry-based\x0a * tests in Safari to fail.\x0a *\x0a * We also can\x27t re-provide the DOCUMENT token from platform-brower because the unit tests\x0a * themselves use things like `querySelector` in test code.\x0a *\x0a * This token is defined in a separate file from Directionality as a workaround for\x0a * https://github.com/angular/angular/issues/22559\x0a *\x0a * \x5c@docs-private\x0a  @type {?} */\x0avar DIR_DOCUMENT = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22InjectionToken\x22](\x27cdk-dir-doc\x27, {\x0a    providedIn: \x27root\x27,\x0a    factory: DIR_DOCUMENT_FACTORY,\x0a});\x0a/**\x0a * \x5c@docs-private\x0a * @return {?}\x0a */\x0afunction DIR_DOCUMENT_FACTORY() {\x0a    return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(_angular_common__WEBPACK_IMPORTED_MODULE_0__[\x22DOCUMENT\x22]);\x0a}\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/**\x0a * The directionality (LTR / RTL) context for the application (or a subtree of it).\x0a * Exposes the current direction and a stream of direction changes.\x0a */\x0avar Directionality = /** @class */ (function () {\x0a    function Directionality(_document) {\x0a        /**\x0a         * The current \x27ltr\x27 or \x27rtl\x27 value.\x0a         */\x0a        this.value = \x27ltr\x27;\x0a        /**\x0a         * Stream that emits whenever the \x27ltr\x27 / \x27rtl\x27 state changes.\x0a         */\x0a        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22EventEmitter\x22]();\x0a        if (_document) {\x0a            /** @type {?} */\x0a            var bodyDir = _document.body ? _document.body.dir : null;\x0a            /** @type {?} */\x0a            var htmlDir = _document.documentElement ? _document.documentElement.dir : null;\x0a            /** @type {?} */\x0a            var value = bodyDir || htmlDir;\x0a            this.value = (value === \x27ltr\x27 || value === \x27rtl\x27) ? value : \x27ltr\x27;\x0a        }\x0a    }\x0a    /**\x0a     * @return {?}\x0a     */\x0a    Directionality.prototype.ngOnDestroy = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this.change.complete();\x0a    };\x0a    Directionality.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Injectable\x22], args: [{ providedIn: \x27root\x27 },] },\x0a    ];\x0a    /** @nocollapse */\x0a    Directionality.ctorParameters = function () { return [\x0a        { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Optional\x22] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Inject\x22], args: [DIR_DOCUMENT,] }] }\x0a    ]; };\x0a    /** @nocollapse */ Directionality.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22defineInjectable\x22])({ factory: function Directionality_Factory() { return new Directionality(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22inject\x22])(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: \x22root\x22 });\x0a    return Directionality;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/**\x0a * Directive to listen for changes of direction of part of the DOM.\x0a *\x0a * Provides itself as Directionality such that descendant directives only need to ever inject\x0a * Directionality to get the closest direction.\x0a */\x0avar Dir = /** @class */ (function () {\x0a    function Dir() {\x0a        this._dir = \x27ltr\x27;\x0a        /**\x0a         * Whether the `value` has been set to its initial value.\x0a         */\x0a        this._isInitialized = false;\x0a        /**\x0a         * Event emitted when the direction changes.\x0a         */\x0a        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22EventEmitter\x22]();\x0a    }\x0a    Object.defineProperty(Dir.prototype, \x22dir\x22, {\x0a        /** @docs-private */\x0a        get: /**\x0a         * \x5c@docs-private\x0a         * @return {?}\x0a         */\x0a        function () { return this._dir; },\x0a        set: /**\x0a         * @param {?} value\x0a         * @return {?}\x0a         */\x0a        function (value) {\x0a            /** @type {?} */\x0a            var old = this._dir;\x0a            this._dir = (value === \x27ltr\x27 || value === \x27rtl\x27) ? value : \x27ltr\x27;\x0a            if (old !== this._dir && this._isInitialized) {\x0a                this.change.emit(this._dir);\x0a            }\x0a        },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    Object.defineProperty(Dir.prototype, \x22value\x22, {\x0a        /** Current layout direction of the element. */\x0a        get: /**\x0a         * Current layout direction of the element.\x0a         * @return {?}\x0a         */\x0a        function () { return this.dir; },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    /** Initialize once default value has been set. */\x0a    /**\x0a     * Initialize once default value has been set.\x0a     * @return {?}\x0a     */\x0a    Dir.prototype.ngAfterContentInit = /**\x0a     * Initialize once default value has been set.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._isInitialized = true;\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    Dir.prototype.ngOnDestroy = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this.change.complete();\x0a    };\x0a    Dir.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Directive\x22], args: [{\x0a                    selector: \x27[dir]\x27,\x0a                    providers: [{ provide: Directionality, useExisting: Dir }],\x0a                    host: { \x27[dir]\x27: \x27dir\x27 },\x0a                    exportAs: \x27dir\x27,\x0a                },] },\x0a    ];\x0a    Dir.propDecorators = {\x0a        change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Output\x22], args: [\x27dirChange\x27,] }],\x0a        dir: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22Input\x22] }]\x0a    };\x0a    return Dir;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0avar BidiModule = /** @class */ (function () {\x0a    function BidiModule() {\x0a    }\x0a    BidiModule.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\x22NgModule\x22], args: [{\x0a                    exports: [Dir],\x0a                    declarations: [Dir],\x0a                },] },\x0a    ];\x0a    return BidiModule;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a\x0a//# sourceMappingURL=bidi.es5.js.map\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/@angular/cdk/esm5/coercion.es5.js\x22:\x0a/*!********************************************************!*\x5c\x0a  !*** ./node_modules/@angular/cdk/esm5/coercion.es5.js ***!\x0a  \x5c********************************************************/\x0a/*! exports provided: coerceBooleanProperty, coerceNumberProperty, _isNumberValue, coerceArray, coerceCssPixelValue */\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22coerceBooleanProperty\x22, function() { return coerceBooleanProperty; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22coerceNumberProperty\x22, function() { return coerceNumberProperty; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22_isNumberValue\x22, function() { return _isNumberValue; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22coerceArray\x22, function() { return coerceArray; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22coerceCssPixelValue\x22, function() { return coerceCssPixelValue; });\x0a/**\x0a * @license\x0a * Copyright Google LLC All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * Coerces a data-bound value (typically a string) to a boolean.\x0a * @param {?} value\x0a * @return {?}\x0a */\x0afunction coerceBooleanProperty(value) {\x0a    return value != null && \x22\x22 + value !== \x27false\x27;\x0a}\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * @param {?} value\x0a * @param {?=} fallbackValue\x0a * @return {?}\x0a */\x0afunction coerceNumberProperty(value, fallbackValue) {\x0a    if (fallbackValue === void 0) { fallbackValue = 0; }\x0a    return _isNumberValue(value) ? Number(value) : fallbackValue;\x0a}\x0a/**\x0a * Whether the provided value is considered a number.\x0a * \x5c@docs-private\x0a * @param {?} value\x0a * @return {?}\x0a */\x0afunction _isNumberValue(value) {\x0a    // parseFloat(value) handles most of the cases we\x27re interested in (it treats null, empty string,\x0a    // and other non-number values as NaN, where Number just uses 0) but it considers the string\x0a    // \x27123hello\x27 to be a valid number. Therefore we also check if Number(value) is NaN.\x0a    return !isNaN(parseFloat(/** @type {?} */ (value))) && !isNaN(Number(value));\x0a}\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * Wraps the provided value in an array, unless the provided value is an array.\x0a * @template T\x0a * @param {?} value\x0a * @return {?}\x0a */\x0afunction coerceArray(value) {\x0a    return Array.isArray(value) ? value : [value];\x0a}\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * Coerces a value to a CSS pixel value.\x0a * @param {?} value\x0a * @return {?}\x0a */\x0afunction coerceCssPixelValue(value) {\x0a    if (value == null) {\x0a        return \x27\x27;\x0a    }\x0a    return typeof value === \x27string\x27 ? value : value + \x22px\x22;\x0a}\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a\x0a//# sourceMappingURL=coercion.es5.js.map\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/@angular/cdk/esm5/collections.es5.js\x22:\x0a/*!***********************************************************!*\x5c\x0a  !*** ./node_modules/@angular/cdk/esm5/collections.es5.js ***!\x0a  \x5c***********************************************************/\x0a/*! exports provided: UniqueSelectionDispatcher, ArrayDataSource, DataSource, getMultipleValuesInSingleSelectionError, SelectionModel */\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22UniqueSelectionDispatcher\x22, function() { return UniqueSelectionDispatcher; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22ArrayDataSource\x22, function() { return ArrayDataSource; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22DataSource\x22, function() { return DataSource; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22getMultipleValuesInSingleSelectionError\x22, function() { return getMultipleValuesInSingleSelectionError; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22SelectionModel\x22, function() { return SelectionModel; });\x0a/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \x22./node_modules/tslib/tslib.es6.js\x22);\x0a/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ \x22./node_modules/rxjs/_esm5/index.js\x22);\x0a/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ \x22./node_modules/@angular/core/fesm5/core.js\x22);\x0a/**\x0a * @license\x0a * Copyright Google LLC All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a\x0a\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * @abstract\x0a * @template T\x0a */\x0avar  /**\x0a * @abstract\x0a * @template T\x0a */\x0aDataSource = /** @class */ (function () {\x0a    function DataSource() {\x0a    }\x0a    return DataSource;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/**\x0a * DataSource wrapper for a native array.\x0a * @template T\x0a */\x0avar  /**\x0a * DataSource wrapper for a native array.\x0a * @template T\x0a */\x0aArrayDataSource = /** @class */ (function (_super) {\x0a    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\x22__extends\x22])(ArrayDataSource, _super);\x0a    function ArrayDataSource(_data) {\x0a        var _this = _super.call(this) || this;\x0a        _this._data = _data;\x0a        return _this;\x0a    }\x0a    /**\x0a     * @return {?}\x0a     */\x0a    ArrayDataSource.prototype.connect = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        return this._data instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__[\x22Observable\x22] ? this._data : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[\x22of\x22])(this._data);\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    ArrayDataSource.prototype.disconnect = /**\x0a     * @return {?}\x0a     */\x0a    function () { };\x0a    return ArrayDataSource;\x0a}(DataSource));\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/**\x0a * Class to be used to power selecting one or more options from a list.\x0a * @template T\x0a */\x0avar  /**\x0a * Class to be used to power selecting one or more options from a list.\x0a * @template T\x0a */\x0aSelectionModel = /** @class */ (function () {\x0a    function SelectionModel(_multiple, initiallySelectedValues, _emitChanges) {\x0a        if (_multiple === void 0) { _multiple = false; }\x0a        if (_emitChanges === void 0) { _emitChanges = true; }\x0a        var _this = this;\x0a        this._multiple = _multiple;\x0a        this._emitChanges = _emitChanges;\x0a        /**\x0a         * Currently-selected values.\x0a         */\x0a        this._selection = new Set();\x0a        /**\x0a         * Keeps track of the deselected options that haven\x27t been emitted by the change event.\x0a         */\x0a        this._deselectedToEmit = [];\x0a        /**\x0a         * Keeps track of the selected options that haven\x27t been emitted by the change event.\x0a         */\x0a        this._selectedToEmit = [];\x0a        /**\x0a         * Event emitted when the value has changed.\x0a         */\x0a        this.changed = new rxjs__WEBPACK_IMPORTED_MODULE_1__[\x22Subject\x22]();\x0a        /**\x0a         * Event emitted when the value has changed.\x0a         * @deprecated Use `changed` instead.\x0a         * \x5c@breaking-change 8.0.0 To be changed to `changed`\x0a         */\x0a        this.onChange = this.changed;\x0a        if (initiallySelectedValues && initiallySelectedValues.length) {\x0a            if (_multiple) {\x0a                initiallySelectedValues.forEach(function (value) { return _this._markSelected(value); });\x0a            }\x0a            else {\x0a                this._markSelected(initiallySelectedValues[0]);\x0a            }\x0a            // Clear the array in order to avoid firing the change event for preselected values.\x0a            this._selectedToEmit.length = 0;\x0a        }\x0a    }\x0a    Object.defineProperty(SelectionModel.prototype, \x22selected\x22, {\x0a        /** Selected values. */\x0a        get: /**\x0a         * Selected values.\x0a         * @return {?}\x0a         */\x0a        function () {\x0a            if (!this._selected) {\x0a                this._selected = Array.from(this._selection.values());\x0a            }\x0a            return this._selected;\x0a        },\x0a        enumerable: true,\x0a        configurable: true\x0a    });\x0a    /**\x0a     * Selects a value or an array of values.\x0a     */\x0a    /**\x0a     * Selects a value or an array of values.\x0a     * @param {...?} values\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype.select = /**\x0a     * Selects a value or an array of values.\x0a     * @param {...?} values\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        var _this = this;\x0a        var values = [];\x0a        for (var _i = 0; _i \x3c arguments.length; _i++) {\x0a            values[_i] = arguments[_i];\x0a        }\x0a        this._verifyValueAssignment(values);\x0a        values.forEach(function (value) { return _this._markSelected(value); });\x0a        this._emitChangeEvent();\x0a    };\x0a    /**\x0a     * Deselects a value or an array of values.\x0a     */\x0a    /**\x0a     * Deselects a value or an array of values.\x0a     * @param {...?} values\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype.deselect = /**\x0a     * Deselects a value or an array of values.\x0a     * @param {...?} values\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        var _this = this;\x0a        var values = [];\x0a        for (var _i = 0; _i \x3c arguments.length; _i++) {\x0a            values[_i] = arguments[_i];\x0a        }\x0a        this._verifyValueAssignment(values);\x0a        values.forEach(function (value) { return _this._unmarkSelected(value); });\x0a        this._emitChangeEvent();\x0a    };\x0a    /**\x0a     * Toggles a value between selected and deselected.\x0a     */\x0a    /**\x0a     * Toggles a value between selected and deselected.\x0a     * @param {?} value\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype.toggle = /**\x0a     * Toggles a value between selected and deselected.\x0a     * @param {?} value\x0a     * @return {?}\x0a     */\x0a    function (value) {\x0a        this.isSelected(value) ? this.deselect(value) : this.select(value);\x0a    };\x0a    /**\x0a     * Clears all of the selected values.\x0a     */\x0a    /**\x0a     * Clears all of the selected values.\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype.clear = /**\x0a     * Clears all of the selected values.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._unmarkAll();\x0a        this._emitChangeEvent();\x0a    };\x0a    /**\x0a     * Determines whether a value is selected.\x0a     */\x0a    /**\x0a     * Determines whether a value is selected.\x0a     * @param {?} value\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype.isSelected = /**\x0a     * Determines whether a value is selected.\x0a     * @param {?} value\x0a     * @return {?}\x0a     */\x0a    function (value) {\x0a        return this._selection.has(value);\x0a    };\x0a    /**\x0a     * Determines whether the model does not have a value.\x0a     */\x0a    /**\x0a     * Determines whether the model does not have a value.\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype.isEmpty = /**\x0a     * Determines whether the model does not have a value.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        return this._selection.size === 0;\x0a    };\x0a    /**\x0a     * Determines whether the model has a value.\x0a     */\x0a    /**\x0a     * Determines whether the model has a value.\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype.hasValue = /**\x0a     * Determines whether the model has a value.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        return !this.isEmpty();\x0a    };\x0a    /**\x0a     * Sorts the selected values based on a predicate function.\x0a     */\x0a    /**\x0a     * Sorts the selected values based on a predicate function.\x0a     * @param {?=} predicate\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype.sort = /**\x0a     * Sorts the selected values based on a predicate function.\x0a     * @param {?=} predicate\x0a     * @return {?}\x0a     */\x0a    function (predicate) {\x0a        if (this._multiple && this.selected) {\x0a            /** @type {?} */ ((this._selected)).sort(predicate);\x0a        }\x0a    };\x0a    /**\x0a     * Gets whether multiple values can be selected.\x0a     */\x0a    /**\x0a     * Gets whether multiple values can be selected.\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype.isMultipleSelection = /**\x0a     * Gets whether multiple values can be selected.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        return this._multiple;\x0a    };\x0a    /**\x0a     * Emits a change event and clears the records of selected and deselected values.\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype._emitChangeEvent = /**\x0a     * Emits a change event and clears the records of selected and deselected values.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        // Clear the selected values so they can be re-cached.\x0a        this._selected = null;\x0a        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\x0a            this.changed.next({\x0a                source: this,\x0a                added: this._selectedToEmit,\x0a                removed: this._deselectedToEmit\x0a            });\x0a            this._deselectedToEmit = [];\x0a            this._selectedToEmit = [];\x0a        }\x0a    };\x0a    /**\x0a     * Selects a value.\x0a     * @param {?} value\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype._markSelected = /**\x0a     * Selects a value.\x0a     * @param {?} value\x0a     * @return {?}\x0a     */\x0a    function (value) {\x0a        if (!this.isSelected(value)) {\x0a            if (!this._multiple) {\x0a                this._unmarkAll();\x0a            }\x0a            this._selection.add(value);\x0a            if (this._emitChanges) {\x0a                this._selectedToEmit.push(value);\x0a            }\x0a        }\x0a    };\x0a    /**\x0a     * Deselects a value.\x0a     * @param {?} value\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype._unmarkSelected = /**\x0a     * Deselects a value.\x0a     * @param {?} value\x0a     * @return {?}\x0a     */\x0a    function (value) {\x0a        if (this.isSelected(value)) {\x0a            this._selection.delete(value);\x0a            if (this._emitChanges) {\x0a                this._deselectedToEmit.push(value);\x0a            }\x0a        }\x0a    };\x0a    /**\x0a     * Clears out the selected values.\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype._unmarkAll = /**\x0a     * Clears out the selected values.\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        var _this = this;\x0a        if (!this.isEmpty()) {\x0a            this._selection.forEach(function (value) { return _this._unmarkSelected(value); });\x0a        }\x0a    };\x0a    /**\x0a     * Verifies the value assignment and throws an error if the specified value array is\x0a     * including multiple values while the selection model is not supporting multiple values.\x0a     * @param {?} values\x0a     * @return {?}\x0a     */\x0a    SelectionModel.prototype._verifyValueAssignment = /**\x0a     * Verifies the value assignment and throws an error if the specified value array is\x0a     * including multiple values while the selection model is not supporting multiple values.\x0a     * @param {?} values\x0a     * @return {?}\x0a     */\x0a    function (values) {\x0a        if (values.length \x3e 1 && !this._multiple) {\x0a            throw getMultipleValuesInSingleSelectionError();\x0a        }\x0a    };\x0a    return SelectionModel;\x0a}());\x0a/**\x0a * Returns an error that reports that multiple values are passed into a selection model\x0a * with a single value.\x0a * \x5c@docs-private\x0a * @return {?}\x0a */\x0afunction getMultipleValuesInSingleSelectionError() {\x0a    return Error(\x27Cannot pass multiple values into SelectionModel with single-value mode.\x27);\x0a}\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a/**\x0a * Class to coordinate unique selection based on name.\x0a * Intended to be consumed as an Angular service.\x0a * This service is needed because native radio change events are only fired on the item currently\x0a * being selected, and we still need to uncheck the previous selection.\x0a *\x0a * This service does not *store* any IDs and names because they may change at any time, so it is\x0a * less error-prone if they are simply passed through when the events occur.\x0a */\x0avar UniqueSelectionDispatcher = /** @class */ (function () {\x0a    function UniqueSelectionDispatcher() {\x0a        this._listeners = [];\x0a    }\x0a    /**\x0a     * Notify other items that selection for the given name has been set.\x0a     * @param id ID of the item.\x0a     * @param name Name of the item.\x0a     */\x0a    /**\x0a     * Notify other items that selection for the given name has been set.\x0a     * @param {?} id ID of the item.\x0a     * @param {?} name Name of the item.\x0a     * @return {?}\x0a     */\x0a    UniqueSelectionDispatcher.prototype.notify = /**\x0a     * Notify other items that selection for the given name has been set.\x0a     * @param {?} id ID of the item.\x0a     * @param {?} name Name of the item.\x0a     * @return {?}\x0a     */\x0a    function (id, name) {\x0a        for (var _i = 0, _a = this._listeners; _i \x3c _a.length; _i++) {\x0a            var listener = _a[_i];\x0a            listener(id, name);\x0a        }\x0a    };\x0a    /**\x0a     * Listen for future changes to item selection.\x0a     * @return Function used to deregister listener\x0a     */\x0a    /**\x0a     * Listen for future changes to item selection.\x0a     * @param {?} listener\x0a     * @return {?} Function used to deregister listener\x0a     */\x0a    UniqueSelectionDispatcher.prototype.listen = /**\x0a     * Listen for future changes to item selection.\x0a     * @param {?} listener\x0a     * @return {?} Function used to deregister listener\x0a     */\x0a    function (listener) {\x0a        var _this = this;\x0a        this._listeners.push(listener);\x0a        return function () {\x0a            _this._listeners = _this._listeners.filter(function (registered) {\x0a                return listener !== registered;\x0a            });\x0a        };\x0a    };\x0a    /**\x0a     * @return {?}\x0a     */\x0a    UniqueSelectionDispatcher.prototype.ngOnDestroy = /**\x0a     * @return {?}\x0a     */\x0a    function () {\x0a        this._listeners = [];\x0a    };\x0a    UniqueSelectionDispatcher.decorators = [\x0a        { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\x22Injectable\x22], args: [{ providedIn: \x27root\x27 },] },\x0a    ];\x0a    /** @nocollapse */ UniqueSelectionDispatcher.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\x22defineInjectable\x22])({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: \x22root\x22 });\x0a    return UniqueSelectionDispatcher;\x0a}());\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a/**\x0a * @fileoverview added by tsickle\x0a * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\x0a */\x0a\x0a\x0a//# sourceMappingURL=collections.es5.js.map\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/@angular/cdk/esm5/keycodes.es5.js\x22:\x0a/*!********************************************************!*\x5c\x0a  !*** ./node_modules/@angular/cdk/esm5/keycodes.es5.js ***!\x0a  \x5c********************************************************/\x0a/*! exports provided: MAC_ENTER, BACKSPACE, TAB, NUM_CENTER, ENTER, SHIFT, CONTROL, ALT, PAUSE, CAPS_LOCK, ESCAPE, SPACE, PAGE_UP, PAGE_DOWN, END, HOME, LEFT_ARROW, UP_ARROW, RIGHT_ARROW, DOWN_ARROW, PLUS_SIGN, PRINT_SCREEN, INSERT, DELETE, ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, FF_SEMICOLON, FF_EQUALS, QUESTION_MARK, AT_SIGN, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, META, MAC_WK_CMD_LEFT, MAC_WK_CMD_RIGHT, CONTEXT_MENU, NUMPAD_ZERO, NUMPAD_ONE, NUMPAD_TWO, NUMPAD_THREE, NUMPAD_FOUR, NUMPAD_FIVE, NUMPAD_SIX, NUMPAD_SEVEN, NUMPAD_EIGHT, NUMPAD_NINE, NUMPAD_MULTIPLY, NUMPAD_PLUS, NUMPAD_MINUS, NUMPAD_PERIOD, NUMPAD_DIVIDE, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, NUM_LOCK, SCROLL_LOCK, FIRST_MEDIA, FF_MINUS, MUTE, VOLUME_DOWN, VOLUME_UP, FF_MUTE, FF_VOLUME_DOWN, LAST_MEDIA, FF_VOLUME_UP, SEMICOLON, EQUALS, COMMA, DASH, SLASH, APOSTROPHE, TILDE, OPEN_SQUARE_BRACKET, BACKSLASH, CLOSE_SQUARE_BRACKET, SINGLE_QUOTE, MAC_META */\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22MAC_ENTER\x22, function() { return MAC_ENTER; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22BACKSPACE\x22, function() { return BACKSPACE; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22TAB\x22, function() { return TAB; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22NUM_CENTER\x22, function() { return NUM_CENTER; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22ENTER\x22, function() { return ENTER; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22SHIFT\x22, function() { return SHIFT; });\x0a/* harmony export (binding) */ __we'}