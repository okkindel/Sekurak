var res = {'data':'HTTP/1.1 200 Partial Content\x0aX-Powered-By: Express\x0aAccess-Control-Allow-Origin: *\x0aAccept-Ranges: bytes\x0aContent-Range: bytes 0-226798/226799\x0aContent-Type: null; charset=UTF-8\x0aContent-Length: 226799\x0aETag: W/\x22375ef-9/gCjIiYgYVIRhOrBvcJljzrZQk\x22\x0aDate: Thu, 06 Dec 2018 12:44:45 GMT\x0aConnection: keep-alive\x0a\x0a(window[\x22webpackJsonp\x22] = window[\x22webpackJsonp\x22] || []).push([[\x22polyfills\x22],{\x0a\x0a/***/ \x22./node_modules/core-js/es7/reflect.js\x22:\x0a/*!*********************************************!*\x5c\x0a  !*** ./node_modules/core-js/es7/reflect.js ***!\x0a  \x5c*********************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a__webpack_require__(/*! ../modules/es7.reflect.define-metadata */ \x22./node_modules/core-js/modules/es7.reflect.define-metadata.js\x22);\x0a__webpack_require__(/*! ../modules/es7.reflect.delete-metadata */ \x22./node_modules/core-js/modules/es7.reflect.delete-metadata.js\x22);\x0a__webpack_require__(/*! ../modules/es7.reflect.get-metadata */ \x22./node_modules/core-js/modules/es7.reflect.get-metadata.js\x22);\x0a__webpack_require__(/*! ../modules/es7.reflect.get-metadata-keys */ \x22./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js\x22);\x0a__webpack_require__(/*! ../modules/es7.reflect.get-own-metadata */ \x22./node_modules/core-js/modules/es7.reflect.get-own-metadata.js\x22);\x0a__webpack_require__(/*! ../modules/es7.reflect.get-own-metadata-keys */ \x22./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js\x22);\x0a__webpack_require__(/*! ../modules/es7.reflect.has-metadata */ \x22./node_modules/core-js/modules/es7.reflect.has-metadata.js\x22);\x0a__webpack_require__(/*! ../modules/es7.reflect.has-own-metadata */ \x22./node_modules/core-js/modules/es7.reflect.has-own-metadata.js\x22);\x0a__webpack_require__(/*! ../modules/es7.reflect.metadata */ \x22./node_modules/core-js/modules/es7.reflect.metadata.js\x22);\x0amodule.exports = __webpack_require__(/*! ../modules/_core */ \x22./node_modules/core-js/modules/_core.js\x22).Reflect;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_a-function.js\x22:\x0a/*!*****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_a-function.js ***!\x0a  \x5c*****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = function (it) {\x0a  if (typeof it != \x27function\x27) throw TypeError(it + \x27 is not a function!\x27);\x0a  return it;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_an-instance.js\x22:\x0a/*!******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_an-instance.js ***!\x0a  \x5c******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = function (it, Constructor, name, forbiddenField) {\x0a  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\x0a    throw TypeError(name + \x27: incorrect invocation!\x27);\x0a  } return it;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_an-object.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_an-object.js ***!\x0a  \x5c****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0amodule.exports = function (it) {\x0a  if (!isObject(it)) throw TypeError(it + \x27 is not an object!\x27);\x0a  return it;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_array-from-iterable.js\x22:\x0a/*!**************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_array-from-iterable.js ***!\x0a  \x5c**************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar forOf = __webpack_require__(/*! ./_for-of */ \x22./node_modules/core-js/modules/_for-of.js\x22);\x0a\x0amodule.exports = function (iter, ITERATOR) {\x0a  var result = [];\x0a  forOf(iter, false, result.push, result, ITERATOR);\x0a  return result;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_array-includes.js\x22:\x0a/*!*********************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_array-includes.js ***!\x0a  \x5c*********************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// false -\x3e Array#indexOf\x0a// true  -\x3e Array#includes\x0avar toIObject = __webpack_require__(/*! ./_to-iobject */ \x22./node_modules/core-js/modules/_to-iobject.js\x22);\x0avar toLength = __webpack_require__(/*! ./_to-length */ \x22./node_modules/core-js/modules/_to-length.js\x22);\x0avar toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ \x22./node_modules/core-js/modules/_to-absolute-index.js\x22);\x0amodule.exports = function (IS_INCLUDES) {\x0a  return function ($this, el, fromIndex) {\x0a    var O = toIObject($this);\x0a    var length = toLength(O.length);\x0a    var index = toAbsoluteIndex(fromIndex, length);\x0a    var value;\x0a    // Array#includes uses SameValueZero equality algorithm\x0a    // eslint-disable-next-line no-self-compare\x0a    if (IS_INCLUDES && el != el) while (length \x3e index) {\x0a      value = O[index++];\x0a      // eslint-disable-next-line no-self-compare\x0a      if (value != value) return true;\x0a    // Array#indexOf ignores holes, Array#includes - not\x0a    } else for (;length \x3e index; index++) if (IS_INCLUDES || index in O) {\x0a      if (O[index] === el) return IS_INCLUDES || index || 0;\x0a    } return !IS_INCLUDES && -1;\x0a  };\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_array-methods.js\x22:\x0a/*!********************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_array-methods.js ***!\x0a  \x5c********************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// 0 -\x3e Array#forEach\x0a// 1 -\x3e Array#map\x0a// 2 -\x3e Array#filter\x0a// 3 -\x3e Array#some\x0a// 4 -\x3e Array#every\x0a// 5 -\x3e Array#find\x0a// 6 -\x3e Array#findIndex\x0avar ctx = __webpack_require__(/*! ./_ctx */ \x22./node_modules/core-js/modules/_ctx.js\x22);\x0avar IObject = __webpack_require__(/*! ./_iobject */ \x22./node_modules/core-js/modules/_iobject.js\x22);\x0avar toObject = __webpack_require__(/*! ./_to-object */ \x22./node_modules/core-js/modules/_to-object.js\x22);\x0avar toLength = __webpack_require__(/*! ./_to-length */ \x22./node_modules/core-js/modules/_to-length.js\x22);\x0avar asc = __webpack_require__(/*! ./_array-species-create */ \x22./node_modules/core-js/modules/_array-species-create.js\x22);\x0amodule.exports = function (TYPE, $create) {\x0a  var IS_MAP = TYPE == 1;\x0a  var IS_FILTER = TYPE == 2;\x0a  var IS_SOME = TYPE == 3;\x0a  var IS_EVERY = TYPE == 4;\x0a  var IS_FIND_INDEX = TYPE == 6;\x0a  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\x0a  var create = $create || asc;\x0a  return function ($this, callbackfn, that) {\x0a    var O = toObject($this);\x0a    var self = IObject(O);\x0a    var f = ctx(callbackfn, that, 3);\x0a    var length = toLength(self.length);\x0a    var index = 0;\x0a    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\x0a    var val, res;\x0a    for (;length \x3e index; index++) if (NO_HOLES || index in self) {\x0a      val = self[index];\x0a      res = f(val, index, O);\x0a      if (TYPE) {\x0a        if (IS_MAP) result[index] = res;   // map\x0a        else if (res) switch (TYPE) {\x0a          case 3: return true;             // some\x0a          case 5: return val;              // find\x0a          case 6: return index;            // findIndex\x0a          case 2: result.push(val);        // filter\x0a        } else if (IS_EVERY) return false; // every\x0a      }\x0a    }\x0a    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\x0a  };\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_array-species-constructor.js\x22:\x0a/*!********************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_array-species-constructor.js ***!\x0a  \x5c********************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0avar isArray = __webpack_require__(/*! ./_is-array */ \x22./node_modules/core-js/modules/_is-array.js\x22);\x0avar SPECIES = __webpack_require__(/*! ./_wks */ \x22./node_modules/core-js/modules/_wks.js\x22)(\x27species\x27);\x0a\x0amodule.exports = function (original) {\x0a  var C;\x0a  if (isArray(original)) {\x0a    C = original.constructor;\x0a    // cross-realm fallback\x0a    if (typeof C == \x27function\x27 && (C === Array || isArray(C.prototype))) C = undefined;\x0a    if (isObject(C)) {\x0a      C = C[SPECIES];\x0a      if (C === null) C = undefined;\x0a    }\x0a  } return C === undefined ? Array : C;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_array-species-create.js\x22:\x0a/*!***************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_array-species-create.js ***!\x0a  \x5c***************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\x0avar speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ \x22./node_modules/core-js/modules/_array-species-constructor.js\x22);\x0a\x0amodule.exports = function (original, length) {\x0a  return new (speciesConstructor(original))(length);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_classof.js\x22:\x0a/*!**************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_classof.js ***!\x0a  \x5c**************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// getting tag from 19.1.3.6 Object.prototype.toString()\x0avar cof = __webpack_require__(/*! ./_cof */ \x22./node_modules/core-js/modules/_cof.js\x22);\x0avar TAG = __webpack_require__(/*! ./_wks */ \x22./node_modules/core-js/modules/_wks.js\x22)(\x27toStringTag\x27);\x0a// ES3 wrong here\x0avar ARG = cof(function () { return arguments; }()) == \x27Arguments\x27;\x0a\x0a// fallback for IE11 Script Access Denied error\x0avar tryGet = function (it, key) {\x0a  try {\x0a    return it[key];\x0a  } catch (e) { /* empty */ }\x0a};\x0a\x0amodule.exports = function (it) {\x0a  var O, T, B;\x0a  return it === undefined ? \x27Undefined\x27 : it === null ? \x27Null\x27\x0a    // @@toStringTag case\x0a    : typeof (T = tryGet(O = Object(it), TAG)) == \x27string\x27 ? T\x0a    // builtinTag case\x0a    : ARG ? cof(O)\x0a    // ES3 arguments fallback\x0a    : (B = cof(O)) == \x27Object\x27 && typeof O.callee == \x27function\x27 ? \x27Arguments\x27 : B;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_cof.js\x22:\x0a/*!**********************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_cof.js ***!\x0a  \x5c**********************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0avar toString = {}.toString;\x0a\x0amodule.exports = function (it) {\x0a  return toString.call(it).slice(8, -1);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_collection-strong.js\x22:\x0a/*!************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_collection-strong.js ***!\x0a  \x5c************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0avar dP = __webpack_require__(/*! ./_object-dp */ \x22./node_modules/core-js/modules/_object-dp.js\x22).f;\x0avar create = __webpack_require__(/*! ./_object-create */ \x22./node_modules/core-js/modules/_object-create.js\x22);\x0avar redefineAll = __webpack_require__(/*! ./_redefine-all */ \x22./node_modules/core-js/modules/_redefine-all.js\x22);\x0avar ctx = __webpack_require__(/*! ./_ctx */ \x22./node_modules/core-js/modules/_ctx.js\x22);\x0avar anInstance = __webpack_require__(/*! ./_an-instance */ \x22./node_modules/core-js/modules/_an-instance.js\x22);\x0avar forOf = __webpack_require__(/*! ./_for-of */ \x22./node_modules/core-js/modules/_for-of.js\x22);\x0avar $iterDefine = __webpack_require__(/*! ./_iter-define */ \x22./node_modules/core-js/modules/_iter-define.js\x22);\x0avar step = __webpack_require__(/*! ./_iter-step */ \x22./node_modules/core-js/modules/_iter-step.js\x22);\x0avar setSpecies = __webpack_require__(/*! ./_set-species */ \x22./node_modules/core-js/modules/_set-species.js\x22);\x0avar DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ \x22./node_modules/core-js/modules/_descriptors.js\x22);\x0avar fastKey = __webpack_require__(/*! ./_meta */ \x22./node_modules/core-js/modules/_meta.js\x22).fastKey;\x0avar validate = __webpack_require__(/*! ./_validate-collection */ \x22./node_modules/core-js/modules/_validate-collection.js\x22);\x0avar SIZE = DESCRIPTORS ? \x27_s\x27 : \x27size\x27;\x0a\x0avar getEntry = function (that, key) {\x0a  // fast case\x0a  var index = fastKey(key);\x0a  var entry;\x0a  if (index !== \x27F\x27) return that._i[index];\x0a  // frozen object case\x0a  for (entry = that._f; entry; entry = entry.n) {\x0a    if (entry.k == key) return entry;\x0a  }\x0a};\x0a\x0amodule.exports = {\x0a  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\x0a    var C = wrapper(function (that, iterable) {\x0a      anInstance(that, C, NAME, \x27_i\x27);\x0a      that._t = NAME;         // collection type\x0a      that._i = create(null); // index\x0a      that._f = undefined;    // first entry\x0a      that._l = undefined;    // last entry\x0a      that[SIZE] = 0;         // size\x0a      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\x0a    });\x0a    redefineAll(C.prototype, {\x0a      // 23.1.3.1 Map.prototype.clear()\x0a      // 23.2.3.2 Set.prototype.clear()\x0a      clear: function clear() {\x0a        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\x0a          entry.r = true;\x0a          if (entry.p) entry.p = entry.p.n = undefined;\x0a          delete data[entry.i];\x0a        }\x0a        that._f = that._l = undefined;\x0a        that[SIZE] = 0;\x0a      },\x0a      // 23.1.3.3 Map.prototype.delete(key)\x0a      // 23.2.3.4 Set.prototype.delete(value)\x0a      \x27delete\x27: function (key) {\x0a        var that = validate(this, NAME);\x0a        var entry = getEntry(that, key);\x0a        if (entry) {\x0a          var next = entry.n;\x0a          var prev = entry.p;\x0a          delete that._i[entry.i];\x0a          entry.r = true;\x0a          if (prev) prev.n = next;\x0a          if (next) next.p = prev;\x0a          if (that._f == entry) that._f = next;\x0a          if (that._l == entry) that._l = prev;\x0a          that[SIZE]--;\x0a        } return !!entry;\x0a      },\x0a      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\x0a      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\x0a      forEach: function forEach(callbackfn /* , that = undefined */) {\x0a        validate(this, NAME);\x0a        var f = ctx(callbackfn, arguments.length \x3e 1 ? arguments[1] : undefined, 3);\x0a        var entry;\x0a        while (entry = entry ? entry.n : this._f) {\x0a          f(entry.v, entry.k, this);\x0a          // revert to the last existing entry\x0a          while (entry && entry.r) entry = entry.p;\x0a        }\x0a      },\x0a      // 23.1.3.7 Map.prototype.has(key)\x0a      // 23.2.3.7 Set.prototype.has(value)\x0a      has: function has(key) {\x0a        return !!getEntry(validate(this, NAME), key);\x0a      }\x0a    });\x0a    if (DESCRIPTORS) dP(C.prototype, \x27size\x27, {\x0a      get: function () {\x0a        return validate(this, NAME)[SIZE];\x0a      }\x0a    });\x0a    return C;\x0a  },\x0a  def: function (that, key, value) {\x0a    var entry = getEntry(that, key);\x0a    var prev, index;\x0a    // change existing entry\x0a    if (entry) {\x0a      entry.v = value;\x0a    // create new entry\x0a    } else {\x0a      that._l = entry = {\x0a        i: index = fastKey(key, true), // \x3c- index\x0a        k: key,                        // \x3c- key\x0a        v: value,                      // \x3c- value\x0a        p: prev = that._l,             // \x3c- previous entry\x0a        n: undefined,                  // \x3c- next entry\x0a        r: false                       // \x3c- removed\x0a      };\x0a      if (!that._f) that._f = entry;\x0a      if (prev) prev.n = entry;\x0a      that[SIZE]++;\x0a      // add to index\x0a      if (index !== \x27F\x27) that._i[index] = entry;\x0a    } return that;\x0a  },\x0a  getEntry: getEntry,\x0a  setStrong: function (C, NAME, IS_MAP) {\x0a    // add .keys, .values, .entries, [@@iterator]\x0a    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\x0a    $iterDefine(C, NAME, function (iterated, kind) {\x0a      this._t = validate(iterated, NAME); // target\x0a      this._k = kind;                     // kind\x0a      this._l = undefined;                // previous\x0a    }, function () {\x0a      var that = this;\x0a      var kind = that._k;\x0a      var entry = that._l;\x0a      // revert to the last existing entry\x0a      while (entry && entry.r) entry = entry.p;\x0a      // get next entry\x0a      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\x0a        // or finish the iteration\x0a        that._t = undefined;\x0a        return step(1);\x0a      }\x0a      // return step by kind\x0a      if (kind == \x27keys\x27) return step(0, entry.k);\x0a      if (kind == \x27values\x27) return step(0, entry.v);\x0a      return step(0, [entry.k, entry.v]);\x0a    }, IS_MAP ? \x27entries\x27 : \x27values\x27, !IS_MAP, true);\x0a\x0a    // add [@@species], 23.1.2.2, 23.2.2.2\x0a    setSpecies(NAME);\x0a  }\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_collection-weak.js\x22:\x0a/*!**********************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_collection-weak.js ***!\x0a  \x5c**********************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0avar redefineAll = __webpack_require__(/*! ./_redefine-all */ \x22./node_modules/core-js/modules/_redefine-all.js\x22);\x0avar getWeak = __webpack_require__(/*! ./_meta */ \x22./node_modules/core-js/modules/_meta.js\x22).getWeak;\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0avar anInstance = __webpack_require__(/*! ./_an-instance */ \x22./node_modules/core-js/modules/_an-instance.js\x22);\x0avar forOf = __webpack_require__(/*! ./_for-of */ \x22./node_modules/core-js/modules/_for-of.js\x22);\x0avar createArrayMethod = __webpack_require__(/*! ./_array-methods */ \x22./node_modules/core-js/modules/_array-methods.js\x22);\x0avar $has = __webpack_require__(/*! ./_has */ \x22./node_modules/core-js/modules/_has.js\x22);\x0avar validate = __webpack_require__(/*! ./_validate-collection */ \x22./node_modules/core-js/modules/_validate-collection.js\x22);\x0avar arrayFind = createArrayMethod(5);\x0avar arrayFindIndex = createArrayMethod(6);\x0avar id = 0;\x0a\x0a// fallback for uncaught frozen keys\x0avar uncaughtFrozenStore = function (that) {\x0a  return that._l || (that._l = new UncaughtFrozenStore());\x0a};\x0avar UncaughtFrozenStore = function () {\x0a  this.a = [];\x0a};\x0avar findUncaughtFrozen = function (store, key) {\x0a  return arrayFind(store.a, function (it) {\x0a    return it[0] === key;\x0a  });\x0a};\x0aUncaughtFrozenStore.prototype = {\x0a  get: function (key) {\x0a    var entry = findUncaughtFrozen(this, key);\x0a    if (entry) return entry[1];\x0a  },\x0a  has: function (key) {\x0a    return !!findUncaughtFrozen(this, key);\x0a  },\x0a  set: function (key, value) {\x0a    var entry = findUncaughtFrozen(this, key);\x0a    if (entry) entry[1] = value;\x0a    else this.a.push([key, value]);\x0a  },\x0a  \x27delete\x27: function (key) {\x0a    var index = arrayFindIndex(this.a, function (it) {\x0a      return it[0] === key;\x0a    });\x0a    if (~index) this.a.splice(index, 1);\x0a    return !!~index;\x0a  }\x0a};\x0a\x0amodule.exports = {\x0a  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\x0a    var C = wrapper(function (that, iterable) {\x0a      anInstance(that, C, NAME, \x27_i\x27);\x0a      that._t = NAME;      // collection type\x0a      that._i = id++;      // collection id\x0a      that._l = undefined; // leak store for uncaught frozen objects\x0a      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\x0a    });\x0a    redefineAll(C.prototype, {\x0a      // 23.3.3.2 WeakMap.prototype.delete(key)\x0a      // 23.4.3.3 WeakSet.prototype.delete(value)\x0a      \x27delete\x27: function (key) {\x0a        if (!isObject(key)) return false;\x0a        var data = getWeak(key);\x0a        if (data === true) return uncaughtFrozenStore(validate(this, NAME))[\x27delete\x27](key);\x0a        return data && $has(data, this._i) && delete data[this._i];\x0a      },\x0a      // 23.3.3.4 WeakMap.prototype.has(key)\x0a      // 23.4.3.4 WeakSet.prototype.has(value)\x0a      has: function has(key) {\x0a        if (!isObject(key)) return false;\x0a        var data = getWeak(key);\x0a        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\x0a        return data && $has(data, this._i);\x0a      }\x0a    });\x0a    return C;\x0a  },\x0a  def: function (that, key, value) {\x0a    var data = getWeak(anObject(key), true);\x0a    if (data === true) uncaughtFrozenStore(that).set(key, value);\x0a    else data[that._i] = value;\x0a    return that;\x0a  },\x0a  ufstore: uncaughtFrozenStore\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_collection.js\x22:\x0a/*!*****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_collection.js ***!\x0a  \x5c*****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0avar global = __webpack_require__(/*! ./_global */ \x22./node_modules/core-js/modules/_global.js\x22);\x0avar $export = __webpack_require__(/*! ./_export */ \x22./node_modules/core-js/modules/_export.js\x22);\x0avar redefine = __webpack_require__(/*! ./_redefine */ \x22./node_modules/core-js/modules/_redefine.js\x22);\x0avar redefineAll = __webpack_require__(/*! ./_redefine-all */ \x22./node_modules/core-js/modules/_redefine-all.js\x22);\x0avar meta = __webpack_require__(/*! ./_meta */ \x22./node_modules/core-js/modules/_meta.js\x22);\x0avar forOf = __webpack_require__(/*! ./_for-of */ \x22./node_modules/core-js/modules/_for-of.js\x22);\x0avar anInstance = __webpack_require__(/*! ./_an-instance */ \x22./node_modules/core-js/modules/_an-instance.js\x22);\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0avar fails = __webpack_require__(/*! ./_fails */ \x22./node_modules/core-js/modules/_fails.js\x22);\x0avar $iterDetect = __webpack_require__(/*! ./_iter-detect */ \x22./node_modules/core-js/modules/_iter-detect.js\x22);\x0avar setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ \x22./node_modules/core-js/modules/_set-to-string-tag.js\x22);\x0avar inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ \x22./node_modules/core-js/modules/_inherit-if-required.js\x22);\x0a\x0amodule.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\x0a  var Base = global[NAME];\x0a  var C = Base;\x0a  var ADDER = IS_MAP ? \x27set\x27 : \x27add\x27;\x0a  var proto = C && C.prototype;\x0a  var O = {};\x0a  var fixMethod = function (KEY) {\x0a    var fn = proto[KEY];\x0a    redefine(proto, KEY,\x0a      KEY == \x27delete\x27 ? function (a) {\x0a        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\x0a      } : KEY == \x27has\x27 ? function has(a) {\x0a        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\x0a      } : KEY == \x27get\x27 ? function get(a) {\x0a        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\x0a      } : KEY == \x27add\x27 ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }\x0a        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }\x0a    );\x0a  };\x0a  if (typeof C != \x27function\x27 || !(IS_WEAK || proto.forEach && !fails(function () {\x0a    new C().entries().next();\x0a  }))) {\x0a    // create collection constructor\x0a    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\x0a    redefineAll(C.prototype, methods);\x0a    meta.NEED = true;\x0a  } else {\x0a    var instance = new C();\x0a    // early implementations not supports chaining\x0a    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\x0a    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\x0a    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\x0a    // most early implementations doesn\x27t supports iterables, most modern - not close it correctly\x0a    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new\x0a    // for early implementations -0 and +0 not the same\x0a    var BUGGY_ZERO = !IS_WEAK && fails(function () {\x0a      // V8 ~ Chromium 42- fails only with 5+ elements\x0a      var $instance = new C();\x0a      var index = 5;\x0a      while (index--) $instance[ADDER](index, index);\x0a      return !$instance.has(-0);\x0a    });\x0a    if (!ACCEPT_ITERABLES) {\x0a      C = wrapper(function (target, iterable) {\x0a        anInstance(target, C, NAME);\x0a        var that = inheritIfRequired(new Base(), target, C);\x0a        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\x0a        return that;\x0a      });\x0a      C.prototype = proto;\x0a      proto.constructor = C;\x0a    }\x0a    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\x0a      fixMethod(\x27delete\x27);\x0a      fixMethod(\x27has\x27);\x0a      IS_MAP && fixMethod(\x27get\x27);\x0a    }\x0a    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\x0a    // weak collections should not contains .clear method\x0a    if (IS_WEAK && proto.clear) delete proto.clear;\x0a  }\x0a\x0a  setToStringTag(C, NAME);\x0a\x0a  O[NAME] = C;\x0a  $export($export.G + $export.W + $export.F * (C != Base), O);\x0a\x0a  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\x0a\x0a  return C;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_core.js\x22:\x0a/*!***********************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_core.js ***!\x0a  \x5c***********************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0avar core = module.exports = { version: \x272.5.7\x27 };\x0aif (typeof __e == \x27number\x27) __e = core; // eslint-disable-line no-undef\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_ctx.js\x22:\x0a/*!**********************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_ctx.js ***!\x0a  \x5c**********************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// optional / simple context binding\x0avar aFunction = __webpack_require__(/*! ./_a-function */ \x22./node_modules/core-js/modules/_a-function.js\x22);\x0amodule.exports = function (fn, that, length) {\x0a  aFunction(fn);\x0a  if (that === undefined) return fn;\x0a  switch (length) {\x0a    case 1: return function (a) {\x0a      return fn.call(that, a);\x0a    };\x0a    case 2: return function (a, b) {\x0a      return fn.call(that, a, b);\x0a    };\x0a    case 3: return function (a, b, c) {\x0a      return fn.call(that, a, b, c);\x0a    };\x0a  }\x0a  return function (/* ...args */) {\x0a    return fn.apply(that, arguments);\x0a  };\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_defined.js\x22:\x0a/*!**************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_defined.js ***!\x0a  \x5c**************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0a// 7.2.1 RequireObjectCoercible(argument)\x0amodule.exports = function (it) {\x0a  if (it == undefined) throw TypeError(\x22Can\x27t call method on  \x22 + it);\x0a  return it;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_descriptors.js\x22:\x0a/*!******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_descriptors.js ***!\x0a  \x5c******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// Thank\x27s IE8 for his funny defineProperty\x0amodule.exports = !__webpack_require__(/*! ./_fails */ \x22./node_modules/core-js/modules/_fails.js\x22)(function () {\x0a  return Object.defineProperty({}, \x27a\x27, { get: function () { return 7; } }).a != 7;\x0a});\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_dom-create.js\x22:\x0a/*!*****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_dom-create.js ***!\x0a  \x5c*****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0avar document = __webpack_require__(/*! ./_global */ \x22./node_modules/core-js/modules/_global.js\x22).document;\x0a// typeof document.createElement is \x27object\x27 in old IE\x0avar is = isObject(document) && isObject(document.createElement);\x0amodule.exports = function (it) {\x0a  return is ? document.createElement(it) : {};\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_enum-bug-keys.js\x22:\x0a/*!********************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!\x0a  \x5c********************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0a// IE 8- don\x27t enum bug keys\x0amodule.exports = (\x0a  \x27constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\x27\x0a).split(\x27,\x27);\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_export.js\x22:\x0a/*!*************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_export.js ***!\x0a  \x5c*************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar global = __webpack_require__(/*! ./_global */ \x22./node_modules/core-js/modules/_global.js\x22);\x0avar core = __webpack_require__(/*! ./_core */ \x22./node_modules/core-js/modules/_core.js\x22);\x0avar hide = __webpack_require__(/*! ./_hide */ \x22./node_modules/core-js/modules/_hide.js\x22);\x0avar redefine = __webpack_require__(/*! ./_redefine */ \x22./node_modules/core-js/modules/_redefine.js\x22);\x0avar ctx = __webpack_require__(/*! ./_ctx */ \x22./node_modules/core-js/modules/_ctx.js\x22);\x0avar PROTOTYPE = \x27prototype\x27;\x0a\x0avar $export = function (type, name, source) {\x0a  var IS_FORCED = type & $export.F;\x0a  var IS_GLOBAL = type & $export.G;\x0a  var IS_STATIC = type & $export.S;\x0a  var IS_PROTO = type & $export.P;\x0a  var IS_BIND = type & $export.B;\x0a  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\x0a  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\x0a  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\x0a  var key, own, out, exp;\x0a  if (IS_GLOBAL) source = name;\x0a  for (key in source) {\x0a    // contains in native\x0a    own = !IS_FORCED && target && target[key] !== undefined;\x0a    // export native or passed\x0a    out = (own ? target : source)[key];\x0a    // bind timers to global for call from export context\x0a    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == \x27function\x27 ? ctx(Function.call, out) : out;\x0a    // extend global\x0a    if (target) redefine(target, key, out, type & $export.U);\x0a    // export\x0a    if (exports[key] != out) hide(exports, key, exp);\x0a    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\x0a  }\x0a};\x0aglobal.core = core;\x0a// type bitmap\x0a$export.F = 1;   // forced\x0a$export.G = 2;   // global\x0a$export.S = 4;   // static\x0a$export.P = 8;   // proto\x0a$export.B = 16;  // bind\x0a$export.W = 32;  // wrap\x0a$export.U = 64;  // safe\x0a$export.R = 128; // real proto method for `library`\x0amodule.exports = $export;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_fails.js\x22:\x0a/*!************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_fails.js ***!\x0a  \x5c************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = function (exec) {\x0a  try {\x0a    return !!exec();\x0a  } catch (e) {\x0a    return true;\x0a  }\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_for-of.js\x22:\x0a/*!*************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_for-of.js ***!\x0a  \x5c*************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar ctx = __webpack_require__(/*! ./_ctx */ \x22./node_modules/core-js/modules/_ctx.js\x22);\x0avar call = __webpack_require__(/*! ./_iter-call */ \x22./node_modules/core-js/modules/_iter-call.js\x22);\x0avar isArrayIter = __webpack_require__(/*! ./_is-array-iter */ \x22./node_modules/core-js/modules/_is-array-iter.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar toLength = __webpack_require__(/*! ./_to-length */ \x22./node_modules/core-js/modules/_to-length.js\x22);\x0avar getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ \x22./node_modules/core-js/modules/core.get-iterator-method.js\x22);\x0avar BREAK = {};\x0avar RETURN = {};\x0avar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\x0a  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\x0a  var f = ctx(fn, that, entries ? 2 : 1);\x0a  var index = 0;\x0a  var length, step, iterator, result;\x0a  if (typeof iterFn != \x27function\x27) throw TypeError(iterable + \x27 is not iterable!\x27);\x0a  // fast case for arrays with default iterator\x0a  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length \x3e index; index++) {\x0a    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\x0a    if (result === BREAK || result === RETURN) return result;\x0a  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\x0a    result = call(iterator, f, step.value, entries);\x0a    if (result === BREAK || result === RETURN) return result;\x0a  }\x0a};\x0aexports.BREAK = BREAK;\x0aexports.RETURN = RETURN;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_global.js\x22:\x0a/*!*************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_global.js ***!\x0a  \x5c*************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0a// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\x0avar global = module.exports = typeof window != \x27undefined\x27 && window.Math == Math\x0a  ? window : typeof self != \x27undefined\x27 && self.Math == Math ? self\x0a  // eslint-disable-next-line no-new-func\x0a  : Function(\x27return this\x27)();\x0aif (typeof __g == \x27number\x27) __g = global; // eslint-disable-line no-undef\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_has.js\x22:\x0a/*!**********************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_has.js ***!\x0a  \x5c**********************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0avar hasOwnProperty = {}.hasOwnProperty;\x0amodule.exports = function (it, key) {\x0a  return hasOwnProperty.call(it, key);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_hide.js\x22:\x0a/*!***********************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_hide.js ***!\x0a  \x5c***********************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar dP = __webpack_require__(/*! ./_object-dp */ \x22./node_modules/core-js/modules/_object-dp.js\x22);\x0avar createDesc = __webpack_require__(/*! ./_property-desc */ \x22./node_modules/core-js/modules/_property-desc.js\x22);\x0amodule.exports = __webpack_require__(/*! ./_descriptors */ \x22./node_modules/core-js/modules/_descriptors.js\x22) ? function (object, key, value) {\x0a  return dP.f(object, key, createDesc(1, value));\x0a} : function (object, key, value) {\x0a  object[key] = value;\x0a  return object;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_html.js\x22:\x0a/*!***********************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_html.js ***!\x0a  \x5c***********************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar document = __webpack_require__(/*! ./_global */ \x22./node_modules/core-js/modules/_global.js\x22).document;\x0amodule.exports = document && document.documentElement;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_ie8-dom-define.js\x22:\x0a/*!*********************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!\x0a  \x5c*********************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0amodule.exports = !__webpack_require__(/*! ./_descriptors */ \x22./node_modules/core-js/modules/_descriptors.js\x22) && !__webpack_require__(/*! ./_fails */ \x22./node_modules/core-js/modules/_fails.js\x22)(function () {\x0a  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ \x22./node_modules/core-js/modules/_dom-create.js\x22)(\x27div\x27), \x27a\x27, { get: function () { return 7; } }).a != 7;\x0a});\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_inherit-if-required.js\x22:\x0a/*!**************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_inherit-if-required.js ***!\x0a  \x5c**************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0avar setPrototypeOf = __webpack_require__(/*! ./_set-proto */ \x22./node_modules/core-js/modules/_set-proto.js\x22).set;\x0amodule.exports = function (that, target, C) {\x0a  var S = target.constructor;\x0a  var P;\x0a  if (S !== C && typeof S == \x27function\x27 && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {\x0a    setPrototypeOf(that, P);\x0a  } return that;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_iobject.js\x22:\x0a/*!**************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_iobject.js ***!\x0a  \x5c**************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// fallback for non-array-like ES3 and non-enumerable old V8 strings\x0avar cof = __webpack_require__(/*! ./_cof */ \x22./node_modules/core-js/modules/_cof.js\x22);\x0a// eslint-disable-next-line no-prototype-builtins\x0amodule.exports = Object(\x27z\x27).propertyIsEnumerable(0) ? Object : function (it) {\x0a  return cof(it) == \x27String\x27 ? it.split(\x27\x27) : Object(it);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_is-array-iter.js\x22:\x0a/*!********************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!\x0a  \x5c********************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// check on default Array iterator\x0avar Iterators = __webpack_require__(/*! ./_iterators */ \x22./node_modules/core-js/modules/_iterators.js\x22);\x0avar ITERATOR = __webpack_require__(/*! ./_wks */ \x22./node_modules/core-js/modules/_wks.js\x22)(\x27iterator\x27);\x0avar ArrayProto = Array.prototype;\x0a\x0amodule.exports = function (it) {\x0a  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_is-array.js\x22:\x0a/*!***************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_is-array.js ***!\x0a  \x5c***************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// 7.2.2 IsArray(argument)\x0avar cof = __webpack_require__(/*! ./_cof */ \x22./node_modules/core-js/modules/_cof.js\x22);\x0amodule.exports = Array.isArray || function isArray(arg) {\x0a  return cof(arg) == \x27Array\x27;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_is-object.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_is-object.js ***!\x0a  \x5c****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = function (it) {\x0a  return typeof it === \x27object\x27 ? it !== null : typeof it === \x27function\x27;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_iter-call.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_iter-call.js ***!\x0a  \x5c****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// call something on iterator step with safe closing on error\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0amodule.exports = function (iterator, fn, value, entries) {\x0a  try {\x0a    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\x0a  // 7.4.6 IteratorClose(iterator, completion)\x0a  } catch (e) {\x0a    var ret = iterator[\x27return\x27];\x0a    if (ret !== undefined) anObject(ret.call(iterator));\x0a    throw e;\x0a  }\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_iter-create.js\x22:\x0a/*!******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_iter-create.js ***!\x0a  \x5c******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0avar create = __webpack_require__(/*! ./_object-create */ \x22./node_modules/core-js/modules/_object-create.js\x22);\x0avar descriptor = __webpack_require__(/*! ./_property-desc */ \x22./node_modules/core-js/modules/_property-desc.js\x22);\x0avar setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ \x22./node_modules/core-js/modules/_set-to-string-tag.js\x22);\x0avar IteratorPrototype = {};\x0a\x0a// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\x0a__webpack_require__(/*! ./_hide */ \x22./node_modules/core-js/modules/_hide.js\x22)(IteratorPrototype, __webpack_require__(/*! ./_wks */ \x22./node_modules/core-js/modules/_wks.js\x22)(\x27iterator\x27), function () { return this; });\x0a\x0amodule.exports = function (Constructor, NAME, next) {\x0a  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\x0a  setToStringTag(Constructor, NAME + \x27 Iterator\x27);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_iter-define.js\x22:\x0a/*!******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_iter-define.js ***!\x0a  \x5c******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0avar LIBRARY = __webpack_require__(/*! ./_library */ \x22./node_modules/core-js/modules/_library.js\x22);\x0avar $export = __webpack_require__(/*! ./_export */ \x22./node_modules/core-js/modules/_export.js\x22);\x0avar redefine = __webpack_require__(/*! ./_redefine */ \x22./node_modules/core-js/modules/_redefine.js\x22);\x0avar hide = __webpack_require__(/*! ./_hide */ \x22./node_modules/core-js/modules/_hide.js\x22);\x0avar Iterators = __webpack_require__(/*! ./_iterators */ \x22./node_modules/core-js/modules/_iterators.js\x22);\x0avar $iterCreate = __webpack_require__(/*! ./_iter-create */ \x22./node_modules/core-js/modules/_iter-create.js\x22);\x0avar setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ \x22./node_modules/core-js/modules/_set-to-string-tag.js\x22);\x0avar getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ \x22./node_modules/core-js/modules/_object-gpo.js\x22);\x0avar ITERATOR = __webpack_require__(/*! ./_wks */ \x22./node_modules/core-js/modules/_wks.js\x22)(\x27iterator\x27);\x0avar BUGGY = !([].keys && \x27next\x27 in [].keys()); // Safari has buggy iterators w/o `next`\x0avar FF_ITERATOR = \x27@@iterator\x27;\x0avar KEYS = \x27keys\x27;\x0avar VALUES = \x27values\x27;\x0a\x0avar returnThis = function () { return this; };\x0a\x0amodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\x0a  $iterCreate(Constructor, NAME, next);\x0a  var getMethod = function (kind) {\x0a    if (!BUGGY && kind in proto) return proto[kind];\x0a    switch (kind) {\x0a      case KEYS: return function keys() { return new Constructor(this, kind); };\x0a      case VALUES: return function values() { return new Constructor(this, kind); };\x0a    } return function entries() { return new Constructor(this, kind); };\x0a  };\x0a  var TAG = NAME + \x27 Iterator\x27;\x0a  var DEF_VALUES = DEFAULT == VALUES;\x0a  var VALUES_BUG = false;\x0a  var proto = Base.prototype;\x0a  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\x0a  var $default = $native || getMethod(DEFAULT);\x0a  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod(\x27entries\x27) : undefined;\x0a  var $anyNative = NAME == \x27Array\x27 ? proto.entries || $native : $native;\x0a  var methods, key, IteratorPrototype;\x0a  // Fix native\x0a  if ($anyNative) {\x0a    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\x0a    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\x0a      // Set @@toStringTag to native iterators\x0a      setToStringTag(IteratorPrototype, TAG, true);\x0a      // fix for some old engines\x0a      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != \x27function\x27) hide(IteratorPrototype, ITERATOR, returnThis);\x0a    }\x0a  }\x0a  // fix Array#{values, @@iterator}.name in V8 / FF\x0a  if (DEF_VALUES && $native && $native.name !== VALUES) {\x0a    VALUES_BUG = true;\x0a    $default = function values() { return $native.call(this); };\x0a  }\x0a  // Define iterator\x0a  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\x0a    hide(proto, ITERATOR, $default);\x0a  }\x0a  // Plug for library\x0a  Iterators[NAME] = $default;\x0a  Iterators[TAG] = returnThis;\x0a  if (DEFAULT) {\x0a    methods = {\x0a      values: DEF_VALUES ? $default : getMethod(VALUES),\x0a      keys: IS_SET ? $default : getMethod(KEYS),\x0a      entries: $entries\x0a    };\x0a    if (FORCED) for (key in methods) {\x0a      if (!(key in proto)) redefine(proto, key, methods[key]);\x0a    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\x0a  }\x0a  return methods;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_iter-detect.js\x22:\x0a/*!******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_iter-detect.js ***!\x0a  \x5c******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar ITERATOR = __webpack_require__(/*! ./_wks */ \x22./node_modules/core-js/modules/_wks.js\x22)(\x27iterator\x27);\x0avar SAFE_CLOSING = false;\x0a\x0atry {\x0a  var riter = [7][ITERATOR]();\x0a  riter[\x27return\x27] = function () { SAFE_CLOSING = true; };\x0a  // eslint-disable-next-line no-throw-literal\x0a  Array.from(riter, function () { throw 2; });\x0a} catch (e) { /* empty */ }\x0a\x0amodule.exports = function (exec, skipClosing) {\x0a  if (!skipClosing && !SAFE_CLOSING) return false;\x0a  var safe = false;\x0a  try {\x0a    var arr = [7];\x0a    var iter = arr[ITERATOR]();\x0a    iter.next = function () { return { done: safe = true }; };\x0a    arr[ITERATOR] = function () { return iter; };\x0a    exec(arr);\x0a  } catch (e) { /* empty */ }\x0a  return safe;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_iter-step.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_iter-step.js ***!\x0a  \x5c****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = function (done, value) {\x0a  return { value: value, done: !!done };\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_iterators.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_iterators.js ***!\x0a  \x5c****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = {};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_library.js\x22:\x0a/*!**************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_library.js ***!\x0a  \x5c**************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = false;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_meta.js\x22:\x0a/*!***********************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_meta.js ***!\x0a  \x5c***********************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar META = __webpack_require__(/*! ./_uid */ \x22./node_modules/core-js/modules/_uid.js\x22)(\x27meta\x27);\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0avar has = __webpack_require__(/*! ./_has */ \x22./node_modules/core-js/modules/_has.js\x22);\x0avar setDesc = __webpack_require__(/*! ./_object-dp */ \x22./node_modules/core-js/modules/_object-dp.js\x22).f;\x0avar id = 0;\x0avar isExtensible = Object.isExtensible || function () {\x0a  return true;\x0a};\x0avar FREEZE = !__webpack_require__(/*! ./_fails */ \x22./node_modules/core-js/modules/_fails.js\x22)(function () {\x0a  return isExtensible(Object.preventExtensions({}));\x0a});\x0avar setMeta = function (it) {\x0a  setDesc(it, META, { value: {\x0a    i: \x27O\x27 + ++id, // object ID\x0a    w: {}          // weak collections IDs\x0a  } });\x0a};\x0avar fastKey = function (it, create) {\x0a  // return primitive with prefix\x0a  if (!isObject(it)) return typeof it == \x27symbol\x27 ? it : (typeof it == \x27string\x27 ? \x27S\x27 : \x27P\x27) + it;\x0a  if (!has(it, META)) {\x0a    // can\x27t set metadata to uncaught frozen object\x0a    if (!isExtensible(it)) return \x27F\x27;\x0a    // not necessary to add metadata\x0a    if (!create) return \x27E\x27;\x0a    // add missing metadata\x0a    setMeta(it);\x0a  // return object ID\x0a  } return it[META].i;\x0a};\x0avar getWeak = function (it, create) {\x0a  if (!has(it, META)) {\x0a    // can\x27t set metadata to uncaught frozen object\x0a    if (!isExtensible(it)) return true;\x0a    // not necessary to add metadata\x0a    if (!create) return false;\x0a    // add missing metadata\x0a    setMeta(it);\x0a  // return hash weak collections IDs\x0a  } return it[META].w;\x0a};\x0a// add metadata on freeze-family methods calling\x0avar onFreeze = function (it) {\x0a  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\x0a  return it;\x0a};\x0avar meta = module.exports = {\x0a  KEY: META,\x0a  NEED: false,\x0a  fastKey: fastKey,\x0a  getWeak: getWeak,\x0a  onFreeze: onFreeze\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_metadata.js\x22:\x0a/*!***************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_metadata.js ***!\x0a  \x5c***************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar Map = __webpack_require__(/*! ./es6.map */ \x22./node_modules/core-js/modules/es6.map.js\x22);\x0avar $export = __webpack_require__(/*! ./_export */ \x22./node_modules/core-js/modules/_export.js\x22);\x0avar shared = __webpack_require__(/*! ./_shared */ \x22./node_modules/core-js/modules/_shared.js\x22)(\x27metadata\x27);\x0avar store = shared.store || (shared.store = new (__webpack_require__(/*! ./es6.weak-map */ \x22./node_modules/core-js/modules/es6.weak-map.js\x22))());\x0a\x0avar getOrCreateMetadataMap = function (target, targetKey, create) {\x0a  var targetMetadata = store.get(target);\x0a  if (!targetMetadata) {\x0a    if (!create) return undefined;\x0a    store.set(target, targetMetadata = new Map());\x0a  }\x0a  var keyMetadata = targetMetadata.get(targetKey);\x0a  if (!keyMetadata) {\x0a    if (!create) return undefined;\x0a    targetMetadata.set(targetKey, keyMetadata = new Map());\x0a  } return keyMetadata;\x0a};\x0avar ordinaryHasOwnMetadata = function (MetadataKey, O, P) {\x0a  var metadataMap = getOrCreateMetadataMap(O, P, false);\x0a  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);\x0a};\x0avar ordinaryGetOwnMetadata = function (MetadataKey, O, P) {\x0a  var metadataMap = getOrCreateMetadataMap(O, P, false);\x0a  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);\x0a};\x0avar ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {\x0a  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);\x0a};\x0avar ordinaryOwnMetadataKeys = function (target, targetKey) {\x0a  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);\x0a  var keys = [];\x0a  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });\x0a  return keys;\x0a};\x0avar toMetaKey = function (it) {\x0a  return it === undefined || typeof it == \x27symbol\x27 ? it : String(it);\x0a};\x0avar exp = function (O) {\x0a  $export($export.S, \x27Reflect\x27, O);\x0a};\x0a\x0amodule.exports = {\x0a  store: store,\x0a  map: getOrCreateMetadataMap,\x0a  has: ordinaryHasOwnMetadata,\x0a  get: ordinaryGetOwnMetadata,\x0a  set: ordinaryDefineOwnMetadata,\x0a  keys: ordinaryOwnMetadataKeys,\x0a  key: toMetaKey,\x0a  exp: exp\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_object-assign.js\x22:\x0a/*!********************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_object-assign.js ***!\x0a  \x5c********************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a// 19.1.2.1 Object.assign(target, source, ...)\x0avar getKeys = __webpack_require__(/*! ./_object-keys */ \x22./node_modules/core-js/modules/_object-keys.js\x22);\x0avar gOPS = __webpack_require__(/*! ./_object-gops */ \x22./node_modules/core-js/modules/_object-gops.js\x22);\x0avar pIE = __webpack_require__(/*! ./_object-pie */ \x22./node_modules/core-js/modules/_object-pie.js\x22);\x0avar toObject = __webpack_require__(/*! ./_to-object */ \x22./node_modules/core-js/modules/_to-object.js\x22);\x0avar IObject = __webpack_require__(/*! ./_iobject */ \x22./node_modules/core-js/modules/_iobject.js\x22);\x0avar $assign = Object.assign;\x0a\x0a// should work with symbols and should have deterministic property order (V8 bug)\x0amodule.exports = !$assign || __webpack_require__(/*! ./_fails */ \x22./node_modules/core-js/modules/_fails.js\x22)(function () {\x0a  var A = {};\x0a  var B = {};\x0a  // eslint-disable-next-line no-undef\x0a  var S = Symbol();\x0a  var K = \x27abcdefghijklmnopqrst\x27;\x0a  A[S] = 7;\x0a  K.split(\x27\x27).forEach(function (k) { B[k] = k; });\x0a  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join(\x27\x27) != K;\x0a}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\x0a  var T = toObject(target);\x0a  var aLen = arguments.length;\x0a  var index = 1;\x0a  var getSymbols = gOPS.f;\x0a  var isEnum = pIE.f;\x0a  while (aLen \x3e index) {\x0a    var S = IObject(arguments[index++]);\x0a    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\x0a    var length = keys.length;\x0a    var j = 0;\x0a    var key;\x0a    while (length \x3e j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\x0a  } return T;\x0a} : $assign;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_object-create.js\x22:\x0a/*!********************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_object-create.js ***!\x0a  \x5c********************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar dPs = __webpack_require__(/*! ./_object-dps */ \x22./node_modules/core-js/modules/_object-dps.js\x22);\x0avar enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ \x22./node_modules/core-js/modules/_enum-bug-keys.js\x22);\x0avar IE_PROTO = __webpack_require__(/*! ./_shared-key */ \x22./node_modules/core-js/modules/_shared-key.js\x22)(\x27IE_PROTO\x27);\x0avar Empty = function () { /* empty */ };\x0avar PROTOTYPE = \x27prototype\x27;\x0a\x0a// Create object with fake `null` prototype: use iframe Object with cleared prototype\x0avar createDict = function () {\x0a  // Thrash, waste and sodomy: IE GC bug\x0a  var iframe = __webpack_require__(/*! ./_dom-create */ \x22./node_modules/core-js/modules/_dom-create.js\x22)(\x27iframe\x27);\x0a  var i = enumBugKeys.length;\x0a  var lt = \x27\x3c\x27;\x0a  var gt = \x27\x3e\x27;\x0a  var iframeDocument;\x0a  iframe.style.display = \x27none\x27;\x0a  __webpack_require__(/*! ./_html */ \x22./node_modules/core-js/modules/_html.js\x22).appendChild(iframe);\x0a  iframe.src = \x27javascript:\x27; // eslint-disable-line no-script-url\x0a  // createDict = iframe.contentWindow.Object;\x0a  // html.removeChild(iframe);\x0a  iframeDocument = iframe.contentWindow.document;\x0a  iframeDocument.open();\x0a  iframeDocument.write(lt + \x27script\x27 + gt + \x27document.F=Object\x27 + lt + \x27/script\x27 + gt);\x0a  iframeDocument.close();\x0a  createDict = iframeDocument.F;\x0a  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\x0a  return createDict();\x0a};\x0a\x0amodule.exports = Object.create || function create(O, Properties) {\x0a  var result;\x0a  if (O !== null) {\x0a    Empty[PROTOTYPE] = anObject(O);\x0a    result = new Empty();\x0a    Empty[PROTOTYPE] = null;\x0a    // add \x22__proto__\x22 for Object.getPrototypeOf polyfill\x0a    result[IE_PROTO] = O;\x0a  } else result = createDict();\x0a  return Properties === undefined ? result : dPs(result, Properties);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_object-dp.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_object-dp.js ***!\x0a  \x5c****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ \x22./node_modules/core-js/modules/_ie8-dom-define.js\x22);\x0avar toPrimitive = __webpack_require__(/*! ./_to-primitive */ \x22./node_modules/core-js/modules/_to-primitive.js\x22);\x0avar dP = Object.defineProperty;\x0a\x0aexports.f = __webpack_require__(/*! ./_descriptors */ \x22./node_modules/core-js/modules/_descriptors.js\x22) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\x0a  anObject(O);\x0a  P = toPrimitive(P, true);\x0a  anObject(Attributes);\x0a  if (IE8_DOM_DEFINE) try {\x0a    return dP(O, P, Attributes);\x0a  } catch (e) { /* empty */ }\x0a  if (\x27get\x27 in Attributes || \x27set\x27 in Attributes) throw TypeError(\x27Accessors not supported!\x27);\x0a  if (\x27value\x27 in Attributes) O[P] = Attributes.value;\x0a  return O;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_object-dps.js\x22:\x0a/*!*****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_object-dps.js ***!\x0a  \x5c*****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar dP = __webpack_require__(/*! ./_object-dp */ \x22./node_modules/core-js/modules/_object-dp.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar getKeys = __webpack_require__(/*! ./_object-keys */ \x22./node_modules/core-js/modules/_object-keys.js\x22);\x0a\x0amodule.exports = __webpack_require__(/*! ./_descriptors */ \x22./node_modules/core-js/modules/_descriptors.js\x22) ? Object.defineProperties : function defineProperties(O, Properties) {\x0a  anObject(O);\x0a  var keys = getKeys(Properties);\x0a  var length = keys.length;\x0a  var i = 0;\x0a  var P;\x0a  while (length \x3e i) dP.f(O, P = keys[i++], Properties[P]);\x0a  return O;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_object-gopd.js\x22:\x0a/*!******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_object-gopd.js ***!\x0a  \x5c******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar pIE = __webpack_require__(/*! ./_object-pie */ \x22./node_modules/core-js/modules/_object-pie.js\x22);\x0avar createDesc = __webpack_require__(/*! ./_property-desc */ \x22./node_modules/core-js/modules/_property-desc.js\x22);\x0avar toIObject = __webpack_require__(/*! ./_to-iobject */ \x22./node_modules/core-js/modules/_to-iobject.js\x22);\x0avar toPrimitive = __webpack_require__(/*! ./_to-primitive */ \x22./node_modules/core-js/modules/_to-primitive.js\x22);\x0avar has = __webpack_require__(/*! ./_has */ \x22./node_modules/core-js/modules/_has.js\x22);\x0avar IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ \x22./node_modules/core-js/modules/_ie8-dom-define.js\x22);\x0avar gOPD = Object.getOwnPropertyDescriptor;\x0a\x0aexports.f = __webpack_require__(/*! ./_descriptors */ \x22./node_modules/core-js/modules/_descriptors.js\x22) ? gOPD : function getOwnPropertyDescriptor(O, P) {\x0a  O = toIObject(O);\x0a  P = toPrimitive(P, true);\x0a  if (IE8_DOM_DEFINE) try {\x0a    return gOPD(O, P);\x0a  } catch (e) { /* empty */ }\x0a  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_object-gops.js\x22:\x0a/*!******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_object-gops.js ***!\x0a  \x5c******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0aexports.f = Object.getOwnPropertySymbols;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_object-gpo.js\x22:\x0a/*!*****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_object-gpo.js ***!\x0a  \x5c*****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\x0avar has = __webpack_require__(/*! ./_has */ \x22./node_modules/core-js/modules/_has.js\x22);\x0avar toObject = __webpack_require__(/*! ./_to-object */ \x22./node_modules/core-js/modules/_to-object.js\x22);\x0avar IE_PROTO = __webpack_require__(/*! ./_shared-key */ \x22./node_modules/core-js/modules/_shared-key.js\x22)(\x27IE_PROTO\x27);\x0avar ObjectProto = Object.prototype;\x0a\x0amodule.exports = Object.getPrototypeOf || function (O) {\x0a  O = toObject(O);\x0a  if (has(O, IE_PROTO)) return O[IE_PROTO];\x0a  if (typeof O.constructor == \x27function\x27 && O instanceof O.constructor) {\x0a    return O.constructor.prototype;\x0a  } return O instanceof Object ? ObjectProto : null;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_object-keys-internal.js\x22:\x0a/*!***************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!\x0a  \x5c***************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar has = __webpack_require__(/*! ./_has */ \x22./node_modules/core-js/modules/_has.js\x22);\x0avar toIObject = __webpack_require__(/*! ./_to-iobject */ \x22./node_modules/core-js/modules/_to-iobject.js\x22);\x0avar arrayIndexOf = __webpack_require__(/*! ./_array-includes */ \x22./node_modules/core-js/modules/_array-includes.js\x22)(false);\x0avar IE_PROTO = __webpack_require__(/*! ./_shared-key */ \x22./node_modules/core-js/modules/_shared-key.js\x22)(\x27IE_PROTO\x27);\x0a\x0amodule.exports = function (object, names) {\x0a  var O = toIObject(object);\x0a  var i = 0;\x0a  var result = [];\x0a  var key;\x0a  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\x0a  // Don\x27t enum bug & hidden keys\x0a  while (names.length \x3e i) if (has(O, key = names[i++])) {\x0a    ~arrayIndexOf(result, key) || result.push(key);\x0a  }\x0a  return result;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_object-keys.js\x22:\x0a/*!******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_object-keys.js ***!\x0a  \x5c******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// 19.1.2.14 / 15.2.3.14 Object.keys(O)\x0avar $keys = __webpack_require__(/*! ./_object-keys-internal */ \x22./node_modules/core-js/modules/_object-keys-internal.js\x22);\x0avar enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ \x22./node_modules/core-js/modules/_enum-bug-keys.js\x22);\x0a\x0amodule.exports = Object.keys || function keys(O) {\x0a  return $keys(O, enumBugKeys);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_object-pie.js\x22:\x0a/*!*****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_object-pie.js ***!\x0a  \x5c*****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0aexports.f = {}.propertyIsEnumerable;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_property-desc.js\x22:\x0a/*!********************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_property-desc.js ***!\x0a  \x5c********************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = function (bitmap, value) {\x0a  return {\x0a    enumerable: !(bitmap & 1),\x0a    configurable: !(bitmap & 2),\x0a    writable: !(bitmap & 4),\x0a    value: value\x0a  };\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_redefine-all.js\x22:\x0a/*!*******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_redefine-all.js ***!\x0a  \x5c*******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar redefine = __webpack_require__(/*! ./_redefine */ \x22./node_modules/core-js/modules/_redefine.js\x22);\x0amodule.exports = function (target, src, safe) {\x0a  for (var key in src) redefine(target, key, src[key], safe);\x0a  return target;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_redefine.js\x22:\x0a/*!***************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_redefine.js ***!\x0a  \x5c***************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar global = __webpack_require__(/*! ./_global */ \x22./node_modules/core-js/modules/_global.js\x22);\x0avar hide = __webpack_require__(/*! ./_hide */ \x22./node_modules/core-js/modules/_hide.js\x22);\x0avar has = __webpack_require__(/*! ./_has */ \x22./node_modules/core-js/modules/_has.js\x22);\x0avar SRC = __webpack_require__(/*! ./_uid */ \x22./node_modules/core-js/modules/_uid.js\x22)(\x27src\x27);\x0avar TO_STRING = \x27toString\x27;\x0avar $toString = Function[TO_STRING];\x0avar TPL = (\x27\x27 + $toString).split(TO_STRING);\x0a\x0a__webpack_require__(/*! ./_core */ \x22./node_modules/core-js/modules/_core.js\x22).inspectSource = function (it) {\x0a  return $toString.call(it);\x0a};\x0a\x0a(module.exports = function (O, key, val, safe) {\x0a  var isFunction = typeof val == \x27function\x27;\x0a  if (isFunction) has(val, \x27name\x27) || hide(val, \x27name\x27, key);\x0a  if (O[key] === val) return;\x0a  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? \x27\x27 + O[key] : TPL.join(String(key)));\x0a  if (O === global) {\x0a    O[key] = val;\x0a  } else if (!safe) {\x0a    delete O[key];\x0a    hide(O, key, val);\x0a  } else if (O[key]) {\x0a    O[key] = val;\x0a  } else {\x0a    hide(O, key, val);\x0a  }\x0a// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\x0a})(Function.prototype, TO_STRING, function toString() {\x0a  return typeof this == \x27function\x27 && this[SRC] || $toString.call(this);\x0a});\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_set-proto.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_set-proto.js ***!\x0a  \x5c****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// Works with __proto__ only. Old v8 can\x27t work with null proto objects.\x0a/* eslint-disable no-proto */\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar check = function (O, proto) {\x0a  anObject(O);\x0a  if (!isObject(proto) && proto !== null) throw TypeError(proto + \x22: can\x27t set as prototype!\x22);\x0a};\x0amodule.exports = {\x0a  set: Object.setPrototypeOf || (\x27__proto__\x27 in {} ? // eslint-disable-line\x0a    function (test, buggy, set) {\x0a      try {\x0a        set = __webpack_require__(/*! ./_ctx */ \x22./node_modules/core-js/modules/_ctx.js\x22)(Function.call, __webpack_require__(/*! ./_object-gopd */ \x22./node_modules/core-js/modules/_object-gopd.js\x22).f(Object.prototype, \x27__proto__\x27).set, 2);\x0a        set(test, []);\x0a        buggy = !(test instanceof Array);\x0a      } catch (e) { buggy = true; }\x0a      return function setPrototypeOf(O, proto) {\x0a        check(O, proto);\x0a        if (buggy) O.__proto__ = proto;\x0a        else set(O, proto);\x0a        return O;\x0a      };\x0a    }({}, false) : undefined),\x0a  check: check\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_set-species.js\x22:\x0a/*!******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_set-species.js ***!\x0a  \x5c******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0avar global = __webpack_require__(/*! ./_global */ \x22./node_modules/core-js/modules/_global.js\x22);\x0avar dP = __webpack_require__(/*! ./_object-dp */ \x22./node_modules/core-js/modules/_object-dp.js\x22);\x0avar DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ \x22./node_modules/core-js/modules/_descriptors.js\x22);\x0avar SPECIES = __webpack_require__(/*! ./_wks */ \x22./node_modules/core-js/modules/_wks.js\x22)(\x27species\x27);\x0a\x0amodule.exports = function (KEY) {\x0a  var C = global[KEY];\x0a  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\x0a    configurable: true,\x0a    get: function () { return this; }\x0a  });\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_set-to-string-tag.js\x22:\x0a/*!************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!\x0a  \x5c************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar def = __webpack_require__(/*! ./_object-dp */ \x22./node_modules/core-js/modules/_object-dp.js\x22).f;\x0avar has = __webpack_require__(/*! ./_has */ \x22./node_modules/core-js/modules/_has.js\x22);\x0avar TAG = __webpack_require__(/*! ./_wks */ \x22./node_modules/core-js/modules/_wks.js\x22)(\x27toStringTag\x27);\x0a\x0amodule.exports = function (it, tag, stat) {\x0a  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_shared-key.js\x22:\x0a/*!*****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_shared-key.js ***!\x0a  \x5c*****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar shared = __webpack_require__(/*! ./_shared */ \x22./node_modules/core-js/modules/_shared.js\x22)(\x27keys\x27);\x0avar uid = __webpack_require__(/*! ./_uid */ \x22./node_modules/core-js/modules/_uid.js\x22);\x0amodule.exports = function (key) {\x0a  return shared[key] || (shared[key] = uid(key));\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_shared.js\x22:\x0a/*!*************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_shared.js ***!\x0a  \x5c*************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar core = __webpack_require__(/*! ./_core */ \x22./node_modules/core-js/modules/_core.js\x22);\x0avar global = __webpack_require__(/*! ./_global */ \x22./node_modules/core-js/modules/_global.js\x22);\x0avar SHARED = \x27__core-js_shared__\x27;\x0avar store = global[SHARED] || (global[SHARED] = {});\x0a\x0a(module.exports = function (key, value) {\x0a  return store[key] || (store[key] = value !== undefined ? value : {});\x0a})(\x27versions\x27, []).push({\x0a  version: core.version,\x0a  mode: __webpack_require__(/*! ./_library */ \x22./node_modules/core-js/modules/_library.js\x22) ? \x27pure\x27 : \x27global\x27,\x0a  copyright: \x27\xc2\xa9 2018 Denis Pushkarev (zloirock.ru)\x27\x0a});\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_to-absolute-index.js\x22:\x0a/*!************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!\x0a  \x5c************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar toInteger = __webpack_require__(/*! ./_to-integer */ \x22./node_modules/core-js/modules/_to-integer.js\x22);\x0avar max = Math.max;\x0avar min = Math.min;\x0amodule.exports = function (index, length) {\x0a  index = toInteger(index);\x0a  return index \x3c 0 ? max(index + length, 0) : min(index, length);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_to-integer.js\x22:\x0a/*!*****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_to-integer.js ***!\x0a  \x5c*****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0a// 7.1.4 ToInteger\x0avar ceil = Math.ceil;\x0avar floor = Math.floor;\x0amodule.exports = function (it) {\x0a  return isNaN(it = +it) ? 0 : (it \x3e 0 ? floor : ceil)(it);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_to-iobject.js\x22:\x0a/*!*****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_to-iobject.js ***!\x0a  \x5c*****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// to indexed object, toObject with fallback for non-array-like ES3 strings\x0avar IObject = __webpack_require__(/*! ./_iobject */ \x22./node_modules/core-js/modules/_iobject.js\x22);\x0avar defined = __webpack_require__(/*! ./_defined */ \x22./node_modules/core-js/modules/_defined.js\x22);\x0amodule.exports = function (it) {\x0a  return IObject(defined(it));\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_to-length.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_to-length.js ***!\x0a  \x5c****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// 7.1.15 ToLength\x0avar toInteger = __webpack_require__(/*! ./_to-integer */ \x22./node_modules/core-js/modules/_to-integer.js\x22);\x0avar min = Math.min;\x0amodule.exports = function (it) {\x0a  return it \x3e 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_to-object.js\x22:\x0a/*!****************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_to-object.js ***!\x0a  \x5c****************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// 7.1.13 ToObject(argument)\x0avar defined = __webpack_require__(/*! ./_defined */ \x22./node_modules/core-js/modules/_defined.js\x22);\x0amodule.exports = function (it) {\x0a  return Object(defined(it));\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_to-primitive.js\x22:\x0a/*!*******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_to-primitive.js ***!\x0a  \x5c*******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a// 7.1.1 ToPrimitive(input [, PreferredType])\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0a// instead of the ES6 spec version, we didn\x27t implement @@toPrimitive case\x0a// and the second argument - flag - preferred type is a string\x0amodule.exports = function (it, S) {\x0a  if (!isObject(it)) return it;\x0a  var fn, val;\x0a  if (S && typeof (fn = it.toString) == \x27function\x27 && !isObject(val = fn.call(it))) return val;\x0a  if (typeof (fn = it.valueOf) == \x27function\x27 && !isObject(val = fn.call(it))) return val;\x0a  if (!S && typeof (fn = it.toString) == \x27function\x27 && !isObject(val = fn.call(it))) return val;\x0a  throw TypeError(\x22Can\x27t convert object to primitive value\x22);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_uid.js\x22:\x0a/*!**********************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_uid.js ***!\x0a  \x5c**********************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports) {\x0a\x0avar id = 0;\x0avar px = Math.random();\x0amodule.exports = function (key) {\x0a  return \x27Symbol(\x27.concat(key === undefined ? \x27\x27 : key, \x27)_\x27, (++id + px).toString(36));\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_validate-collection.js\x22:\x0a/*!**************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_validate-collection.js ***!\x0a  \x5c**************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0amodule.exports = function (it, TYPE) {\x0a  if (!isObject(it) || it._t !== TYPE) throw TypeError(\x27Incompatible receiver, \x27 + TYPE + \x27 required!\x27);\x0a  return it;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/_wks.js\x22:\x0a/*!**********************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/_wks.js ***!\x0a  \x5c**********************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar store = __webpack_require__(/*! ./_shared */ \x22./node_modules/core-js/modules/_shared.js\x22)(\x27wks\x27);\x0avar uid = __webpack_require__(/*! ./_uid */ \x22./node_modules/core-js/modules/_uid.js\x22);\x0avar Symbol = __webpack_require__(/*! ./_global */ \x22./node_modules/core-js/modules/_global.js\x22).Symbol;\x0avar USE_SYMBOL = typeof Symbol == \x27function\x27;\x0a\x0avar $exports = module.exports = function (name) {\x0a  return store[name] || (store[name] =\x0a    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)(\x27Symbol.\x27 + name));\x0a};\x0a\x0a$exports.store = store;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/core.get-iterator-method.js\x22:\x0a/*!******************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!\x0a  \x5c******************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar classof = __webpack_require__(/*! ./_classof */ \x22./node_modules/core-js/modules/_classof.js\x22);\x0avar ITERATOR = __webpack_require__(/*! ./_wks */ \x22./node_modules/core-js/modules/_wks.js\x22)(\x27iterator\x27);\x0avar Iterators = __webpack_require__(/*! ./_iterators */ \x22./node_modules/core-js/modules/_iterators.js\x22);\x0amodule.exports = __webpack_require__(/*! ./_core */ \x22./node_modules/core-js/modules/_core.js\x22).getIteratorMethod = function (it) {\x0a  if (it != undefined) return it[ITERATOR]\x0a    || it[\x27@@iterator\x27]\x0a    || Iterators[classof(it)];\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es6.map.js\x22:\x0a/*!*************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es6.map.js ***!\x0a  \x5c*************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0avar strong = __webpack_require__(/*! ./_collection-strong */ \x22./node_modules/core-js/modules/_collection-strong.js\x22);\x0avar validate = __webpack_require__(/*! ./_validate-collection */ \x22./node_modules/core-js/modules/_validate-collection.js\x22);\x0avar MAP = \x27Map\x27;\x0a\x0a// 23.1 Map Objects\x0amodule.exports = __webpack_require__(/*! ./_collection */ \x22./node_modules/core-js/modules/_collection.js\x22)(MAP, function (get) {\x0a  return function Map() { return get(this, arguments.length \x3e 0 ? arguments[0] : undefined); };\x0a}, {\x0a  // 23.1.3.6 Map.prototype.get(key)\x0a  get: function get(key) {\x0a    var entry = strong.getEntry(validate(this, MAP), key);\x0a    return entry && entry.v;\x0a  },\x0a  // 23.1.3.9 Map.prototype.set(key, value)\x0a  set: function set(key, value) {\x0a    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);\x0a  }\x0a}, strong, true);\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es6.set.js\x22:\x0a/*!*************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es6.set.js ***!\x0a  \x5c*************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0avar strong = __webpack_require__(/*! ./_collection-strong */ \x22./node_modules/core-js/modules/_collection-strong.js\x22);\x0avar validate = __webpack_require__(/*! ./_validate-collection */ \x22./node_modules/core-js/modules/_validate-collection.js\x22);\x0avar SET = \x27Set\x27;\x0a\x0a// 23.2 Set Objects\x0amodule.exports = __webpack_require__(/*! ./_collection */ \x22./node_modules/core-js/modules/_collection.js\x22)(SET, function (get) {\x0a  return function Set() { return get(this, arguments.length \x3e 0 ? arguments[0] : undefined); };\x0a}, {\x0a  // 23.2.3.1 Set.prototype.add(value)\x0a  add: function add(value) {\x0a    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);\x0a  }\x0a}, strong);\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es6.weak-map.js\x22:\x0a/*!******************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es6.weak-map.js ***!\x0a  \x5c******************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0avar each = __webpack_require__(/*! ./_array-methods */ \x22./node_modules/core-js/modules/_array-methods.js\x22)(0);\x0avar redefine = __webpack_require__(/*! ./_redefine */ \x22./node_modules/core-js/modules/_redefine.js\x22);\x0avar meta = __webpack_require__(/*! ./_meta */ \x22./node_modules/core-js/modules/_meta.js\x22);\x0avar assign = __webpack_require__(/*! ./_object-assign */ \x22./node_modules/core-js/modules/_object-assign.js\x22);\x0avar weak = __webpack_require__(/*! ./_collection-weak */ \x22./node_modules/core-js/modules/_collection-weak.js\x22);\x0avar isObject = __webpack_require__(/*! ./_is-object */ \x22./node_modules/core-js/modules/_is-object.js\x22);\x0avar fails = __webpack_require__(/*! ./_fails */ \x22./node_modules/core-js/modules/_fails.js\x22);\x0avar validate = __webpack_require__(/*! ./_validate-collection */ \x22./node_modules/core-js/modules/_validate-collection.js\x22);\x0avar WEAK_MAP = \x27WeakMap\x27;\x0avar getWeak = meta.getWeak;\x0avar isExtensible = Object.isExtensible;\x0avar uncaughtFrozenStore = weak.ufstore;\x0avar tmp = {};\x0avar InternalMap;\x0a\x0avar wrapper = function (get) {\x0a  return function WeakMap() {\x0a    return get(this, arguments.length \x3e 0 ? arguments[0] : undefined);\x0a  };\x0a};\x0a\x0avar methods = {\x0a  // 23.3.3.3 WeakMap.prototype.get(key)\x0a  get: function get(key) {\x0a    if (isObject(key)) {\x0a      var data = getWeak(key);\x0a      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\x0a      return data ? data[this._i] : undefined;\x0a    }\x0a  },\x0a  // 23.3.3.5 WeakMap.prototype.set(key, value)\x0a  set: function set(key, value) {\x0a    return weak.def(validate(this, WEAK_MAP), key, value);\x0a  }\x0a};\x0a\x0a// 23.3 WeakMap Objects\x0avar $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ \x22./node_modules/core-js/modules/_collection.js\x22)(WEAK_MAP, wrapper, methods, weak, true, true);\x0a\x0a// IE11 WeakMap frozen keys fix\x0aif (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {\x0a  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\x0a  assign(InternalMap.prototype, methods);\x0a  meta.NEED = true;\x0a  each([\x27delete\x27, \x27has\x27, \x27get\x27, \x27set\x27], function (key) {\x0a    var proto = $WeakMap.prototype;\x0a    var method = proto[key];\x0a    redefine(proto, key, function (a, b) {\x0a      // store frozen objects on internal weakmap shim\x0a      if (isObject(a) && !isExtensible(a)) {\x0a        if (!this._f) this._f = new InternalMap();\x0a        var result = this._f[key](a, b);\x0a        return key == \x27set\x27 ? this : result;\x0a      // store all the rest on native weakmap\x0a      } return method.call(this, a, b);\x0a    });\x0a  });\x0a}\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es7.reflect.define-metadata.js\x22:\x0a/*!*********************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es7.reflect.define-metadata.js ***!\x0a  \x5c*********************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar metadata = __webpack_require__(/*! ./_metadata */ \x22./node_modules/core-js/modules/_metadata.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar toMetaKey = metadata.key;\x0avar ordinaryDefineOwnMetadata = metadata.set;\x0a\x0ametadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {\x0a  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));\x0a} });\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es7.reflect.delete-metadata.js\x22:\x0a/*!*********************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es7.reflect.delete-metadata.js ***!\x0a  \x5c*********************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar metadata = __webpack_require__(/*! ./_metadata */ \x22./node_modules/core-js/modules/_metadata.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar toMetaKey = metadata.key;\x0avar getOrCreateMetadataMap = metadata.map;\x0avar store = metadata.store;\x0a\x0ametadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {\x0a  var targetKey = arguments.length \x3c 3 ? undefined : toMetaKey(arguments[2]);\x0a  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);\x0a  if (metadataMap === undefined || !metadataMap[\x27delete\x27](metadataKey)) return false;\x0a  if (metadataMap.size) return true;\x0a  var targetMetadata = store.get(target);\x0a  targetMetadata[\x27delete\x27](targetKey);\x0a  return !!targetMetadata.size || store[\x27delete\x27](target);\x0a} });\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js\x22:\x0a/*!***********************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js ***!\x0a  \x5c***********************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar Set = __webpack_require__(/*! ./es6.set */ \x22./node_modules/core-js/modules/es6.set.js\x22);\x0avar from = __webpack_require__(/*! ./_array-from-iterable */ \x22./node_modules/core-js/modules/_array-from-iterable.js\x22);\x0avar metadata = __webpack_require__(/*! ./_metadata */ \x22./node_modules/core-js/modules/_metadata.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ \x22./node_modules/core-js/modules/_object-gpo.js\x22);\x0avar ordinaryOwnMetadataKeys = metadata.keys;\x0avar toMetaKey = metadata.key;\x0a\x0avar ordinaryMetadataKeys = function (O, P) {\x0a  var oKeys = ordinaryOwnMetadataKeys(O, P);\x0a  var parent = getPrototypeOf(O);\x0a  if (parent === null) return oKeys;\x0a  var pKeys = ordinaryMetadataKeys(parent, P);\x0a  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;\x0a};\x0a\x0ametadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {\x0a  return ordinaryMetadataKeys(anObject(target), arguments.length \x3c 2 ? undefined : toMetaKey(arguments[1]));\x0a} });\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es7.reflect.get-metadata.js\x22:\x0a/*!******************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es7.reflect.get-metadata.js ***!\x0a  \x5c******************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar metadata = __webpack_require__(/*! ./_metadata */ \x22./node_modules/core-js/modules/_metadata.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ \x22./node_modules/core-js/modules/_object-gpo.js\x22);\x0avar ordinaryHasOwnMetadata = metadata.has;\x0avar ordinaryGetOwnMetadata = metadata.get;\x0avar toMetaKey = metadata.key;\x0a\x0avar ordinaryGetMetadata = function (MetadataKey, O, P) {\x0a  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\x0a  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);\x0a  var parent = getPrototypeOf(O);\x0a  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;\x0a};\x0a\x0ametadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {\x0a  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length \x3c 3 ? undefined : toMetaKey(arguments[2]));\x0a} });\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js\x22:\x0a/*!***************************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js ***!\x0a  \x5c***************************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar metadata = __webpack_require__(/*! ./_metadata */ \x22./node_modules/core-js/modules/_metadata.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar ordinaryOwnMetadataKeys = metadata.keys;\x0avar toMetaKey = metadata.key;\x0a\x0ametadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {\x0a  return ordinaryOwnMetadataKeys(anObject(target), arguments.length \x3c 2 ? undefined : toMetaKey(arguments[1]));\x0a} });\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es7.reflect.get-own-metadata.js\x22:\x0a/*!**********************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es7.reflect.get-own-metadata.js ***!\x0a  \x5c**********************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar metadata = __webpack_require__(/*! ./_metadata */ \x22./node_modules/core-js/modules/_metadata.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar ordinaryGetOwnMetadata = metadata.get;\x0avar toMetaKey = metadata.key;\x0a\x0ametadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {\x0a  return ordinaryGetOwnMetadata(metadataKey, anObject(target)\x0a    , arguments.length \x3c 3 ? undefined : toMetaKey(arguments[2]));\x0a} });\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es7.reflect.has-metadata.js\x22:\x0a/*!******************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es7.reflect.has-metadata.js ***!\x0a  \x5c******************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar metadata = __webpack_require__(/*! ./_metadata */ \x22./node_modules/core-js/modules/_metadata.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ \x22./node_modules/core-js/modules/_object-gpo.js\x22);\x0avar ordinaryHasOwnMetadata = metadata.has;\x0avar toMetaKey = metadata.key;\x0a\x0avar ordinaryHasMetadata = function (MetadataKey, O, P) {\x0a  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\x0a  if (hasOwn) return true;\x0a  var parent = getPrototypeOf(O);\x0a  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;\x0a};\x0a\x0ametadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {\x0a  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length \x3c 3 ? undefined : toMetaKey(arguments[2]));\x0a} });\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es7.reflect.has-own-metadata.js\x22:\x0a/*!**********************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es7.reflect.has-own-metadata.js ***!\x0a  \x5c**********************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar metadata = __webpack_require__(/*! ./_metadata */ \x22./node_modules/core-js/modules/_metadata.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar ordinaryHasOwnMetadata = metadata.has;\x0avar toMetaKey = metadata.key;\x0a\x0ametadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {\x0a  return ordinaryHasOwnMetadata(metadataKey, anObject(target)\x0a    , arguments.length \x3c 3 ? undefined : toMetaKey(arguments[2]));\x0a} });\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/core-js/modules/es7.reflect.metadata.js\x22:\x0a/*!**************************************************************!*\x5c\x0a  !*** ./node_modules/core-js/modules/es7.reflect.metadata.js ***!\x0a  \x5c**************************************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar $metadata = __webpack_require__(/*! ./_metadata */ \x22./node_modules/core-js/modules/_metadata.js\x22);\x0avar anObject = __webpack_require__(/*! ./_an-object */ \x22./node_modules/core-js/modules/_an-object.js\x22);\x0avar aFunction = __webpack_require__(/*! ./_a-function */ \x22./node_modules/core-js/modules/_a-function.js\x22);\x0avar toMetaKey = $metadata.key;\x0avar ordinaryDefineOwnMetadata = $metadata.set;\x0a\x0a$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {\x0a  return function decorator(target, targetKey) {\x0a    ordinaryDefineOwnMetadata(\x0a      metadataKey, metadataValue,\x0a      (targetKey !== undefined ? anObject : aFunction)(target),\x0a      toMetaKey(targetKey)\x0a    );\x0a  };\x0a} });\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./node_modules/zone.js/dist/zone.js\x22:\x0a/*!*******************************************!*\x5c\x0a  !*** ./node_modules/zone.js/dist/zone.js ***!\x0a  \x5c*******************************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a/**\x0a* @license\x0a* Copyright Google Inc. All Rights Reserved.\x0a*\x0a* Use of this source code is governed by an MIT-style license that can be\x0a* found in the LICENSE file at https://angular.io/license\x0a*/\x0a(function (global, factory) {\x0a\x09 true ? factory() :\x0a\x09undefined;\x0a}(this, (function () { \x27use strict\x27;\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0avar Zone$1 = (function (global) {\x0a    var FUNCTION = \x27function\x27;\x0a    var performance = global[\x27performance\x27];\x0a    function mark(name) {\x0a        performance && performance[\x27mark\x27] && performance[\x27mark\x27](name);\x0a    }\x0a    function performanceMeasure(name, label) {\x0a        performance && performance[\x27measure\x27] && performance[\x27measure\x27](name, label);\x0a    }\x0a    mark(\x27Zone\x27);\x0a    if (global[\x27Zone\x27]) {\x0a        throw new Error(\x27Zone already loaded.\x27);\x0a    }\x0a    var Zone = /** @class */ (function () {\x0a        function Zone(parent, zoneSpec) {\x0a            this._properties = null;\x0a            this._parent = parent;\x0a            this._name = zoneSpec ? zoneSpec.name || \x27unnamed\x27 : \x27\x3croot\x3e\x27;\x0a            this._properties = zoneSpec && zoneSpec.properties || {};\x0a            this._zoneDelegate =\x0a                new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\x0a        }\x0a        Zone.assertZonePatched = function () {\x0a            if (global[\x27Promise\x27] !== patches[\x27ZoneAwarePromise\x27]) {\x0a                throw new Error(\x27Zone.js has detected that ZoneAwarePromise `(window|global).Promise` \x27 +\x0a                    \x27has been overwritten.\x5cn\x27 +\x0a                    \x27Most likely cause is that a Promise polyfill has been loaded \x27 +\x0a                    \x27after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. \x27 +\x0a                    \x27If you must load one, do so before loading zone.js.)\x27);\x0a            }\x0a        };\x0a        Object.defineProperty(Zone, \x22root\x22, {\x0a            get: function () {\x0a                var zone = Zone.current;\x0a                while (zone.parent) {\x0a                    zone = zone.parent;\x0a                }\x0a                return zone;\x0a            },\x0a            enumerable: true,\x0a            configurable: true\x0a        });\x0a        Object.defineProperty(Zone, \x22current\x22, {\x0a            get: function () {\x0a                return _currentZoneFrame.zone;\x0a            },\x0a            enumerable: true,\x0a            configurable: true\x0a        });\x0a        Object.defineProperty(Zone, \x22currentTask\x22, {\x0a            get: function () {\x0a                return _currentTask;\x0a            },\x0a            enumerable: true,\x0a            configurable: true\x0a        });\x0a        Zone.__load_patch = function (name, fn) {\x0a            if (patches.hasOwnProperty(name)) {\x0a                throw Error(\x27Already loaded patch: \x27 + name);\x0a            }\x0a            else if (!global[\x27__Zone_disable_\x27 + name]) {\x0a                var perfName = \x27Zone:\x27 + name;\x0a                mark(perfName);\x0a                patches[name] = fn(global, Zone, _api);\x0a                performanceMeasure(perfName, perfName);\x0a            }\x0a        };\x0a        Object.defineProperty(Zone.prototype, \x22parent\x22, {\x0a            get: function () {\x0a                return this._parent;\x0a            },\x0a            enumerable: true,\x0a            configurable: true\x0a        });\x0a        Object.defineProperty(Zone.prototype, \x22name\x22, {\x0a            get: function () {\x0a                return this._name;\x0a            },\x0a            enumerable: true,\x0a            configurable: true\x0a        });\x0a        Zone.prototype.get = function (key) {\x0a            var zone = this.getZoneWith(key);\x0a            if (zone)\x0a                return zone._properties[key];\x0a        };\x0a        Zone.prototype.getZoneWith = function (key) {\x0a            var current = this;\x0a            while (current) {\x0a                if (current._properties.hasOwnProperty(key)) {\x0a                    return current;\x0a                }\x0a                current = current._parent;\x0a            }\x0a            return null;\x0a        };\x0a        Zone.prototype.fork = function (zoneSpec) {\x0a            if (!zoneSpec)\x0a                throw new Error(\x27ZoneSpec required!\x27);\x0a            return this._zoneDelegate.fork(this, zoneSpec);\x0a        };\x0a        Zone.prototype.wrap = function (callback, source) {\x0a            if (typeof callback !== FUNCTION) {\x0a                throw new Error(\x27Expecting function got: \x27 + callback);\x0a            }\x0a            var _callback = this._zoneDelegate.intercept(this, callback, source);\x0a            var zone = this;\x0a            return function () {\x0a                return zone.runGuarded(_callback, this, arguments, source);\x0a            };\x0a        };\x0a        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {\x0a            if (applyThis === void 0) { applyThis = undefined; }\x0a            if (applyArgs === void 0) { applyArgs = null; }\x0a            if (source === void 0) { source = null; }\x0a            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\x0a            try {\x0a                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\x0a            }\x0a            finally {\x0a                _currentZoneFrame = _currentZoneFrame.parent;\x0a            }\x0a        };\x0a        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {\x0a            if (applyThis === void 0) { applyThis = null; }\x0a            if (applyArgs === void 0) { applyArgs = null; }\x0a            if (source === void 0) { source = null; }\x0a            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\x0a            try {\x0a                try {\x0a                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\x0a                }\x0a                catch (error) {\x0a                    if (this._zoneDelegate.handleError(this, error)) {\x0a                        throw error;\x0a                    }\x0a                }\x0a            }\x0a            finally {\x0a                _currentZoneFrame = _currentZoneFrame.parent;\x0a            }\x0a        };\x0a        Zone.prototype.runTask = function (task, applyThis, applyArgs) {\x0a            if (task.zone != this) {\x0a                throw new Error(\x27A task can only be run in the zone of creation! (Creation: \x27 +\x0a                    (task.zone || NO_ZONE).name + \x27; Execution: \x27 + this.name + \x27)\x27);\x0a            }\x0a            // https://github.com/angular/zone.js/issues/778, sometimes eventTask\x0a            // will run in notScheduled(canceled) state, we should not try to\x0a            // run such kind of task but just return\x0a            // we have to define an variable here, if not\x0a            // typescript compiler will complain below\x0a            var isNotScheduled = task.state === notScheduled;\x0a            if (isNotScheduled && task.type === eventTask) {\x0a                return;\x0a            }\x0a            var reEntryGuard = task.state != running;\x0a            reEntryGuard && task._transitionTo(running, scheduled);\x0a            task.runCount++;\x0a            var previousTask = _currentTask;\x0a            _currentTask = task;\x0a            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\x0a            try {\x0a                if (task.type == macroTask && task.data && !task.data.isPeriodic) {\x0a                    task.cancelFn = null;\x0a                }\x0a                try {\x0a                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\x0a                }\x0a                catch (error) {\x0a                    if (this._zoneDelegate.handleError(this, error)) {\x0a                        throw error;\x0a                    }\x0a                }\x0a            }\x0a            finally {\x0a                // if the task\x27s state is notScheduled or unknown, then it has already been cancelled\x0a                // we should not reset the state to scheduled\x0a                if (task.state !== notScheduled && task.state !== unknown) {\x0a                    if (task.type == eventTask || (task.data && task.data.isPeriodic)) {\x0a                        reEntryGuard && task._transitionTo(scheduled, running);\x0a                    }\x0a                    else {\x0a                        task.runCount = 0;\x0a                        this._updateTaskCount(task, -1);\x0a                        reEntryGuard &&\x0a                            task._transitionTo(notScheduled, running, notScheduled);\x0a                    }\x0a                }\x0a                _currentZoneFrame = _currentZoneFrame.parent;\x0a                _currentTask = previousTask;\x0a            }\x0a        };\x0a        Zone.prototype.scheduleTask = function (task) {\x0a            if (task.zone && task.zone !== this) {\x0a                // check if the task was rescheduled, the newZone\x0a                // should not be the children of the original zone\x0a                var newZone = this;\x0a                while (newZone) {\x0a                    if (newZone === task.zone) {\x0a                        throw Error(\x22can not reschedule task to \x22 + this\x0a                            .name + \x22 which is descendants of the original zone \x22 + task.zone.name);\x0a                    }\x0a                    newZone = newZone.parent;\x0a                }\x0a            }\x0a            task._transitionTo(scheduling, notScheduled);\x0a            var zoneDelegates = [];\x0a            task._zoneDelegates = zoneDelegates;\x0a            task._zone = this;\x0a            try {\x0a                task = this._zoneDelegate.scheduleTask(this, task);\x0a            }\x0a            catch (err) {\x0a                // should set task\x27s state to unknown when scheduleTask throw error\x0a                // because the err may from reschedule, so the fromState maybe notScheduled\x0a                task._transitionTo(unknown, scheduling, notScheduled);\x0a                // TODO: @JiaLiPassion, should we check the result from handleError?\x0a                this._zoneDelegate.handleError(this, err);\x0a                throw err;\x0a            }\x0a            if (task._zoneDelegates === zoneDelegates) {\x0a                // we have to check because internally the delegate can reschedule the task.\x0a                this._updateTaskCount(task, 1);\x0a            }\x0a            if (task.state == scheduling) {\x0a                task._transitionTo(scheduled, scheduling);\x0a            }\x0a            return task;\x0a        };\x0a        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {\x0a            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, null));\x0a        };\x0a        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {\x0a            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\x0a        };\x0a        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {\x0a            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\x0a        };\x0a        Zone.prototype.cancelTask = function (task) {\x0a            if (task.zone != this)\x0a                throw new Error(\x27A task can only be cancelled in the zone of creation! (Creation: \x27 +\x0a                    (task.zone || NO_ZONE).name + \x27; Execution: \x27 + this.name + \x27)\x27);\x0a            task._transitionTo(canceling, scheduled, running);\x0a            try {\x0a                this._zoneDelegate.cancelTask(this, task);\x0a            }\x0a            catch (err) {\x0a                // if error occurs when cancelTask, transit the state to unknown\x0a                task._transitionTo(unknown, canceling);\x0a                this._zoneDelegate.handleError(this, err);\x0a                throw err;\x0a            }\x0a            this._updateTaskCount(task, -1);\x0a            task._transitionTo(notScheduled, canceling);\x0a            task.runCount = 0;\x0a            return task;\x0a        };\x0a        Zone.prototype._updateTaskCount = function (task, count) {\x0a            var zoneDelegates = task._zoneDelegates;\x0a            if (count == -1) {\x0a                task._zoneDelegates = null;\x0a            }\x0a            for (var i = 0; i \x3c zoneDelegates.length; i++) {\x0a                zoneDelegates[i]._updateTaskCount(task.type, count);\x0a            }\x0a        };\x0a        Zone.__symbol__ = __symbol__;\x0a        return Zone;\x0a    }());\x0a    var DELEGATE_ZS = {\x0a        name: \x27\x27,\x0a        onHasTask: function (delegate, _, target, hasTaskState) {\x0a            return delegate.hasTask(target, hasTaskState);\x0a        },\x0a        onScheduleTask: function (delegate, _, target, task) {\x0a            return delegate.scheduleTask(target, task);\x0a        },\x0a        onInvokeTask: function (delegate, _, target, task, applyThis, applyArgs) { return delegate.invokeTask(target, task, applyThis, applyArgs); },\x0a        onCancelTask: function (delegate, _, target, task) {\x0a            return delegate.cancelTask(target, task);\x0a        }\x0a    };\x0a    var ZoneDelegate = /** @class */ (function () {\x0a        function ZoneDelegate(zone, parentDelegate, zoneSpec) {\x0a            this._taskCounts = { \x27microTask\x27: 0, \x27macroTask\x27: 0, \x27eventTask\x27: 0 };\x0a            this.zone = zone;\x0a            this._parentDelegate = parentDelegate;\x0a            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\x0a            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\x0a            this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate.zone);\x0a            this._interceptZS =\x0a                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\x0a            this._interceptDlgt =\x0a                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\x0a            this._interceptCurrZone =\x0a                zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);\x0a            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\x0a            this._invokeDlgt =\x0a                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\x0a            this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);\x0a            this._handleErrorZS =\x0a                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\x0a            this._handleErrorDlgt =\x0a                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\x0a            this._handleErrorCurrZone =\x0a                zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);\x0a            this._scheduleTaskZS =\x0a                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\x0a            this._scheduleTaskDlgt =\x0a                zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\x0a            this._scheduleTaskCurrZone =\x0a                zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);\x0a            this._invokeTaskZS =\x0a                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\x0a            this._invokeTaskDlgt =\x0a                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\x0a            this._invokeTaskCurrZone =\x0a                zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);\x0a            this._cancelTaskZS =\x0a                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\x0a            this._cancelTaskDlgt =\x0a                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\x0a            this._cancelTaskCurrZone =\x0a                zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);\x0a            this._hasTaskZS = null;\x0a            this._hasTaskDlgt = null;\x0a            this._hasTaskDlgtOwner = null;\x0a            this._hasTaskCurrZone = null;\x0a            var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\x0a            var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\x0a            if (zoneSpecHasTask || parentHasTask) {\x0a                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such\x0a                // a case all task related interceptors must go through this ZD. We can\x27t short circuit it.\x0a                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\x0a                this._hasTaskDlgt = parentDelegate;\x0a                this._hasTaskDlgtOwner = this;\x0a                this._hasTaskCurrZone = zone;\x0a                if (!zoneSpec.onScheduleTask) {\x0a                    this._scheduleTaskZS = DELEGATE_ZS;\x0a                    this._scheduleTaskDlgt = parentDelegate;\x0a                    this._scheduleTaskCurrZone = this.zone;\x0a                }\x0a                if (!zoneSpec.onInvokeTask) {\x0a                    this._invokeTaskZS = DELEGATE_ZS;\x0a                    this._invokeTaskDlgt = parentDelegate;\x0a                    this._invokeTaskCurrZone = this.zone;\x0a                }\x0a                if (!zoneSpec.onCancelTask) {\x0a                    this._cancelTaskZS = DELEGATE_ZS;\x0a                    this._cancelTaskDlgt = parentDelegate;\x0a                    this._cancelTaskCurrZone = this.zone;\x0a                }\x0a            }\x0a        }\x0a        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {\x0a            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :\x0a                new Zone(targetZone, zoneSpec);\x0a        };\x0a        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {\x0a            return this._interceptZS ?\x0a                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :\x0a                callback;\x0a        };\x0a        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {\x0a            return this._invokeZS ?\x0a                this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :\x0a                callback.apply(applyThis, applyArgs);\x0a        };\x0a        ZoneDelegate.prototype.handleError = function (targetZone, error) {\x0a            return this._handleErrorZS ?\x0a                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :\x0a                true;\x0a        };\x0a        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {\x0a            var returnTask = task;\x0a            if (this._scheduleTaskZS) {\x0a                if (this._hasTaskZS) {\x0a                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\x0a                }\x0a                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\x0a                if (!returnTask)\x0a                    returnTask = task;\x0a            }\x0a            else {\x0a                if (task.scheduleFn) {\x0a                    task.scheduleFn(task);\x0a                }\x0a                else if (task.type == microTask) {\x0a                    scheduleMicroTask(task);\x0a                }\x0a                else {\x0a                    throw new Error(\x27Task is missing scheduleFn.\x27);\x0a                }\x0a            }\x0a            return returnTask;\x0a        };\x0a        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {\x0a            return this._invokeTaskZS ?\x0a                this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :\x0a                task.callback.apply(applyThis, applyArgs);\x0a        };\x0a        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {\x0a            var value;\x0a            if (this._cancelTaskZS) {\x0a                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\x0a            }\x0a            else {\x0a                if (!task.cancelFn) {\x0a                    throw Error(\x27Task is not cancelable\x27);\x0a                }\x0a                value = task.cancelFn(task);\x0a            }\x0a            return value;\x0a        };\x0a        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {\x0a            // hasTask should not throw error so other ZoneDelegate\x0a            // can still trigger hasTask callback\x0a            try {\x0a                return this._hasTaskZS &&\x0a                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\x0a            }\x0a            catch (err) {\x0a                this.handleError(targetZone, err);\x0a            }\x0a        };\x0a        ZoneDelegate.prototype._updateTaskCount = function (type, count) {\x0a            var counts = this._taskCounts;\x0a            var prev = counts[type];\x0a            var next = counts[type] = prev + count;\x0a            if (next \x3c 0) {\x0a                throw new Error(\x27More tasks executed then were scheduled.\x27);\x0a            }\x0a            if (prev == 0 || next == 0) {\x0a                var isEmpty = {\x0a                    microTask: counts[\x27microTask\x27] \x3e 0,\x0a                    macroTask: counts[\x27macroTask\x27] \x3e 0,\x0a                    eventTask: counts[\x27eventTask\x27] \x3e 0,\x0a                    change: type\x0a                };\x0a                this.hasTask(this.zone, isEmpty);\x0a            }\x0a        };\x0a        return ZoneDelegate;\x0a    }());\x0a    var ZoneTask = /** @class */ (function () {\x0a        function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {\x0a            this._zone = null;\x0a            this.runCount = 0;\x0a            this._zoneDelegates = null;\x0a            this._state = \x27notScheduled\x27;\x0a            this.type = type;\x0a            this.source = source;\x0a            this.data = options;\x0a            this.scheduleFn = scheduleFn;\x0a            this.cancelFn = cancelFn;\x0a            this.callback = callback;\x0a            var self = this;\x0a            // TODO: @JiaLiPassion options should have interface\x0a            if (type === eventTask && options && options.useG) {\x0a                this.invoke = ZoneTask.invokeTask;\x0a            }\x0a            else {\x0a                this.invoke = function () {\x0a                    return ZoneTask.invokeTask.call(global, self, this, arguments);\x0a                };\x0a            }\x0a        }\x0a        ZoneTask.invokeTask = function (task, target, args) {\x0a            if (!task) {\x0a                task = this;\x0a            }\x0a            _numberOfNestedTaskFrames++;\x0a            try {\x0a                task.runCount++;\x0a                return task.zone.runTask(task, target, args);\x0a            }\x0a            finally {\x0a                if (_numberOfNestedTaskFrames == 1) {\x0a                    drainMicroTaskQueue();\x0a                }\x0a                _numberOfNestedTaskFrames--;\x0a            }\x0a        };\x0a        Object.defineProperty(ZoneTask.prototype, \x22zone\x22, {\x0a            get: function () {\x0a                return this._zone;\x0a            },\x0a            enumerable: true,\x0a            configurable: true\x0a        });\x0a        Object.defineProperty(ZoneTask.prototype, \x22state\x22, {\x0a            get: function () {\x0a                return this._state;\x0a            },\x0a            enumerable: true,\x0a            configurable: true\x0a        });\x0a        ZoneTask.prototype.cancelScheduleRequest = function () {\x0a            this._transitionTo(notScheduled, scheduling);\x0a        };\x0a        ZoneTask.prototype._transitionTo = function (toState, fromState1, fromState2) {\x0a            if (this._state === fromState1 || this._state === fromState2) {\x0a                this._state = toState;\x0a                if (toState == notScheduled) {\x0a                    this._zoneDelegates = null;\x0a                }\x0a            }\x0a            else {\x0a                throw new Error(this.type + \x22 \x27\x22 + this.source + \x22\x27: can not transition to \x27\x22 + toState + \x22\x27, expecting state \x27\x22 + fromState1 + \x22\x27\x22 + (fromState2 ?\x0a                    \x27 or \x5c\x27\x27 + fromState2 + \x27\x5c\x27\x27 :\x0a                    \x27\x27) + \x22, was \x27\x22 + this._state + \x22\x27.\x22);\x0a            }\x0a        };\x0a        ZoneTask.prototype.toString = function () {\x0a            if (this.data && typeof this.data.handleId !== \x27undefined\x27) {\x0a                return this.data.handleId;\x0a            }\x0a            else {\x0a                return Object.prototype.toString.call(this);\x0a            }\x0a        };\x0a        // add toJSON method to prevent cyclic error when\x0a        // call JSON.stringify(zoneTask)\x0a        ZoneTask.prototype.toJSON = function () {\x0a            return {\x0a                type: this.type,\x0a                state: this.state,\x0a                source: this.source,\x0a                zone: this.zone.name,\x0a                runCount: this.runCount\x0a            };\x0a        };\x0a        return ZoneTask;\x0a    }());\x0a    //////////////////////////////////////////////////////\x0a    //////////////////////////////////////////////////////\x0a    ///  MICROTASK QUEUE\x0a    //////////////////////////////////////////////////////\x0a    //////////////////////////////////////////////////////\x0a    var symbolSetTimeout = __symbol__(\x27setTimeout\x27);\x0a    var symbolPromise = __symbol__(\x27Promise\x27);\x0a    var symbolThen = __symbol__(\x27then\x27);\x0a    var _microTaskQueue = [];\x0a    var _isDrainingMicrotaskQueue = false;\x0a    var nativeMicroTaskQueuePromise;\x0a    function scheduleMicroTask(task) {\x0a        // if we are not running in any task, and there has not been anything scheduled\x0a        // we must bootstrap the initial task creation by manually scheduling the drain\x0a        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\x0a            // We are not running in Task, so we need to kickstart the microtask queue.\x0a            if (!nativeMicroTaskQueuePromise) {\x0a                if (global[symbolPromise]) {\x0a                    nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);\x0a                }\x0a            }\x0a            if (nativeMicroTaskQueuePromise) {\x0a                nativeMicroTaskQueuePromise[symbolThen](drainMicroTaskQueue);\x0a            }\x0a            else {\x0a                global[symbolSetTimeout](drainMicroTaskQueue, 0);\x0a            }\x0a        }\x0a        task && _microTaskQueue.push(task);\x0a    }\x0a    function drainMicroTaskQueue() {\x0a        if (!_isDrainingMicrotaskQueue) {\x0a            _isDrainingMicrotaskQueue = true;\x0a            while (_microTaskQueue.length) {\x0a                var queue = _microTaskQueue;\x0a                _microTaskQueue = [];\x0a                for (var i = 0; i \x3c queue.length; i++) {\x0a                    var task = queue[i];\x0a                    try {\x0a                        task.zone.runTask(task, null, null);\x0a                    }\x0a                    catch (error) {\x0a                        _api.onUnhandledError(error);\x0a                    }\x0a                }\x0a            }\x0a            _api.microtaskDrainDone();\x0a            _isDrainingMicrotaskQueue = false;\x0a        }\x0a    }\x0a    //////////////////////////////////////////////////////\x0a    //////////////////////////////////////////////////////\x0a    ///  BOOTSTRAP\x0a    //////////////////////////////////////////////////////\x0a    //////////////////////////////////////////////////////\x0a    var NO_ZONE = { name: \x27NO ZONE\x27 };\x0a    var notScheduled = \x27notScheduled\x27, scheduling = \x27scheduling\x27, scheduled = \x27scheduled\x27, running = \x27running\x27, canceling = \x27canceling\x27, unknown = \x27unknown\x27;\x0a    var microTask = \x27microTask\x27, macroTask = \x27macroTask\x27, eventTask = \x27eventTask\x27;\x0a    var patches = {};\x0a    var _api = {\x0a        symbol: __symbol__,\x0a        currentZoneFrame: function () { return _currentZoneFrame; },\x0a        onUnhandledError: noop,\x0a        microtaskDrainDone: noop,\x0a        scheduleMicroTask: scheduleMicroTask,\x0a        showUncaughtError: function () { return !Zone[__symbol__(\x27ignoreConsoleErrorUncaughtError\x27)]; },\x0a        patchEventTarget: function () { return []; },\x0a        patchOnProperties: noop,\x0a        patchMethod: function () { return noop; },\x0a        bindArguments: function () { return null; },\x0a        setNativePromise: function (NativePromise) {\x0a            // sometimes NativePromise.resolve static function\x0a            // is not ready yet, (such as core-js/es6.promise)\x0a            // so we need to check here.\x0a            if (NativePromise && typeof NativePromise.resolve === FUNCTION) {\x0a                nativeMicroTaskQueuePromise = NativePromise.resolve(0);\x0a            }\x0a        },\x0a    };\x0a    var _currentZoneFrame = { parent: null, zone: new Zone(null, null) };\x0a    var _currentTask = null;\x0a    var _numberOfNestedTaskFrames = 0;\x0a    function noop() { }\x0a    function __symbol__(name) {\x0a        return \x27__zone_symbol__\x27 + name;\x0a    }\x0a    performanceMeasure(\x27Zone\x27, \x27Zone\x27);\x0a    return global[\x27Zone\x27] = Zone;\x0a})(typeof window !== \x27undefined\x27 && window || typeof self !== \x27undefined\x27 && self || global);\x0a\x0aZone.__load_patch(\x27ZoneAwarePromise\x27, function (global, Zone, api) {\x0a    var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\x0a    var ObjectDefineProperty = Object.defineProperty;\x0a    function readableObjectToString(obj) {\x0a        if (obj && obj.toString === Object.prototype.toString) {\x0a            var className = obj.constructor && obj.constructor.name;\x0a            return (className ? className : \x27\x27) + \x27: \x27 + JSON.stringify(obj);\x0a        }\x0a        return obj ? obj.toString() : Object.prototype.toString.call(obj);\x0a    }\x0a    var __symbol__ = api.symbol;\x0a    var _uncaughtPromiseErrors = [];\x0a    var symbolPromise = __symbol__(\x27Promise\x27);\x0a    var symbolThen = __symbol__(\x27then\x27);\x0a    var creationTrace = \x27__creationTrace__\x27;\x0a    api.onUnhandledError = function (e) {\x0a        if (api.showUncaughtError()) {\x0a            var rejection = e && e.rejection;\x0a            if (rejection) {\x0a                console.error(\x27Unhandled Promise rejection:\x27, rejection instanceof Error ? rejection.message : rejection, \x27; Zone:\x27, e.zone.name, \x27; Task:\x27, e.task && e.task.source, \x27; Value:\x27, rejection, rejection instanceof Error ? rejection.stack : undefined);\x0a            }\x0a            else {\x0a                console.error(e);\x0a            }\x0a        }\x0a    };\x0a    api.microtaskDrainDone = function () {\x0a        while (_uncaughtPromiseErrors.length) {\x0a            var _loop_1 = function () {\x0a                var uncaughtPromiseError = _uncaughtPromiseErrors.shift();\x0a                try {\x0a                    uncaughtPromiseError.zone.runGuarded(function () {\x0a                        throw uncaughtPromiseError;\x0a                    });\x0a                }\x0a                catch (error) {\x0a                    handleUnhandledRejection(error);\x0a                }\x0a            };\x0a            while (_uncaughtPromiseErrors.length) {\x0a                _loop_1();\x0a            }\x0a        }\x0a    };\x0a    var UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__(\x27unhandledPromiseRejectionHandler\x27);\x0a    function handleUnhandledRejection(e) {\x0a        api.onUnhandledError(e);\x0a        try {\x0a            var handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];\x0a            if (handler && typeof handler === \x27function\x27) {\x0a                handler.call(this, e);\x0a            }\x0a        }\x0a        catch (err) {\x0a        }\x0a    }\x0a    function isThenable(value) {\x0a        return value && value.then;\x0a    }\x0a    function forwardResolution(value) {\x0a        return value;\x0a    }\x0a    function forwardRejection(rejection) {\x0a        return ZoneAwarePromise.reject(rejection);\x0a    }\x0a    var symbolState = __symbol__(\x27state\x27);\x0a    var symbolValue = __symbol__(\x27value\x27);\x0a    var symbolFinally = __symbol__(\x27finally\x27);\x0a    var symbolParentPromiseValue = __symbol__(\x27parentPromiseValue\x27);\x0a    var symbolParentPromiseState = __symbol__(\x27parentPromiseState\x27);\x0a    var source = \x27Promise.then\x27;\x0a    var UNRESOLVED = null;\x0a    var RESOLVED = true;\x0a    var REJECTED = false;\x0a    var REJECTED_NO_CATCH = 0;\x0a    function makeResolver(promise, state) {\x0a        return function (v) {\x0a            try {\x0a                resolvePromise(promise, state, v);\x0a            }\x0a            catch (err) {\x0a                resolvePromise(promise, false, err);\x0a            }\x0a            // Do not return value or you will break the Promise spec.\x0a        };\x0a    }\x0a    var once = function () {\x0a        var wasCalled = false;\x0a        return function wrapper(wrappedFunction) {\x0a            return function () {\x0a                if (wasCalled) {\x0a                    return;\x0a                }\x0a                wasCalled = true;\x0a                wrappedFunction.apply(null, arguments);\x0a            };\x0a        };\x0a    };\x0a    var TYPE_ERROR = \x27Promise resolved with itself\x27;\x0a    var CURRENT_TASK_TRACE_SYMBOL = __symbol__(\x27currentTaskTrace\x27);\x0a    // Promise Resolution\x0a    function resolvePromise(promise, state, value) {\x0a        var onceWrapper = once();\x0a        if (promise === value) {\x0a            throw new TypeError(TYPE_ERROR);\x0a        }\x0a        if (promise[symbolState] === UNRESOLVED) {\x0a            // should only get value.then once based on promise spec.\x0a            var then = null;\x0a            try {\x0a                if (typeof value === \x27object\x27 || typeof value === \x27function\x27) {\x0a                    then = value && value.then;\x0a                }\x0a            }\x0a            catch (err) {\x0a                onceWrapper(function () {\x0a                    resolvePromise(promise, false, err);\x0a                })();\x0a                return promise;\x0a            }\x0a            // if (value instanceof ZoneAwarePromise) {\x0a            if (state !== REJECTED && value instanceof ZoneAwarePromise &&\x0a                value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) &&\x0a                value[symbolState] !== UNRESOLVED) {\x0a                clearRejectedNoCatch(value);\x0a                resolvePromise(promise, value[symbolState], value[symbolValue]);\x0a            }\x0a            else if (state !== REJECTED && typeof then === \x27function\x27) {\x0a                try {\x0a                    then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));\x0a                }\x0a                catch (err) {\x0a                    onceWrapper(function () {\x0a                        resolvePromise(promise, false, err);\x0a                    })();\x0a                }\x0a            }\x0a            else {\x0a                promise[symbolState] = state;\x0a                var queue = promise[symbolValue];\x0a                promise[symbolValue] = value;\x0a                if (promise[symbolFinally] === symbolFinally) {\x0a                    // the promise is generated by Promise.prototype.finally          \x0a                    if (state === RESOLVED) {\x0a                        // the state is resolved, should ignore the value\x0a                        // and use parent promise value\x0a                        promise[symbolState] = promise[symbolParentPromiseState];\x0a                        promise[symbolValue] = promise[symbolParentPromiseValue];\x0a                    }\x0a                }\x0a                // record task information in value when error occurs, so we can\x0a                // do some additional work such as render longStackTrace\x0a                if (state === REJECTED && value instanceof Error) {\x0a                    // check if longStackTraceZone is here\x0a                    var trace = Zone.currentTask && Zone.currentTask.data &&\x0a                        Zone.currentTask.data[creationTrace];\x0a                    if (trace) {\x0a                        // only keep the long stack trace into error when in longStackTraceZone\x0a                        ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, { configurable: true, enumerable: false, writable: true, value: trace });\x0a                    }\x0a                }\x0a                for (var i = 0; i \x3c queue.length;) {\x0a                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\x0a                }\x0a                if (queue.length == 0 && state == REJECTED) {\x0a                    promise[symbolState] = REJECTED_NO_CATCH;\x0a                    try {\x0a                        // try to print more readable error log\x0a                        throw new Error(\x27Uncaught (in promise): \x27 + readableObjectToString(value) +\x0a                            (value && value.stack ? \x27\x5cn\x27 + value.stack : \x27\x27));\x0a                    }\x0a                    catch (err) {\x0a                        var error_1 = err;\x0a                        error_1.rejection = value;\x0a                        error_1.promise = promise;\x0a                        error_1.zone = Zone.current;\x0a                        error_1.task = Zone.currentTask;\x0a                        _uncaughtPromiseErrors.push(error_1);\x0a                        api.scheduleMicroTask(); // to make sure that it is running\x0a                    }\x0a                }\x0a            }\x0a        }\x0a        // Resolving an already resolved promise is a noop.\x0a        return promise;\x0a    }\x0a    var REJECTION_HANDLED_HANDLER = __symbol__(\x27rejectionHandledHandler\x27);\x0a    function clearRejectedNoCatch(promise) {\x0a        if (promise[symbolState] === REJECTED_NO_CATCH) {\x0a            // if the promise is rejected no catch status\x0a            // and queue.length \x3e 0, means there is a error handler\x0a            // here to handle the rejected promise, we should trigger\x0a            // windows.rejectionhandled eventHandler or nodejs rejectionHandled\x0a            // eventHandler\x0a            try {\x0a                var handler = Zone[REJECTION_HANDLED_HANDLER];\x0a                if (handler && typeof handler === \x27function\x27) {\x0a                    handler.call(this, { rejection: promise[symbolValue], promise: promise });\x0a                }\x0a            }\x0a            catch (err) {\x0a            }\x0a            promise[symbolState] = REJECTED;\x0a            for (var i = 0; i \x3c _uncaughtPromiseErrors.length; i++) {\x0a                if (promise === _uncaughtPromiseErrors[i].promise) {\x0a                    _uncaughtPromiseErrors.splice(i, 1);\x0a                }\x0a            }\x0a        }\x0a    }\x0a    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\x0a        clearRejectedNoCatch(promise);\x0a        var promiseState = promise[symbolState];\x0a        var delegate = promiseState ?\x0a            (typeof onFulfilled === \x27function\x27) ? onFulfilled : forwardResolution :\x0a            (typeof onRejected === \x27function\x27) ? onRejected : forwardRejection;\x0a        zone.scheduleMicroTask(source, function () {\x0a            try {\x0a                var parentPromiseValue = promise[symbolValue];\x0a                var isFinallyPromise = chainPromise && symbolFinally === chainPromise[symbolFinally];\x0a                if (isFinallyPromise) {\x0a                    // if the promise is generated from finally call, keep parent promise\x27s state and value\x0a                    chainPromise[symbolParentPromiseValue] = parentPromiseValue;\x0a                    chainPromise[symbolParentPromiseState] = promiseState;\x0a                }\x0a                // should not pass value to finally callback\x0a                var value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);\x0a                resolvePromise(chainPromise, true, value);\x0a            }\x0a            catch (error) {\x0a                // if error occurs, should always return this error\x0a                resolvePromise(chainPromise, false, error);\x0a            }\x0a        }, chainPromise);\x0a    }\x0a    var ZONE_AWARE_PROMISE_TO_STRING = \x27function ZoneAwarePromise() { [native code] }\x27;\x0a    var ZoneAwarePromise = /** @class */ (function () {\x0a        function ZoneAwarePromise(executor) {\x0a            var promise = this;\x0a            if (!(promise instanceof ZoneAwarePromise)) {\x0a                throw new Error(\x27Must be an instanceof Promise.\x27);\x0a            }\x0a            promise[symbolState] = UNRESOLVED;\x0a            promise[symbolValue] = []; // queue;\x0a            try {\x0a                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\x0a            }\x0a            catch (error) {\x0a                resolvePromise(promise, false, error);\x0a            }\x0a        }\x0a        ZoneAwarePromise.toString = function () {\x0a            return ZONE_AWARE_PROMISE_TO_STRING;\x0a        };\x0a        ZoneAwarePromise.resolve = function (value) {\x0a            return resolvePromise(new this(null), RESOLVED, value);\x0a        };\x0a        ZoneAwarePromise.reject = function (error) {\x0a            return resolvePromise(new this(null), REJECTED, error);\x0a        };\x0a        ZoneAwarePromise.race = function (values) {\x0a            var resolve;\x0a            var reject;\x0a            var promise = new this(function (res, rej) {\x0a                resolve = res;\x0a                reject = rej;\x0a            });\x0a            function onResolve(value) {\x0a                promise && (promise = null || resolve(value));\x0a            }\x0a            function onReject(error) {\x0a                promise && (promise = null || reject(error));\x0a            }\x0a            for (var _i = 0, values_1 = values; _i \x3c values_1.length; _i++) {\x0a                var value = values_1[_i];\x0a                if (!isThenable(value)) {\x0a                    value = this.resolve(value);\x0a                }\x0a                value.then(onResolve, onReject);\x0a            }\x0a            return promise;\x0a        };\x0a        ZoneAwarePromise.all = function (values) {\x0a            var resolve;\x0a            var reject;\x0a            var promise = new this(function (res, rej) {\x0a                resolve = res;\x0a                reject = rej;\x0a            });\x0a            var count = 0;\x0a            var resolvedValues = [];\x0a            for (var _i = 0, values_2 = values; _i \x3c values_2.length; _i++) {\x0a                var value = values_2[_i];\x0a                if (!isThenable(value)) {\x0a                    value = this.resolve(value);\x0a                }\x0a                value.then((function (index) { return function (value) {\x0a                    resolvedValues[index] = value;\x0a                    count--;\x0a                    if (!count) {\x0a                        resolve(resolvedValues);\x0a                    }\x0a                }; })(count), reject);\x0a                count++;\x0a            }\x0a            if (!count)\x0a                resolve(resolvedValues);\x0a            return promise;\x0a        };\x0a        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {\x0a            var chainPromise = new this.constructor(null);\x0a            var zone = Zone.current;\x0a            if (this[symbolState] == UNRESOLVED) {\x0a                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\x0a            }\x0a            else {\x0a                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\x0a            }\x0a            return chainPromise;\x0a        };\x0a        ZoneAwarePromise.prototype.catch = function (onRejected) {\x0a            return this.then(null, onRejected);\x0a        };\x0a        ZoneAwarePromise.prototype.finally = function (onFinally) {\x0a            var chainPromise = new this.constructor(null);\x0a            chainPromise[symbolFinally] = symbolFinally;\x0a            var zone = Zone.current;\x0a            if (this[symbolState] == UNRESOLVED) {\x0a                this[symbolValue].push(zone, chainPromise, onFinally, onFinally);\x0a            }\x0a            else {\x0a                scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);\x0a            }\x0a            return chainPromise;\x0a        };\x0a        return ZoneAwarePromise;\x0a    }());\x0a    // Protect against aggressive optimizers dropping seemingly unused properties.\x0a    // E.g. Closure Compiler in advanced mode.\x0a    ZoneAwarePromise[\x27resolve\x27] = ZoneAwarePromise.resolve;\x0a    ZoneAwarePromise[\x27reject\x27] = ZoneAwarePromise.reject;\x0a    ZoneAwarePromise[\x27race\x27] = ZoneAwarePromise.race;\x0a    ZoneAwarePromise[\x27all\x27] = ZoneAwarePromise.all;\x0a    var NativePromise = global[symbolPromise] = global[\x27Promise\x27];\x0a    var ZONE_AWARE_PROMISE = Zone.__symbol__(\x27ZoneAwarePromise\x27);\x0a    var desc = ObjectGetOwnPropertyDescriptor(global, \x27Promise\x27);\x0a    if (!desc || desc.configurable) {\x0a        desc && delete desc.writable;\x0a        desc && delete desc.value;\x0a        if (!desc) {\x0a            desc = { configurable: true, enumerable: true };\x0a        }\x0a        desc.get = function () {\x0a            // if we already set ZoneAwarePromise, use patched one\x0a            // otherwise return native one.\x0a            return global[ZONE_AWARE_PROMISE] ? global[ZONE_AWARE_PROMISE] : global[symbolPromise];\x0a        };\x0a        desc.set = function (NewNativePromise) {\x0a            if (NewNativePromise === ZoneAwarePromise) {\x0a                // if the NewNativePromise is ZoneAwarePromise\x0a                // save to global\x0a                global[ZONE_AWARE_PROMISE] = NewNativePromise;\x0a            }\x0a            else {\x0a                // if the NewNativePromise is not ZoneAwarePromise\x0a                // for example: after load zone.js, some library just\x0a                // set es6-promise to global, if we set it to global\x0a                // directly, assertZonePatched will fail and angular\x0a                // will not loaded, so we just set the NewNativePromise\x0a                // to global[symbolPromise], so the result is just like\x0a                // we load ES6 Promise before zone.js\x0a                global[symbolPromise] = NewNativePromise;\x0a                if (!NewNativePromise.prototype[symbolThen]) {\x0a                    patchThen(NewNativePromise);\x0a                }\x0a                api.setNativePromise(NewNativePromise);\x0a            }\x0a        };\x0a        ObjectDefineProperty(global, \x27Promise\x27, desc);\x0a    }\x0a    global[\x27Promise\x27] = ZoneAwarePromise;\x0a    var symbolThenPatched = __symbol__(\x27thenPatched\x27);\x0a    function patchThen(Ctor) {\x0a        var proto = Ctor.prototype;\x0a        var prop = ObjectGetOwnPropertyDescriptor(proto, \x27then\x27);\x0a        if (prop && (prop.writable === false || !prop.configurable)) {\x0a            // check Ctor.prototype.then propertyDescriptor is writable or not\x0a            // in meteor env, writable is false, we should ignore such case\x0a            return;\x0a        }\x0a        var originalThen = proto.then;\x0a        // Keep a reference to the original method.\x0a        proto[symbolThen] = originalThen;\x0a        Ctor.prototype.then = function (onResolve, onReject) {\x0a            var _this = this;\x0a            var wrapped = new ZoneAwarePromise(function (resolve, reject) {\x0a                originalThen.call(_this, resolve, reject);\x0a            });\x0a            return wrapped.then(onResolve, onReject);\x0a        };\x0a        Ctor[symbolThenPatched] = true;\x0a    }\x0a    function zoneify(fn) {\x0a        return function () {\x0a            var resultPromise = fn.apply(this, arguments);\x0a            if (resultPromise instanceof ZoneAwarePromise) {\x0a                return resultPromise;\x0a            }\x0a            var ctor = resultPromise.constructor;\x0a            if (!ctor[symbolThenPatched]) {\x0a                patchThen(ctor);\x0a            }\x0a            return resultPromise;\x0a        };\x0a    }\x0a    if (NativePromise) {\x0a        patchThen(NativePromise);\x0a        var fetch_1 = global[\x27fetch\x27];\x0a        if (typeof fetch_1 == \x27function\x27) {\x0a            global[\x27fetch\x27] = zoneify(fetch_1);\x0a        }\x0a    }\x0a    // This is not part of public API, but it is useful for tests, so we expose it.\x0a    Promise[Zone.__symbol__(\x27uncaughtPromiseErrors\x27)] = _uncaughtPromiseErrors;\x0a    return ZoneAwarePromise;\x0a});\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/**\x0a * Suppress closure compiler errors about unknown \x27Zone\x27 variable\x0a * @fileoverview\x0a * @suppress {undefinedVars,globalThis,missingRequire}\x0a */\x0a// issue #989, to reduce bundle size, use short name\x0a/** Object.getOwnPropertyDescriptor */\x0avar ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\x0a/** Object.defineProperty */\x0avar ObjectDefineProperty = Object.defineProperty;\x0a/** Object.getPrototypeOf */\x0avar ObjectGetPrototypeOf = Object.getPrototypeOf;\x0a/** Object.create */\x0avar ObjectCreate = Object.create;\x0a/** Array.prototype.slice */\x0avar ArraySlice = Array.prototype.slice;\x0a/** addEventListener string const */\x0avar ADD_EVENT_LISTENER_STR = \x27addEventListener\x27;\x0a/** removeEventListener string const */\x0avar REMOVE_EVENT_LISTENER_STR = \x27removeEventListener\x27;\x0a/** zoneSymbol addEventListener */\x0avar ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);\x0a/** zoneSymbol removeEventListener */\x0avar ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);\x0a/** true string const */\x0avar TRUE_STR = \x27true\x27;\x0a/** false string const */\x0avar FALSE_STR = \x27false\x27;\x0a/** __zone_symbol__ string const */\x0avar ZONE_SYMBOL_PREFIX = \x27__zone_symbol__\x27;\x0afunction wrapWithCurrentZone(callback, source) {\x0a    return Zone.current.wrap(callback, source);\x0a}\x0afunction scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {\x0a    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);\x0a}\x0avar zoneSymbol = Zone.__symbol__;\x0avar isWindowExists = typeof window !== \x27undefined\x27;\x0avar internalWindow = isWindowExists ? window : undefined;\x0avar _global = isWindowExists && internalWindow || typeof self === \x27object\x27 && self || global;\x0avar REMOVE_ATTRIBUTE = \x27removeAttribute\x27;\x0avar NULL_ON_PROP_VALUE = [null];\x0afunction bindArguments(args, source) {\x0a    for (var i = args.length - 1; i \x3e= 0; i--) {\x0a        if (typeof args[i] === \x27function\x27) {\x0a            args[i] = wrapWithCurrentZone(args[i], source + \x27_\x27 + i);\x0a        }\x0a    }\x0a    return args;\x0a}\x0afunction patchPrototype(prototype, fnNames) {\x0a    var source = prototype.constructor[\x27name\x27];\x0a    var _loop_1 = function (i) {\x0a        var name_1 = fnNames[i];\x0a        var delegate = prototype[name_1];\x0a        if (delegate) {\x0a            var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name_1);\x0a            if (!isPropertyWritable(prototypeDesc)) {\x0a                return \x22continue\x22;\x0a            }\x0a            prototype[name_1] = (function (delegate) {\x0a                var patched = function () {\x0a                    return delegate.apply(this, bindArguments(arguments, source + \x27.\x27 + name_1));\x0a                };\x0a                attachOriginToPatched(patched, delegate);\x0a                return patched;\x0a            })(delegate);\x0a        }\x0a    };\x0a    for (var i = 0; i \x3c fnNames.length; i++) {\x0a        _loop_1(i);\x0a    }\x0a}\x0afunction isPropertyWritable(propertyDesc) {\x0a    if (!propertyDesc) {\x0a        return true;\x0a    }\x0a    if (propertyDesc.writable === false) {\x0a        return false;\x0a    }\x0a    return !(typeof propertyDesc.get === \x27function\x27 && typeof propertyDesc.set === \x27undefined\x27);\x0a}\x0avar isWebWorker = (typeof WorkerGlobalScope !== \x27undefined\x27 && self instanceof WorkerGlobalScope);\x0a// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\x0a// this code.\x0avar isNode = (!(\x27nw\x27 in _global) && typeof _global.process !== \x27undefined\x27 &&\x0a    {}.toString.call(_global.process) === \x27[object process]\x27);\x0avar isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow[\x27HTMLElement\x27]);\x0a// we are in electron of nw, so we are both browser and nodejs\x0a// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\x0a// this code.\x0avar isMix = typeof _global.process !== \x27undefined\x27 &&\x0a    {}.toString.call(_global.process) === \x27[object process]\x27 && !isWebWorker &&\x0a    !!(isWindowExists && internalWindow[\x27HTMLElement\x27]);\x0avar zoneSymbolEventNames = {};\x0avar wrapFn = function (event) {\x0a    // https://github.com/angular/zone.js/issues/911, in IE, sometimes\x0a    // event will be undefined, so we need to use window.event\x0a    event = event || _global.event;\x0a    if (!event) {\x0a        return;\x0a    }\x0a    var eventNameSymbol = zoneSymbolEventNames[event.type];\x0a    if (!eventNameSymbol) {\x0a        eventNameSymbol = zoneSymbolEventNames[event.type] = zoneSymbol(\x27ON_PROPERTY\x27 + event.type);\x0a    }\x0a    var target = this || event.target || _global;\x0a    var listener = target[eventNameSymbol];\x0a    var result = listener && listener.apply(this, arguments);\x0a    if (result != undefined && !result) {\x0a        event.preventDefault();\x0a    }\x0a    return result;\x0a};\x0afunction patchProperty(obj, prop, prototype) {\x0a    var desc = ObjectGetOwnPropertyDescriptor(obj, prop);\x0a    if (!desc && prototype) {\x0a        // when patch window object, use prototype to check prop exist or not\x0a        var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);\x0a        if (prototypeDesc) {\x0a            desc = { enumerable: true, configurable: true };\x0a        }\x0a    }\x0a    // if the descriptor not exists or is not configurable\x0a    // just return\x0a    if (!desc || !desc.configurable) {\x0a        return;\x0a    }\x0a    // A property descriptor cannot have getter/setter and be writable\x0a    // deleting the writable and value properties avoids this error:\x0a    //\x0a    // TypeError: property descriptors must not specify a value or be writable when a\x0a    // getter or setter has been specified\x0a    delete desc.writable;\x0a    delete desc.value;\x0a    var originalDescGet = desc.get;\x0a    var originalDescSet = desc.set;\x0a    // substr(2) cuz \x27onclick\x27 -\x3e \x27click\x27, etc\x0a    var eventName = prop.substr(2);\x0a    var eventNameSymbol = zoneSymbolEventNames[eventName];\x0a    if (!eventNameSymbol) {\x0a        eventNameSymbol = zoneSymbolEventNames[eventName] = zoneSymbol(\x27ON_PROPERTY\x27 + eventName);\x0a    }\x0a    desc.set = function (newValue) {\x0a        // in some of windows\x27s onproperty callback, this is undefined\x0a        // so we need to check it\x0a        var target = this;\x0a        if (!target && obj === _global) {\x0a            target = _global;\x0a        }\x0a        if (!target) {\x0a            return;\x0a        }\x0a        var previousValue = target[eventNameSymbol];\x0a        if (previousValue) {\x0a            target.removeEventListener(eventName, wrapFn);\x0a        }\x0a        // issue #978, when onload handler was added before loading zone.js\x0a        // we should remove it with originalDescSet\x0a        if (originalDescSet) {\x0a            originalDescSet.apply(target, NULL_ON_PROP_VALUE);\x0a        }\x0a        if (typeof newValue === \x27function\x27) {\x0a            target[eventNameSymbol] = newValue;\x0a            target.addEventListener(eventName, wrapFn, false);\x0a        }\x0a        else {\x0a            target[eventNameSymbol] = null;\x0a        }\x0a    };\x0a    // The getter would return undefined for unassigned properties but the default value of an\x0a    // unassigned property is null\x0a    desc.get = function () {\x0a        // in some of windows\x27s onproperty callback, this is undefined\x0a        // so we need to check it\x0a        var target = this;\x0a        if (!target && obj === _global) {\x0a            target = _global;\x0a        }\x0a        if (!target) {\x0a            return null;\x0a        }\x0a        var listener = target[eventNameSymbol];\x0a        if (listener) {\x0a            return listener;\x0a        }\x0a        else if (originalDescGet) {\x0a            // result will be null when use inline event attribute,\x0a            // such as \x3cbutton onclick=\x22func();\x22\x3eOK\x3c/button\x3e\x0a            // because the onclick function is internal raw uncompiled handler\x0a            // the onclick will be evaluated when first time event was triggered or\x0a            // the property is accessed, https://github.com/angular/zone.js/issues/525\x0a            // so we should use original native get to retrieve the handler\x0a            var value = originalDescGet && originalDescGet.call(this);\x0a            if (value) {\x0a                desc.set.call(this, value);\x0a                if (typeof target[REMOVE_ATTRIBUTE] === \x27function\x27) {\x0a                    target.removeAttribute(prop);\x0a                }\x0a                return value;\x0a            }\x0a        }\x0a        return null;\x0a    };\x0a    ObjectDefineProperty(obj, prop, desc);\x0a}\x0afunction patchOnProperties(obj, properties, prototype) {\x0a    if (properties) {\x0a        for (var i = 0; i \x3c properties.length; i++) {\x0a            patchProperty(obj, \x27on\x27 + properties[i], prototype);\x0a        }\x0a    }\x0a    else {\x0a        var onProperties = [];\x0a        for (var prop in obj) {\x0a            if (prop.substr(0, 2) == \x27on\x27) {\x0a                onProperties.push(prop);\x0a            }\x0a        }\x0a        for (var j = 0; j \x3c onProperties.length; j++) {\x0a            patchProperty(obj, onProperties[j], prototype);\x0a        }\x0a    }\x0a}\x0avar originalInstanceKey = zoneSymbol(\x27originalInstance\x27);\x0a// wrap some native API on `window`\x0afunction patchClass(className) {\x0a    var OriginalClass = _global[className];\x0a    if (!OriginalClass)\x0a        return;\x0a    // keep original class in global\x0a    _global[zoneSymbol(className)] = OriginalClass;\x0a    _global[className] = function () {\x0a        var a = bindArguments(arguments, className);\x0a        switch (a.length) {\x0a            case 0:\x0a                this[originalInstanceKey] = new OriginalClass();\x0a                break;\x0a            case 1:\x0a                this[originalInstanceKey] = new OriginalClass(a[0]);\x0a                break;\x0a            case 2:\x0a                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\x0a                break;\x0a            case 3:\x0a                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\x0a                break;\x0a            case 4:\x0a                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\x0a                break;\x0a            default:\x0a                throw new Error(\x27Arg list too long.\x27);\x0a        }\x0a    };\x0a    // attach original delegate to patched function\x0a    attachOriginToPatched(_global[className], OriginalClass);\x0a    var instance = new OriginalClass(function () { });\x0a    var prop;\x0a    for (prop in instance) {\x0a        // https://bugs.webkit.org/show_bug.cgi?id=44721\x0a        if (className === \x27XMLHttpRequest\x27 && prop === \x27responseBlob\x27)\x0a            continue;\x0a        (function (prop) {\x0a            if (typeof instance[prop] === \x27function\x27) {\x0a                _global[className].prototype[prop] = function () {\x0a                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\x0a                };\x0a            }\x0a            else {\x0a                ObjectDefineProperty(_global[className].prototype, prop, {\x0a                    set: function (fn) {\x0a                        if (typeof fn === \x27function\x27) {\x0a                            this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + \x27.\x27 + prop);\x0a                            // keep callback in wrapped function so we can\x0a                            // use it in Function.prototype.toString to return\x0a                            // the native one.\x0a                            attachOriginToPatched(this[originalInstanceKey][prop], fn);\x0a                        }\x0a                        else {\x0a                            this[originalInstanceKey][prop] = fn;\x0a                        }\x0a                    },\x0a                    get: function () {\x0a                        return this[originalInstanceKey][prop];\x0a                    }\x0a                });\x0a            }\x0a        }(prop));\x0a    }\x0a    for (prop in OriginalClass) {\x0a        if (prop !== \x27prototype\x27 && OriginalClass.hasOwnProperty(prop)) {\x0a            _global[className][prop] = OriginalClass[prop];\x0a        }\x0a    }\x0a}\x0afunction patchMethod(target, name, patchFn) {\x0a    var proto = target;\x0a    while (proto && !proto.hasOwnProperty(name)) {\x0a        proto = ObjectGetPrototypeOf(proto);\x0a    }\x0a    if (!proto && target[name]) {\x0a        // somehow we did not find it, but we can see it. This happens on IE for Window properties.\x0a        proto = target;\x0a    }\x0a    var delegateName = zoneSymbol(name);\x0a    var delegate;\x0a    if (proto && !(delegate = proto[delegateName])) {\x0a        delegate = proto[delegateName] = proto[name];\x0a        // check whether proto[name] is writable\x0a        // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob\x0a        var desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);\x0a        if (isPropertyWritable(desc)) {\x0a            var patchDelegate_1 = patchFn(delegate, delegateName, name);\x0a            proto[name] = function () {\x0a                return patchDelegate_1(this, arguments);\x0a            };\x0a            attachOriginToPatched(proto[name], delegate);\x0a        }\x0a    }\x0a    return delegate;\x0a}\x0a// TODO: @JiaLiPassion, support cancel task later if necessary\x0afunction patchMacroTask(obj, funcName, metaCreator) {\x0a    var setNative = null;\x0a    function scheduleTask(task) {\x0a        var data = task.data;\x0a        data.args[data.cbIdx] = function () {\x0a            task.invoke.apply(this, arguments);\x0a        };\x0a        setNative.apply(data.target, data.args);\x0a        return task;\x0a    }\x0a    setNative = patchMethod(obj, funcName, function (delegate) { return function (self, args) {\x0a        var meta = metaCreator(self, args);\x0a        if (meta.cbIdx \x3e= 0 && typeof args[meta.cbIdx] === \x27function\x27) {\x0a            return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask, null);\x0a        }\x0a        else {\x0a            // cause an error by calling it directly.\x0a            return delegate.apply(self, args);\x0a        }\x0a    }; });\x0a}\x0a\x0afunction attachOriginToPatched(patched, original) {\x0a    patched[zoneSymbol(\x27OriginalDelegate\x27)] = original;\x0a}\x0avar isDetectedIEOrEdge = false;\x0avar ieOrEdge = false;\x0afunction isIEOrEdge() {\x0a    if (isDetectedIEOrEdge) {\x0a        return ieOrEdge;\x0a    }\x0a    isDetectedIEOrEdge = true;\x0a    try {\x0a        var ua = internalWindow.navigator.userAgent;\x0a        if (ua.indexOf(\x27MSIE \x27) !== -1 || ua.indexOf(\x27Trident/\x27) !== -1 || ua.indexOf(\x27Edge/\x27) !== -1) {\x0a            ieOrEdge = true;\x0a        }\x0a        return ieOrEdge;\x0a    }\x0a    catch (error) {\x0a    }\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a// override Function.prototype.toString to make zone.js patched function\x0a// look like native function\x0aZone.__load_patch(\x27toString\x27, function (global) {\x0a    // patch Func.prototype.toString to let them look like native\x0a    var originalFunctionToString = Function.prototype.toString;\x0a    var ORIGINAL_DELEGATE_SYMBOL = zoneSymbol(\x27OriginalDelegate\x27);\x0a    var PROMISE_SYMBOL = zoneSymbol(\x27Promise\x27);\x0a    var ERROR_SYMBOL = zoneSymbol(\x27Error\x27);\x0a    var newFunctionToString = function toString() {\x0a        if (typeof this === \x27function\x27) {\x0a            var originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];\x0a            if (originalDelegate) {\x0a                if (typeof originalDelegate === \x27function\x27) {\x0a                    return originalFunctionToString.apply(this[ORIGINAL_DELEGATE_SYMBOL], arguments);\x0a                }\x0a                else {\x0a                    return Object.prototype.toString.call(originalDelegate);\x0a                }\x0a            }\x0a            if (this === Promise) {\x0a                var nativePromise = global[PROMISE_SYMBOL];\x0a                if (nativePromise) {\x0a                    return originalFunctionToString.apply(nativePromise, arguments);\x0a                }\x0a            }\x0a            if (this === Error) {\x0a                var nativeError = global[ERROR_SYMBOL];\x0a                if (nativeError) {\x0a                    return originalFunctionToString.apply(nativeError, arguments);\x0a                }\x0a            }\x0a        }\x0a        return originalFunctionToString.apply(this, arguments);\x0a    };\x0a    newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;\x0a    Function.prototype.toString = newFunctionToString;\x0a    // patch Object.prototype.toString to let them look like native\x0a    var originalObjectToString = Object.prototype.toString;\x0a    var PROMISE_OBJECT_TO_STRING = \x27[object Promise]\x27;\x0a    Object.prototype.toString = function () {\x0a        if (this instanceof Promise) {\x0a            return PROMISE_OBJECT_TO_STRING;\x0a        }\x0a        return originalObjectToString.apply(this, arguments);\x0a    };\x0a});\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/**\x0a * @fileoverview\x0a * @suppress {missingRequire}\x0a */\x0a// an identifier to tell ZoneTask do not create a new invoke closure\x0avar OPTIMIZED_ZONE_EVENT_TASK_DATA = {\x0a    useG: true\x0a};\x0avar zoneSymbolEventNames$1 = {};\x0avar globalSources = {};\x0avar EVENT_NAME_SYMBOL_REGX = /^__zone_symbol__(\x5cw+)(true|false)$/;\x0avar IMMEDIATE_PROPAGATION_SYMBOL = (\x27__zone_symbol__propagationStopped\x27);\x0afunction patchEventTarget(_global, apis, patchOptions) {\x0a    var ADD_EVENT_LISTENER = (patchOptions && patchOptions.add) || ADD_EVENT_LISTENER_STR;\x0a    var REMOVE_EVENT_LISTENER = (patchOptions && patchOptions.rm) || REMOVE_EVENT_LISTENER_STR;\x0a    var LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.listeners) || \x27eventListeners\x27;\x0a    var REMOVE_ALL_LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.rmAll) || \x27removeAllListeners\x27;\x0a    var zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);\x0a    var ADD_EVENT_LISTENER_SOURCE = \x27.\x27 + ADD_EVENT_LISTENER + \x27:\x27;\x0a    var PREPEND_EVENT_LISTENER = \x27prependListener\x27;\x0a    var PREPEND_EVENT_LISTENER_SOURCE = \x27.\x27 + PREPEND_EVENT_LISTENER + \x27:\x27;\x0a    var invokeTask = function (task, target, event) {\x0a        // for better performance, check isRemoved which is set\x0a        // by removeEventListener\x0a        if (task.isRemoved) {\x0a            return;\x0a        }\x0a        var delegate = task.callback;\x0a        if (typeof delegate === \x27object\x27 && delegate.handleEvent) {\x0a            // create the bind version of handleEvent when invoke\x0a            task.callback = function (event) { return delegate.handleEvent(event); };\x0a            task.originalDelegate = delegate;\x0a        }\x0a        // invoke static task.invoke\x0a        task.invoke(task, target, [event]);\x0a        var options = task.options;\x0a        if (options && typeof options === \x27object\x27 && options.once) {\x0a            // if options.once is true, after invoke once remove listener here\x0a            // only browser need to do this, nodejs eventEmitter will cal removeListener\x0a            // inside EventEmitter.once\x0a            var delegate_1 = task.originalDelegate ? task.originalDelegate : task.callback;\x0a            target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate_1, options);\x0a        }\x0a    };\x0a    // global shared zoneAwareCallback to handle all event callback with capture = false\x0a    var globalZoneAwareCallback = function (event) {\x0a        // https://github.com/angular/zone.js/issues/911, in IE, sometimes\x0a        // event will be undefined, so we need to use window.event\x0a        event = event || _global.event;\x0a        if (!event) {\x0a            return;\x0a        }\x0a        // event.target is needed for Samsung TV and SourceBuffer\x0a        // || global is needed https://github.com/angular/zone.js/issues/190\x0a        var target = this || event.target || _global;\x0a        var tasks = target[zoneSymbolEventNames$1[event.type][FALSE_STR]];\x0a        if (tasks) {\x0a            // invoke all tasks which attached to current target with given event.type and capture = false\x0a            // for performance concern, if task.length === 1, just invoke\x0a            if (tasks.length === 1) {\x0a                invokeTask(tasks[0], target, event);\x0a            }\x0a            else {\x0a                // https://github.com/angular/zone.js/issues/836\x0a                // copy the tasks array before invoke, to avoid\x0a                // the callback will remove itself or other listener\x0a                var copyTasks = tasks.slice();\x0a                for (var i = 0; i \x3c copyTasks.length; i++) {\x0a                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\x0a                        break;\x0a                    }\x0a                    invokeTask(copyTasks[i], target, event);\x0a                }\x0a            }\x0a        }\x0a    };\x0a    // global shared zoneAwareCallback to handle all event callback with capture = true\x0a    var globalZoneAwareCaptureCallback = function (event) {\x0a        // https://github.com/angular/zone.js/issues/911, in IE, sometimes\x0a        // event will be undefined, so we need to use window.event\x0a        event = event || _global.event;\x0a        if (!event) {\x0a            return;\x0a        }\x0a        // event.target is needed for Samsung TV and SourceBuffer\x0a        // || global is needed https://github.com/angular/zone.js/issues/190\x0a        var target = this || event.target || _global;\x0a        var tasks = target[zoneSymbolEventNames$1[event.type][TRUE_STR]];\x0a        if (tasks) {\x0a            // invoke all tasks which attached to current target with given event.type and capture = false\x0a            // for performance concern, if task.length === 1, just invoke\x0a            if (tasks.length === 1) {\x0a                invokeTask(tasks[0], target, event);\x0a            }\x0a            else {\x0a                // https://github.com/angular/zone.js/issues/836\x0a                // copy the tasks array before invoke, to avoid\x0a                // the callback will remove itself or other listener\x0a                var copyTasks = tasks.slice();\x0a                for (var i = 0; i \x3c copyTasks.length; i++) {\x0a                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\x0a                        break;\x0a                    }\x0a                    invokeTask(copyTasks[i], target, event);\x0a                }\x0a            }\x0a        }\x0a    };\x0a    function patchEventTargetMethods(obj, patchOptions) {\x0a        if (!obj) {\x0a            return false;\x0a        }\x0a        var useGlobalCallback = true;\x0a        if (patchOptions && patchOptions.useG !== undefined) {\x0a            useGlobalCallback = patchOptions.useG;\x0a        }\x0a        var validateHandler = patchOptions && patchOptions.vh;\x0a        var checkDuplicate = true;\x0a        if (patchOptions && patchOptions.chkDup !== undefined) {\x0a            checkDuplicate = patchOptions.chkDup;\x0a        }\x0a        var returnTarget = false;\x0a        if (patchOptions && patchOptions.rt !== undefined) {\x0a            returnTarget = patchOptions.rt;\x0a        }\x0a        var proto = obj;\x0a        while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {\x0a            proto = ObjectGetPrototypeOf(proto);\x0a        }\x0a        if (!proto && obj[ADD_EVENT_LISTENER]) {\x0a            // somehow we did not find it, but we can see it. This happens on IE for Window properties.\x0a            proto = obj;\x0a        }\x0a        if (!proto) {\x0a            return false;\x0a        }\x0a        if (proto[zoneSymbolAddEventListener]) {\x0a            return false;\x0a        }\x0a        // a shared global taskData to pass data for scheduleEventTask\x0a        // so we do not need to create a new object just for pass some data\x0a        var taskData = {};\x0a        var nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];\x0a        var nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] =\x0a            proto[REMOVE_EVENT_LISTENER];\x0a        var nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] =\x0a            proto[LISTENERS_EVENT_LISTENER];\x0a        var nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] =\x0a            proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];\x0a        var nativePrependEventListener;\x0a        if (patchOptions && patchOptions.prepend) {\x0a            nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] =\x0a                proto[patchOptions.prepend];\x0a        }\x0a        var customScheduleGlobal = function () {\x0a            // if there is already a task for the eventName + capture,\x0a            // just return, because we use the shared globalZoneAwareCallback here.\x0a            if (taskData.isExisting) {\x0a                return;\x0a            }\x0a            return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);\x0a        };\x0a        var customCancelGlobal = function (task) {\x0a            // if task is not marked as isRemoved, this call is directly\x0a            // from Zone.prototype.cancelTask, we should remove the task\x0a            // from tasksList of target first\x0a            if (!task.isRemoved) {\x0a                var symbolEventNames = zoneSymbolEventNames$1[task.eventName];\x0a                var symbolEventName = void 0;\x0a                if (symbolEventNames) {\x0a                    symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];\x0a                }\x0a                var existingTasks = symbolEventName && task.target[symbolEventName];\x0a                if (existingTasks) {\x0a                    for (var i = 0; i \x3c existingTasks.length; i++) {\x0a                        var existingTask = existingTasks[i];\x0a                        if (existingTask === task) {\x0a                            existingTasks.splice(i, 1);\x0a                            // set isRemoved to data for faster invokeTask check\x0a                            task.isRemoved = true;\x0a                            if (existingTasks.length === 0) {\x0a                                // all tasks for the eventName + capture have gone,\x0a                                // remove globalZoneAwareCallback and remove the task cache from target\x0a                                task.allRemoved = true;\x0a                                task.target[symbolEventName] = null;\x0a                            }\x0a                            break;\x0a                        }\x0a                    }\x0a                }\x0a            }\x0a            // if all tasks for the eventName + capture have gone,\x0a            // we will really remove the global event callback,\x0a            // if not, return\x0a            if (!task.allRemoved) {\x0a                return;\x0a            }\x0a            return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);\x0a        };\x0a        var customScheduleNonGlobal = function (task) {\x0a            return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\x0a        };\x0a        var customSchedulePrepend = function (task) {\x0a            return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\x0a        };\x0a        var customCancelNonGlobal = function (task) {\x0a            return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);\x0a        };\x0a        var customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;\x0a        var customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;\x0a        var compareTaskCallbackVsDelegate = function (task, delegate) {\x0a            var typeOfDelegate = typeof delegate;\x0a            return (typeOfDelegate === \x27function\x27 && task.callback === delegate) ||\x0a                (typeOfDelegate === \x27object\x27 && task.originalDelegate === delegate);\x0a        };\x0a        var compare = (patchOptions && patchOptions.diff) ? patchOptions.diff : compareTaskCallbackVsDelegate;\x0a        var blackListedEvents = Zone[Zone.__symbol__(\x27BLACK_LISTED_EVENTS\x27)];\x0a        var makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget, prepend) {\x0a            if (returnTarget === void 0) { returnTarget = false; }\x0a            if (prepend === void 0) { prepend = false; }\x0a            return function () {\x0a                var target = this || _global;\x0a                var delegate = arguments[1];\x0a                if (!delegate) {\x0a                    return nativeListener.apply(this, arguments);\x0a                }\x0a                // don\x27t create the bind delegate function for handleEvent\x0a                // case here to improve addEventListener performance\x0a                // we will create the bind delegate when invoke\x0a                var isHandleEvent = false;\x0a                if (typeof delegate !== \x27function\x27) {\x0a                    if (!delegate.handleEvent) {\x0a                        return nativeListener.apply(this, arguments);\x0a                    }\x0a                    isHandleEvent = true;\x0a                }\x0a                if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {\x0a                    return;\x0a                }\x0a                var eventName = arguments[0];\x0a                var options = arguments[2];\x0a                if (blackListedEvents) {\x0a                    // check black list\x0a                    for (var i = 0; i \x3c blackListedEvents.length; i++) {\x0a                        if (eventName === blackListedEvents[i]) {\x0a                            return nativeListener.apply(this, arguments);\x0a                        }\x0a                    }\x0a                }\x0a                var capture;\x0a                var once = false;\x0a                if (options === undefined) {\x0a                    capture = false;\x0a                }\x0a                else if (options === true) {\x0a                    capture = true;\x0a                }\x0a                else if (options === false) {\x0a                    capture = false;\x0a                }\x0a                else {\x0a                    capture = options ? !!options.capture : false;\x0a                    once = options ? !!options.once : false;\x0a                }\x0a                var zone = Zone.current;\x0a                var symbolEventNames = zoneSymbolEventNames$1[eventName];\x0a                var symbolEventName;\x0a                if (!symbolEventNames) {\x0a                    // the code is duplicate, but I just want to get some better performance\x0a                    var falseEventName = eventName + FALSE_STR;\x0a                    var trueEventName = eventName + TRUE_STR;\x0a                    var symbol = ZONE_SYMBOL_PREFIX + falseEventName;\x0a                    var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\x0a                    zoneSymbolEventNames$1[eventName] = {};\x0a                    zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;\x0a                    zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;\x0a                    symbolEventName = capture ? symbolCapture : symbol;\x0a                }\x0a                else {\x0a                    symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\x0a                }\x0a                var existingTasks = target[symbolEventName];\x0a                var isExisting = false;\x0a                if (existingTasks) {\x0a                    // already have task registered\x0a                    isExisting = true;\x0a                    if (checkDuplicate) {\x0a                        for (var i = 0; i \x3c existingTasks.length; i++) {\x0a                            if (compare(existingTasks[i], delegate)) {\x0a                                // same callback, same capture, same event name, just return\x0a                                return;\x0a                            }\x0a                        }\x0a                    }\x0a                }\x0a                else {\x0a                    existingTasks = target[symbolEventName] = [];\x0a                }\x0a                var source;\x0a                var constructorName = target.constructor[\x27name\x27];\x0a                var targetSource = globalSources[constructorName];\x0a                if (targetSource) {\x0a                    source = targetSource[eventName];\x0a                }\x0a                if (!source) {\x0a                    source = constructorName + addSource + eventName;\x0a                }\x0a                // do not create a new object as task.data to pass those things\x0a                // just use the global shared one\x0a                taskData.options = options;\x0a                if (once) {\x0a                    // if addEventListener with once options, we don\x27t pass it to\x0a                    // native addEventListener, instead we keep the once setting\x0a                    // and handle ourselves.\x0a                    taskData.options.once = false;\x0a                }\x0a                taskData.target = target;\x0a                taskData.capture = capture;\x0a                taskData.eventName = eventName;\x0a                taskData.isExisting = isExisting;\x0a                var data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : null;\x0a                // keep taskData into data to allow onScheduleEventTask to access the task information\x0a                if (data) {\x0a                    data.taskData = taskData;\x0a                }\x0a                var task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);\x0a                // should clear taskData.target to avoid memory leak\x0a                // issue, https://github.com/angular/angular/issues/20442\x0a                taskData.target = null;\x0a                // need to clear up taskData because it is a global object\x0a                if (data) {\x0a                    data.taskData = null;\x0a                }\x0a                // have to save those information to task in case\x0a                // application may call task.zone.cancelTask() directly\x0a                if (once) {\x0a                    options.once = true;\x0a                }\x0a                task.options = options;\x0a                task.target = target;\x0a                task.capture = capture;\x0a                task.eventName = eventName;\x0a                if (isHandleEvent) {\x0a                    // save original delegate for compare to check duplicate\x0a                    task.originalDelegate = delegate;\x0a                }\x0a                if (!prepend) {\x0a                    existingTasks.push(task);\x0a                }\x0a                else {\x0a                    existingTasks.unshift(task);\x0a                }\x0a                if (returnTarget) {\x0a                    return target;\x0a                }\x0a            };\x0a        };\x0a        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);\x0a        if (nativePrependEventListener) {\x0a            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);\x0a        }\x0a        proto[REMOVE_EVENT_LISTENER] = function () {\x0a            var target = this || _global;\x0a            var eventName = arguments[0];\x0a            var options = arguments[2];\x0a            var capture;\x0a            if (options === undefined) {\x0a                capture = false;\x0a            }\x0a            else if (options === true) {\x0a                capture = true;\x0a            }\x0a            else if (options === false) {\x0a                capture = false;\x0a            }\x0a            else {\x0a                capture = options ? !!options.capture : false;\x0a            }\x0a            var delegate = arguments[1];\x0a            if (!delegate) {\x0a                return nativeRemoveEventListener.apply(this, arguments);\x0a            }\x0a            if (validateHandler &&\x0a                !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {\x0a                return;\x0a            }\x0a            var symbolEventNames = zoneSymbolEventNames$1[eventName];\x0a            var symbolEventName;\x0a            if (symbolEventNames) {\x0a                symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\x0a            }\x0a            var existingTasks = symbolEventName && target[symbolEventName];\x0a            if (existingTasks) {\x0a                for (var i = 0; i \x3c existingTasks.length; i++) {\x0a                    var existingTask = existingTasks[i];\x0a                    if (compare(existingTask, delegate)) {\x0a                        existingTasks.splice(i, 1);\x0a                        // set isRemoved to data for faster invokeTask check\x0a                        existingTask.isRemoved = true;\x0a                        if (existingTasks.length === 0) {\x0a                            // all tasks for the eventName + capture have gone,\x0a                            // remove globalZoneAwareCallback and remove the task cache from target\x0a                            existingTask.allRemoved = true;\x0a                            target[symbolEventName] = null;\x0a                        }\x0a                        existingTask.zone.cancelTask(existingTask);\x0a                        if (returnTarget) {\x0a                            return target;\x0a                        }\x0a                        return;\x0a                    }\x0a                }\x0a            }\x0a            // issue 930, didn\x27t find the event name or callback\x0a            // from zone kept existingTasks, the callback maybe\x0a            // added outside of zone, we need to call native removeEventListener\x0a            // to try to remove it.\x0a            return nativeRemoveEventListener.apply(this, arguments);\x0a        };\x0a        proto[LISTENERS_EVENT_LISTENER] = function () {\x0a            var target = this || _global;\x0a            var eventName = arguments[0];\x0a            var listeners = [];\x0a            var tasks = findEventTasks(target, eventName);\x0a            for (var i = 0; i \x3c tasks.length; i++) {\x0a                var task = tasks[i];\x0a                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\x0a                listeners.push(delegate);\x0a            }\x0a            return listeners;\x0a        };\x0a        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {\x0a            var target = this || _global;\x0a            var eventName = arguments[0];\x0a            if (!eventName) {\x0a                var keys = Object.keys(target);\x0a                for (var i = 0; i \x3c keys.length; i++) {\x0a                    var prop = keys[i];\x0a                    var match = EVENT_NAME_SYMBOL_REGX.exec(prop);\x0a                    var evtName = match && match[1];\x0a                    // in nodejs EventEmitter, removeListener event is\x0a                    // used for monitoring the removeListener call,\x0a                    // so just keep removeListener eventListener until\x0a                    // all other eventListeners are removed\x0a                    if (evtName && evtName !== \x27removeListener\x27) {\x0a                        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);\x0a                    }\x0a                }\x0a                // remove removeListener listener finally\x0a                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, \x27removeListener\x27);\x0a            }\x0a            else {\x0a                var symbolEventNames = zoneSymbolEventNames$1[eventName];\x0a                if (symbolEventNames) {\x0a                    var symbolEventName = symbolEventNames[FALSE_STR];\x0a                    var symbolCaptureEventName = symbolEventNames[TRUE_STR];\x0a                    var tasks = target[symbolEventName];\x0a                    var captureTasks = target[symbolCaptureEventName];\x0a                    if (tasks) {\x0a                        var removeTasks = tasks.slice();\x0a                        for (var i = 0; i \x3c removeTasks.length; i++) {\x0a                            var task = removeTasks[i];\x0a                            var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\x0a                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\x0a                        }\x0a                    }\x0a                    if (captureTasks) {\x0a                        var removeTasks = captureTasks.slice();\x0a                        for (var i = 0; i \x3c removeTasks.length; i++) {\x0a                            var task = removeTasks[i];\x0a                            var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\x0a                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\x0a                        }\x0a                    }\x0a                }\x0a            }\x0a            if (returnTarget) {\x0a                return this;\x0a            }\x0a        };\x0a        // for native toString patch\x0a        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);\x0a        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);\x0a        if (nativeRemoveAllListeners) {\x0a            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);\x0a        }\x0a        if (nativeListeners) {\x0a            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);\x0a        }\x0a        return true;\x0a    }\x0a    var results = [];\x0a    for (var i = 0; i \x3c apis.length; i++) {\x0a        results[i] = patchEventTargetMethods(apis[i], patchOptions);\x0a    }\x0a    return results;\x0a}\x0afunction findEventTasks(target, eventName) {\x0a    var foundTasks = [];\x0a    for (var prop in target) {\x0a        var match = EVENT_NAME_SYMBOL_REGX.exec(prop);\x0a        var evtName = match && match[1];\x0a        if (evtName && (!eventName || evtName === eventName)) {\x0a            var tasks = target[prop];\x0a            if (tasks) {\x0a                for (var i = 0; i \x3c tasks.length; i++) {\x0a                    foundTasks.push(tasks[i]);\x0a                }\x0a            }\x0a        }\x0a    }\x0a    return foundTasks;\x0a}\x0afunction patchEventPrototype(global, api) {\x0a    var Event = global[\x27Event\x27];\x0a    if (Event && Event.prototype) {\x0a        api.patchMethod(Event.prototype, \x27stopImmediatePropagation\x27, function (delegate) { return function (self, args) {\x0a            self[IMMEDIATE_PROPAGATION_SYMBOL] = true;\x0a            // we need to call the native stopImmediatePropagation\x0a            // in case in some hybrid application, some part of\x0a            // application will be controlled by zone, some are not\x0a            delegate && delegate.apply(self, args);\x0a        }; });\x0a    }\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/**\x0a * @fileoverview\x0a * @suppress {missingRequire}\x0a */\x0avar taskSymbol = zoneSymbol(\x27zoneTask\x27);\x0afunction patchTimer(window, setName, cancelName, nameSuffix) {\x0a    var setNative = null;\x0a    var clearNative = null;\x0a    setName += nameSuffix;\x0a    cancelName += nameSuffix;\x0a    var tasksByHandleId = {};\x0a    function scheduleTask(task) {\x0a        var data = task.data;\x0a        function timer() {\x0a            try {\x0a                task.invoke.apply(this, arguments);\x0a            }\x0a            finally {\x0a                // issue-934, task will be cancelled\x0a                // even it is a periodic task such as\x0a                // setInterval\x0a                if (!(task.data && task.data.isPeriodic)) {\x0a                    if (typeof data.handleId === \x27number\x27) {\x0a                        // in non-nodejs env, we remove timerId\x0a                        // from local cache\x0a                        delete tasksByHandleId[data.handleId];\x0a                    }\x0a                    else if (data.handleId) {\x0a                        // Node returns complex objects as handleIds\x0a                        // we remove task reference from timer object\x0a                        data.handleId[taskSymbol] = null;\x0a                    }\x0a                }\x0a            }\x0a        }\x0a        data.args[0] = timer;\x0a        data.handleId = setNative.apply(window, data.args);\x0a        return task;\x0a    }\x0a    function clearTask(task) {\x0a        return clearNative(task.data.handleId);\x0a    }\x0a    setNative =\x0a        patchMethod(window, setName, function (delegate) { return function (self, args) {\x0a            if (typeof args[0] === \x27function\x27) {\x0a                var options = {\x0a                    handleId: null,\x0a                    isPeriodic: nameSuffix === \x27Interval\x27,\x0a                    delay: (nameSuffix === \x27Timeout\x27 || nameSuffix === \x27Interval\x27) ? args[1] || 0 : null,\x0a                    args: args\x0a                };\x0a                var task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);\x0a                if (!task) {\x0a                    return task;\x0a                }\x0a                // Node.js must additionally support the ref and unref functions.\x0a                var handle = task.data.handleId;\x0a                if (typeof handle === \x27number\x27) {\x0a                    // for non nodejs env, we save handleId: task\x0a                    // mapping in local cache for clearTimeout\x0a                    tasksByHandleId[handle] = task;\x0a                }\x0a                else if (handle) {\x0a                    // for nodejs env, we save task\x0a                    // reference in timerId Object for clearTimeout\x0a                    handle[taskSymbol] = task;\x0a                }\x0a                // check whether handle is null, because some polyfill or browser\x0a                // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame\x0a                if (handle && handle.ref && handle.unref && typeof handle.ref === \x27function\x27 &&\x0a                    typeof handle.unref === \x27function\x27) {\x0a                    task.ref = handle.ref.bind(handle);\x0a                    task.unref = handle.unref.bind(handle);\x0a                }\x0a                if (typeof handle === \x27number\x27 || handle) {\x0a                    return handle;\x0a                }\x0a                return task;\x0a            }\x0a            else {\x0a                // cause an error by calling it directly.\x0a                return delegate.apply(window, args);\x0a            }\x0a        }; });\x0a    clearNative =\x0a        patchMethod(window, cancelName, function (delegate) { return function (self, args) {\x0a            var id = args[0];\x0a            var task;\x0a            if (typeof id === \x27number\x27) {\x0a                // non nodejs env.\x0a                task = tasksByHandleId[id];\x0a            }\x0a            else {\x0a                // nodejs env.\x0a                task = id && id[taskSymbol];\x0a                // other environments.\x0a                if (!task) {\x0a                    task = id;\x0a                }\x0a            }\x0a            if (task && typeof task.type === \x27string\x27) {\x0a                if (task.state !== \x27notScheduled\x27 &&\x0a                    (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {\x0a                    if (typeof id === \x27number\x27) {\x0a                        delete tasksByHandleId[id];\x0a                    }\x0a                    else if (id) {\x0a                        id[taskSymbol] = null;\x0a                    }\x0a                    // Do not cancel already canceled functions\x0a                    task.zone.cancelTask(task);\x0a                }\x0a            }\x0a            else {\x0a                // cause an error by calling it directly.\x0a                delegate.apply(window, args);\x0a            }\x0a        }; });\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/*\x0a * This is necessary for Chrome and Chrome mobile, to enable\x0a * things like redefining `createdCallback` on an element.\x0a */\x0avar _defineProperty = Object[zoneSymbol(\x27defineProperty\x27)] = Object.defineProperty;\x0avar _getOwnPropertyDescriptor = Object[zoneSymbol(\x27getOwnPropertyDescriptor\x27)] =\x0a    Object.getOwnPropertyDescriptor;\x0avar _create = Object.create;\x0avar unconfigurablesKey = zoneSymbol(\x27unconfigurables\x27);\x0afunction propertyPatch() {\x0a    Object.defineProperty = function (obj, prop, desc) {\x0a        if (isUnconfigurable(obj, prop)) {\x0a            throw new TypeError(\x27Cannot assign to read only property \x5c\x27\x27 + prop + \x27\x5c\x27 of \x27 + obj);\x0a        }\x0a        var originalConfigurableFlag = desc.configurable;\x0a        if (prop !== \x27prototype\x27) {\x0a            desc = rewriteDescriptor(obj, prop, desc);\x0a        }\x0a        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\x0a    };\x0a    Object.defineProperties = function (obj, props) {\x0a        Object.keys(props).forEach(function (prop) {\x0a            Object.defineProperty(obj, prop, props[prop]);\x0a        });\x0a        return obj;\x0a    };\x0a    Object.create = function (obj, proto) {\x0a        if (typeof proto === \x27object\x27 && !Object.isFrozen(proto)) {\x0a            Object.keys(proto).forEach(function (prop) {\x0a                proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);\x0a            });\x0a        }\x0a        return _create(obj, proto);\x0a    };\x0a    Object.getOwnPropertyDescriptor = function (obj, prop) {\x0a        var desc = _getOwnPropertyDescriptor(obj, prop);\x0a        if (isUnconfigurable(obj, prop)) {\x0a            desc.configurable = false;\x0a        }\x0a        return desc;\x0a    };\x0a}\x0afunction _redefineProperty(obj, prop, desc) {\x0a    var originalConfigurableFlag = desc.configurable;\x0a    desc = rewriteDescriptor(obj, prop, desc);\x0a    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\x0a}\x0afunction isUnconfigurable(obj, prop) {\x0a    return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];\x0a}\x0afunction rewriteDescriptor(obj, prop, desc) {\x0a    // issue-927, if the desc is frozen, don\x27t try to change the desc\x0a    if (!Object.isFrozen(desc)) {\x0a        desc.configurable = true;\x0a    }\x0a    if (!desc.configurable) {\x0a        // issue-927, if the obj is frozen, don\x27t try to set the desc to obj\x0a        if (!obj[unconfigurablesKey] && !Object.isFrozen(obj)) {\x0a            _defineProperty(obj, unconfigurablesKey, { writable: true, value: {} });\x0a        }\x0a        if (obj[unconfigurablesKey]) {\x0a            obj[unconfigurablesKey][prop] = true;\x0a        }\x0a    }\x0a    return desc;\x0a}\x0afunction _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {\x0a    try {\x0a        return _defineProperty(obj, prop, desc);\x0a    }\x0a    catch (error) {\x0a        if (desc.configurable) {\x0a            // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let\x27s\x0a            // retry with the original flag value\x0a            if (typeof originalConfigurableFlag == \x27undefined\x27) {\x0a                delete desc.configurable;\x0a            }\x0a            else {\x0a                desc.configurable = originalConfigurableFlag;\x0a            }\x0a            try {\x0a                return _defineProperty(obj, prop, desc);\x0a            }\x0a            catch (error) {\x0a                var descJson = null;\x0a                try {\x0a                    descJson = JSON.stringify(desc);\x0a                }\x0a                catch (error) {\x0a                    descJson = desc.toString();\x0a                }\x0a                console.log(\x22Attempting to configure \x27\x22 + prop + \x22\x27 with descriptor \x27\x22 + descJson + \x22\x27 on object \x27\x22 + obj + \x22\x27 and got error, giving up: \x22 + error);\x0a            }\x0a        }\x0a        else {\x0a            throw error;\x0a        }\x0a    }\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a// we have to patch the instance since the proto is non-configurable\x0afunction apply(api, _global) {\x0a    var WS = _global.WebSocket;\x0a    // On Safari window.EventTarget doesn\x27t exist so need to patch WS add/removeEventListener\x0a    // On older Chrome, no need since EventTarget was already patched\x0a    if (!_global.EventTarget) {\x0a        patchEventTarget(_global, [WS.prototype]);\x0a    }\x0a    _global.WebSocket = function (x, y) {\x0a        var socket = arguments.length \x3e 1 ? new WS(x, y) : new WS(x);\x0a        var proxySocket;\x0a        var proxySocketProto;\x0a        // Safari 7.0 has non-configurable own \x27onmessage\x27 and friends properties on the socket instance\x0a        var onmessageDesc = ObjectGetOwnPropertyDescriptor(socket, \x27onmessage\x27);\x0a        if (onmessageDesc && onmessageDesc.configurable === false) {\x0a            proxySocket = ObjectCreate(socket);\x0a            // socket have own property descriptor \x27onopen\x27, \x27onmessage\x27, \x27onclose\x27, \x27onerror\x27\x0a            // but proxySocket not, so we will keep socket as prototype and pass it to\x0a            // patchOnProperties method\x0a            proxySocketProto = socket;\x0a            [ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, \x27send\x27, \x27close\x27].forEach(function (propName) {\x0a                proxySocket[propName] = function () {\x0a                    var args = ArraySlice.call(arguments);\x0a                    if (propName === ADD_EVENT_LISTENER_STR || propName === REMOVE_EVENT_LISTENER_STR) {\x0a                        var eventName = args.length \x3e 0 ? args[0] : undefined;\x0a                        if (eventName) {\x0a                            var propertySymbol = Zone.__symbol__(\x27ON_PROPERTY\x27 + eventName);\x0a                            socket[propertySymbol] = proxySocket[propertySymbol];\x0a                        }\x0a                    }\x0a                    return socket[propName].apply(socket, args);\x0a                };\x0a            });\x0a        }\x0a        else {\x0a            // we can patch the real socket\x0a            proxySocket = socket;\x0a        }\x0a        patchOnProperties(proxySocket, [\x27close\x27, \x27error\x27, \x27message\x27, \x27open\x27], proxySocketProto);\x0a        return proxySocket;\x0a    };\x0a    var globalWebSocket = _global[\x27WebSocket\x27];\x0a    for (var prop in WS) {\x0a        globalWebSocket[prop] = WS[prop];\x0a    }\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/**\x0a * @fileoverview\x0a * @suppress {globalThis}\x0a */\x0avar globalEventHandlersEventNames = [\x0a    \x27abort\x27,\x0a    \x27animationcancel\x27,\x0a    \x27animationend\x27,\x0a    \x27animationiteration\x27,\x0a    \x27auxclick\x27,\x0a    \x27beforeinput\x27,\x0a    \x27blur\x27,\x0a    \x27cancel\x27,\x0a    \x27canplay\x27,\x0a    \x27canplaythrough\x27,\x0a    \x27change\x27,\x0a    \x27compositionstart\x27,\x0a    \x27compositionupdate\x27,\x0a    \x27compositionend\x27,\x0a    \x27cuechange\x27,\x0a    \x27click\x27,\x0a    \x27close\x27,\x0a    \x27contextmenu\x27,\x0a    \x27curechange\x27,\x0a    \x27dblclick\x27,\x0a    \x27drag\x27,\x0a    \x27dragend\x27,\x0a    \x27dragenter\x27,\x0a    \x27dragexit\x27,\x0a    \x27dragleave\x27,\x0a    \x27dragover\x27,\x0a    \x27drop\x27,\x0a    \x27durationchange\x27,\x0a    \x27emptied\x27,\x0a    \x27ended\x27,\x0a    \x27error\x27,\x0a    \x27focus\x27,\x0a    \x27focusin\x27,\x0a    \x27focusout\x27,\x0a    \x27gotpointercapture\x27,\x0a    \x27input\x27,\x0a    \x27invalid\x27,\x0a    \x27keydown\x27,\x0a    \x27keypress\x27,\x0a    \x27keyup\x27,\x0a    \x27load\x27,\x0a    \x27loadstart\x27,\x0a    \x27loadeddata\x27,\x0a    \x27loadedmetadata\x27,\x0a    \x27lostpointercapture\x27,\x0a    \x27mousedown\x27,\x0a    \x27mouseenter\x27,\x0a    \x27mouseleave\x27,\x0a    \x27mousemove\x27,\x0a    \x27mouseout\x27,\x0a    \x27mouseover\x27,\x0a    \x27mouseup\x27,\x0a    \x27mousewheel\x27,\x0a    \x27orientationchange\x27,\x0a    \x27pause\x27,\x0a    \x27play\x27,\x0a    \x27playing\x27,\x0a    \x27pointercancel\x27,\x0a    \x27pointerdown\x27,\x0a    \x27pointerenter\x27,\x0a    \x27pointerleave\x27,\x0a    \x27pointerlockchange\x27,\x0a    \x27mozpointerlockchange\x27,\x0a    \x27webkitpointerlockerchange\x27,\x0a    \x27pointerlockerror\x27,\x0a    \x27mozpointerlockerror\x27,\x0a    \x27webkitpointerlockerror\x27,\x0a    \x27pointermove\x27,\x0a    \x27pointout\x27,\x0a    \x27pointerover\x27,\x0a    \x27pointerup\x27,\x0a    \x27progress\x27,\x0a    \x27ratechange\x27,\x0a    \x27reset\x27,\x0a    \x27resize\x27,\x0a    \x27scroll\x27,\x0a    \x27seeked\x27,\x0a    \x27seeking\x27,\x0a    \x27select\x27,\x0a    \x27selectionchange\x27,\x0a    \x27selectstart\x27,\x0a    \x27show\x27,\x0a    \x27sort\x27,\x0a    \x27stalled\x27,\x0a    \x27submit\x27,\x0a    \x27suspend\x27,\x0a    \x27timeupdate\x27,\x0a    \x27volumechange\x27,\x0a    \x27touchcancel\x27,\x0a    \x27touchmove\x27,\x0a    \x27touchstart\x27,\x0a    \x27touchend\x27,\x0a    \x27transitioncancel\x27,\x0a    \x27transitionend\x27,\x0a    \x27waiting\x27,\x0a    \x27wheel\x27\x0a];\x0avar documentEventNames = [\x0a    \x27afterscriptexecute\x27, \x27beforescriptexecute\x27, \x27DOMContentLoaded\x27, \x27fullscreenchange\x27,\x0a    \x27mozfullscreenchange\x27, \x27webkitfullscreenchange\x27, \x27msfullscreenchange\x27, \x27fullscreenerror\x27,\x0a    \x27mozfullscreenerror\x27, \x27webkitfullscreenerror\x27, \x27msfullscreenerror\x27, \x27readystatechange\x27,\x0a    \x27visibilitychange\x27\x0a];\x0avar windowEventNames = [\x0a    \x27absolutedeviceorientation\x27,\x0a    \x27afterinput\x27,\x0a    \x27afterprint\x27,\x0a    \x27appinstalled\x27,\x0a    \x27beforeinstallprompt\x27,\x0a    \x27beforeprint\x27,\x0a    \x27beforeunload\x27,\x0a    \x27devicelight\x27,\x0a    \x27devicemotion\x27,\x0a    \x27deviceorientation\x27,\x0a    \x27deviceorientationabsolute\x27,\x0a    \x27deviceproximity\x27,\x0a    \x27hashchange\x27,\x0a    \x27languagechange\x27,\x0a    \x27message\x27,\x0a    \x27mozbeforepaint\x27,\x0a    \x27offline\x27,\x0a    \x27online\x27,\x0a    \x27paint\x27,\x0a    \x27pageshow\x27,\x0a    \x27pagehide\x27,\x0a    \x27popstate\x27,\x0a    \x27rejectionhandled\x27,\x0a    \x27storage\x27,\x0a    \x27unhandledrejection\x27,\x0a    \x27unload\x27,\x0a    \x27userproximity\x27,\x0a    \x27vrdisplyconnected\x27,\x0a    \x27vrdisplaydisconnected\x27,\x0a    \x27vrdisplaypresentchange\x27\x0a];\x0avar htmlElementEventNames = [\x0a    \x27beforecopy\x27, \x27beforecut\x27, \x27beforepaste\x27, \x27copy\x27, \x27cut\x27, \x27paste\x27, \x27dragstart\x27, \x27loadend\x27,\x0a    \x27animationstart\x27, \x27search\x27, \x27transitionrun\x27, \x27transitionstart\x27, \x27webkitanimationend\x27,\x0a    \x27webkitanimationiteration\x27, \x27webkitanimationstart\x27, \x27webkittransitionend\x27\x0a];\x0avar mediaElementEventNames = [\x27encrypted\x27, \x27waitingforkey\x27, \x27msneedkey\x27, \x27mozinterruptbegin\x27, \x27mozinterruptend\x27];\x0avar ieElementEventNames = [\x0a    \x27activate\x27,\x0a    \x27afterupdate\x27,\x0a    \x27ariarequest\x27,\x0a    \x27beforeactivate\x27,\x0a    \x27beforedeactivate\x27,\x0a    \x27beforeeditfocus\x27,\x0a    \x27beforeupdate\x27,\x0a    \x27cellchange\x27,\x0a    \x27controlselect\x27,\x0a    \x27dataavailable\x27,\x0a    \x27datasetchanged\x27,\x0a    \x27datasetcomplete\x27,\x0a    \x27errorupdate\x27,\x0a    \x27filterchange\x27,\x0a    \x27layoutcomplete\x27,\x0a    \x27losecapture\x27,\x0a    \x27move\x27,\x0a    \x27moveend\x27,\x0a    \x27movestart\x27,\x0a    \x27propertychange\x27,\x0a    \x27resizeend\x27,\x0a    \x27resizestart\x27,\x0a    \x27rowenter\x27,\x0a    \x27rowexit\x27,\x0a    \x27rowsdelete\x27,\x0a    \x27rowsinserted\x27,\x0a    \x27command\x27,\x0a    \x27compassneedscalibration\x27,\x0a    \x27deactivate\x27,\x0a    \x27help\x27,\x0a    \x27mscontentzoom\x27,\x0a    \x27msmanipulationstatechanged\x27,\x0a    \x27msgesturechange\x27,\x0a    \x27msgesturedoubletap\x27,\x0a    \x27msgestureend\x27,\x0a    \x27msgesturehold\x27,\x0a    \x27msgesturestart\x27,\x0a    \x27msgesturetap\x27,\x0a    \x27msgotpointercapture\x27,\x0a    \x27msinertiastart\x27,\x0a    \x27mslostpointercapture\x27,\x0a    \x27mspointercancel\x27,\x0a    \x27mspointerdown\x27,\x0a    \x27mspointerenter\x27,\x0a    \x27mspointerhover\x27,\x0a    \x27mspointerleave\x27,\x0a    \x27mspointermove\x27,\x0a    \x27mspointerout\x27,\x0a    \x27mspointerover\x27,\x0a    \x27mspointerup\x27,\x0a    \x27pointerout\x27,\x0a    \x27mssitemodejumplistitemremoved\x27,\x0a    \x27msthumbnailclick\x27,\x0a    \x27stop\x27,\x0a    \x27storagecommit\x27\x0a];\x0avar webglEventNames = [\x27webglcontextrestored\x27, \x27webglcontextlost\x27, \x27webglcontextcreationerror\x27];\x0avar formEventNames = [\x27autocomplete\x27, \x27autocompleteerror\x27];\x0avar detailEventNames = [\x27toggle\x27];\x0avar frameEventNames = [\x27load\x27];\x0avar frameSetEventNames = [\x27blur\x27, \x27error\x27, \x27focus\x27, \x27load\x27, \x27resize\x27, \x27scroll\x27, \x27messageerror\x27];\x0avar marqueeEventNames = [\x27bounce\x27, \x27finish\x27, \x27start\x27];\x0avar XMLHttpRequestEventNames = [\x0a    \x27loadstart\x27, \x27progress\x27, \x27abort\x27, \x27error\x27, \x27load\x27, \x27progress\x27, \x27timeout\x27, \x27loadend\x27,\x0a    \x27readystatechange\x27\x0a];\x0avar IDBIndexEventNames = [\x27upgradeneeded\x27, \x27complete\x27, \x27abort\x27, \x27success\x27, \x27error\x27, \x27blocked\x27, \x27versionchange\x27, \x27close\x27];\x0avar websocketEventNames = [\x27close\x27, \x27error\x27, \x27open\x27, \x27message\x27];\x0avar workerEventNames = [\x27error\x27, \x27message\x27];\x0avar eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);\x0afunction filterProperties(target, onProperties, ignoreProperties) {\x0a    if (!ignoreProperties) {\x0a        return onProperties;\x0a    }\x0a    var tip = ignoreProperties.filter(function (ip) { return ip.target === target; });\x0a    if (!tip || tip.length === 0) {\x0a        return onProperties;\x0a    }\x0a    var targetIgnoreProperties = tip[0].ignoreProperties;\x0a    return onProperties.filter(function (op) { return targetIgnoreProperties.indexOf(op) === -1; });\x0a}\x0afunction patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {\x0a    // check whether target is available, sometimes target will be undefined\x0a    // because different browser or some 3rd party plugin.\x0a    if (!target) {\x0a        return;\x0a    }\x0a    var filteredProperties = filterProperties(target, onProperties, ignoreProperties);\x0a    patchOnProperties(target, filteredProperties, prototype);\x0a}\x0afunction propertyDescriptorPatch(api, _global) {\x0a    if (isNode && !isMix) {\x0a        return;\x0a    }\x0a    var supportsWebSocket = typeof WebSocket !== \x27undefined\x27;\x0a    if (canPatchViaPropertyDescriptor()) {\x0a        var ignoreProperties = _global.__Zone_ignore_on_properties;\x0a        // for browsers that we can patch the descriptor:  Chrome & Firefox\x0a        if (isBrowser) {\x0a            var internalWindow = window;\x0a            // in IE/Edge, onProp not exist in window object, but in WindowPrototype\x0a            // so we need to pass WindowPrototype to check onProp exist or not\x0a            patchFilteredProperties(internalWindow, eventNames.concat([\x27messageerror\x27]), ignoreProperties, ObjectGetPrototypeOf(internalWindow));\x0a            patchFilteredProperties(Document.prototype, eventNames, ignoreProperties);\x0a            if (typeof internalWindow[\x27SVGElement\x27] !== \x27undefined\x27) {\x0a                patchFilteredProperties(internalWindow[\x27SVGElement\x27].prototype, eventNames, ignoreProperties);\x0a            }\x0a            patchFilteredProperties(Element.prototype, eventNames, ignoreProperties);\x0a            patchFilteredProperties(HTMLElement.prototype, eventNames, ignoreProperties);\x0a            patchFilteredProperties(HTMLMediaElement.prototype, mediaElementEventNames, ignoreProperties);\x0a            patchFilteredProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);\x0a            patchFilteredProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);\x0a            patchFilteredProperties(HTMLFrameElement.prototype, frameEventNames, ignoreProperties);\x0a            patchFilteredProperties(HTMLIFrameElement.prototype, frameEventNames, ignoreProperties);\x0a            var HTMLMarqueeElement_1 = internalWindow[\x27HTMLMarqueeElement\x27];\x0a            if (HTMLMarqueeElement_1) {\x0a                patchFilteredProperties(HTMLMarqueeElement_1.prototype, marqueeEventNames, ignoreProperties);\x0a            }\x0a            var Worker_1 = internalWindow[\x27Worker\x27];\x0a            if (Worker_1) {\x0a                patchFilteredProperties(Worker_1.prototype, workerEventNames, ignoreProperties);\x0a            }\x0a        }\x0a        patchFilteredProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames, ignoreProperties);\x0a        var XMLHttpRequestEventTarget = _global[\x27XMLHttpRequestEventTarget\x27];\x0a        if (XMLHttpRequestEventTarget) {\x0a            patchFilteredProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames, ignoreProperties);\x0a        }\x0a        if (typeof IDBIndex !== \x27undefined\x27) {\x0a            patchFilteredProperties(IDBIndex.prototype, IDBIndexEventNames, ignoreProperties);\x0a            patchFilteredProperties(IDBRequest.prototype, IDBIndexEventNames, ignoreProperties);\x0a            patchFilteredProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames, ignoreProperties);\x0a            patchFilteredProperties(IDBDatabase.prototype, IDBIndexEventNames, ignoreProperties);\x0a            patchFilteredProperties(IDBTransaction.prototype, IDBIndexEventNames, ignoreProperties);\x0a            patchFilteredProperties(IDBCursor.prototype, IDBIndexEventNames, ignoreProperties);\x0a        }\x0a        if (supportsWebSocket) {\x0a            patchFilteredProperties(WebSocket.prototype, websocketEventNames, ignoreProperties);\x0a        }\x0a    }\x0a    else {\x0a        // Safari, Android browsers (Jelly Bean)\x0a        patchViaCapturingAllTheEvents();\x0a        patchClass(\x27XMLHttpRequest\x27);\x0a        if (supportsWebSocket) {\x0a            apply(api, _global);\x0a        }\x0a    }\x0a}\x0afunction canPatchViaPropertyDescriptor() {\x0a    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, \x27onclick\x27) &&\x0a        typeof Element !== \x27undefined\x27) {\x0a        // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364\x0a        // IDL interface attributes are not configurable\x0a        var desc = ObjectGetOwnPropertyDescriptor(Element.prototype, \x27onclick\x27);\x0a        if (desc && !desc.configurable)\x0a            return false;\x0a    }\x0a    var ON_READY_STATE_CHANGE = \x27onreadystatechange\x27;\x0a    var XMLHttpRequestPrototype = XMLHttpRequest.prototype;\x0a    var xhrDesc = ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);\x0a    // add enumerable and configurable here because in opera\x0a    // by default XMLHttpRequest.prototype.onreadystatechange is undefined\x0a    // without adding enumerable and configurable will cause onreadystatechange\x0a    // non-configurable\x0a    // and if XMLHttpRequest.prototype.onreadystatechange is undefined,\x0a    // we should set a real desc instead a fake one\x0a    if (xhrDesc) {\x0a        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {\x0a            enumerable: true,\x0a            configurable: true,\x0a            get: function () {\x0a                return true;\x0a            }\x0a        });\x0a        var req = new XMLHttpRequest();\x0a        var result = !!req.onreadystatechange;\x0a        // restore original desc\x0a        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});\x0a        return result;\x0a    }\x0a    else {\x0a        var SYMBOL_FAKE_ONREADYSTATECHANGE_1 = zoneSymbol(\x27fake\x27);\x0a        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {\x0a            enumerable: true,\x0a            configurable: true,\x0a            get: function () {\x0a                return this[SYMBOL_FAKE_ONREADYSTATECHANGE_1];\x0a            },\x0a            set: function (value) {\x0a                this[SYMBOL_FAKE_ONREADYSTATECHANGE_1] = value;\x0a            }\x0a        });\x0a        var req = new XMLHttpRequest();\x0a        var detectFunc = function () { };\x0a        req.onreadystatechange = detectFunc;\x0a        var result = req[SYMBOL_FAKE_ONREADYSTATECHANGE_1] === detectFunc;\x0a        req.onreadystatechange = null;\x0a        return result;\x0a    }\x0a}\x0avar unboundKey = zoneSymbol(\x27unbound\x27);\x0a// Whenever any eventListener fires, we check the eventListener target and all parents\x0a// for `onwhatever` properties and replace them with zone-bound functions\x0a// - Chrome (for now)\x0afunction patchViaCapturingAllTheEvents() {\x0a    var _loop_1 = function (i) {\x0a        var property = eventNames[i];\x0a        var onproperty = \x27on\x27 + property;\x0a        self.addEventListener(property, function (event) {\x0a            var elt = event.target, bound, source;\x0a            if (elt) {\x0a                source = elt.constructor[\x27name\x27] + \x27.\x27 + onproperty;\x0a            }\x0a            else {\x0a                source = \x27unknown.\x27 + onproperty;\x0a            }\x0a            while (elt) {\x0a                if (elt[onproperty] && !elt[onproperty][unboundKey]) {\x0a                    bound = wrapWithCurrentZone(elt[onproperty], source);\x0a                    bound[unboundKey] = elt[onproperty];\x0a                    elt[onproperty] = bound;\x0a                }\x0a                elt = elt.parentElement;\x0a            }\x0a        }, true);\x0a    };\x0a    for (var i = 0; i \x3c eventNames.length; i++) {\x0a        _loop_1(i);\x0a    }\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0afunction eventTargetPatch(_global, api) {\x0a    var WTF_ISSUE_555 = \x27Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video\x27;\x0a    var NO_EVENT_TARGET = \x27ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket\x27\x0a        .split(\x27,\x27);\x0a    var EVENT_TARGET = \x27EventTarget\x27;\x0a    var apis = [];\x0a    var isWtf = _global[\x27wtf\x27];\x0a    var WTF_ISSUE_555_ARRAY = WTF_ISSUE_555.split(\x27,\x27);\x0a    if (isWtf) {\x0a        // Workaround for: https://github.com/google/tracing-framework/issues/555\x0a        apis = WTF_ISSUE_555_ARRAY.map(function (v) { return \x27HTML\x27 + v + \x27Element\x27; }).concat(NO_EVENT_TARGET);\x0a    }\x0a    else if (_global[EVENT_TARGET]) {\x0a        apis.push(EVENT_TARGET);\x0a    }\x0a    else {\x0a        // Note: EventTarget is not available in all browsers,\x0a        // if it\x27s not available, we instead patch the APIs in the IDL that inherit from EventTarget\x0a        apis = NO_EVENT_TARGET;\x0a    }\x0a    var isDisableIECheck = _global[\x27__Zone_disable_IE_check\x27] || false;\x0a    var isEnableCrossContextCheck = _global[\x27__Zone_enable_cross_context_check\x27] || false;\x0a    var ieOrEdge = isIEOrEdge();\x0a    var ADD_EVENT_LISTENER_SOURCE = \x27.addEventListener:\x27;\x0a    var FUNCTION_WRAPPER = \x27[object FunctionWrapper]\x27;\x0a    var BROWSER_TOOLS = \x27function __BROWSERTOOLS_CONSOLE_SAFEFUNC() { [native code] }\x27;\x0a    //  predefine all __zone_symbol__ + eventName + true/false string\x0a    for (var i = 0; i \x3c eventNames.length; i++) {\x0a        var eventName = eventNames[i];\x0a        var falseEventName = eventName + FALSE_STR;\x0a        var trueEventName = eventName + TRUE_STR;\x0a        var symbol = ZONE_SYMBOL_PREFIX + falseEventName;\x0a        var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\x0a        zoneSymbolEventNames$1[eventName] = {};\x0a        zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;\x0a        zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;\x0a    }\x0a    //  predefine all task.source string\x0a    for (var i = 0; i \x3c WTF_ISSUE_555.length; i++) {\x0a        var target = WTF_ISSUE_555_ARRAY[i];\x0a        var targets = globalSources[target] = {};\x0a        for (var j = 0; j \x3c eventNames.length; j++) {\x0a            var eventName = eventNames[j];\x0a            targets[eventName] = target + ADD_EVENT_LISTENER_SOURCE + eventName;\x0a        }\x0a    }\x0a    var checkIEAndCrossContext = function (nativeDelegate, delegate, target, args) {\x0a        if (!isDisableIECheck && ieOrEdge) {\x0a            if (isEnableCrossContextCheck) {\x0a                try {\x0a                    var testString = delegate.toString();\x0a                    if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) {\x0a                        nativeDelegate.apply(target, args);\x0a                        return false;\x0a                    }\x0a                }\x0a                catch (error) {\x0a                    nativeDelegate.apply(target, args);\x0a                    return false;\x0a                }\x0a            }\x0a            else {\x0a                var testString = delegate.toString();\x0a                if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) {\x0a                    nativeDelegate.apply(target, args);\x0a                    return false;\x0a                }\x0a            }\x0a        }\x0a        else if (isEnableCrossContextCheck) {\x0a            try {\x0a                delegate.toString();\x0a            }\x0a            catch (error) {\x0a                nativeDelegate.apply(target, args);\x0a                return false;\x0a            }\x0a        }\x0a        return true;\x0a    };\x0a    var apiTypes = [];\x0a    for (var i = 0; i \x3c apis.length; i++) {\x0a        var type = _global[apis[i]];\x0a        apiTypes.push(type && type.prototype);\x0a    }\x0a    // vh is validateHandler to check event handler\x0a    // is valid or not(for security check)\x0a    patchEventTarget(_global, apiTypes, { vh: checkIEAndCrossContext });\x0a    api.patchEventTarget = patchEventTarget;\x0a    return true;\x0a}\x0afunction patchEvent(global, api) {\x0a    patchEventPrototype(global, api);\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0afunction registerElementPatch(_global) {\x0a    if ((!isBrowser && !isMix) || !(\x27registerElement\x27 in _global.document)) {\x0a        return;\x0a    }\x0a    var _registerElement = document.registerElement;\x0a    var callbacks = [\x27createdCallback\x27, \x27attachedCallback\x27, \x27detachedCallback\x27, \x27attributeChangedCallback\x27];\x0a    document.registerElement = function (name, opts) {\x0a        if (opts && opts.prototype) {\x0a            callbacks.forEach(function (callback) {\x0a                var source = \x27Document.registerElement::\x27 + callback;\x0a                var prototype = opts.prototype;\x0a                if (prototype.hasOwnProperty(callback)) {\x0a                    var descriptor = ObjectGetOwnPropertyDescriptor(prototype, callback);\x0a                    if (descriptor && descriptor.value) {\x0a                        descriptor.value = wrapWithCurrentZone(descriptor.value, source);\x0a                        _redefineProperty(opts.prototype, callback, descriptor);\x0a                    }\x0a                    else {\x0a                        prototype[callback] = wrapWithCurrentZone(prototype[callback], source);\x0a                    }\x0a                }\x0a                else if (prototype[callback]) {\x0a                    prototype[callback] = wrapWithCurrentZone(prototype[callback], source);\x0a                }\x0a            });\x0a        }\x0a        return _registerElement.call(document, name, opts);\x0a    };\x0a    attachOriginToPatched(document.registerElement, _registerElement);\x0a}\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a/**\x0a * @fileoverview\x0a * @suppress {missingRequire}\x0a */\x0aZone.__load_patch(\x27util\x27, function (global, Zone, api) {\x0a    api.patchOnProperties = patchOnProperties;\x0a    api.patchMethod = patchMethod;\x0a    api.bindArguments = bindArguments;\x0a});\x0aZone.__load_patch(\x27timers\x27, function (global) {\x0a    var set = \x27set\x27;\x0a    var clear = \x27clear\x27;\x0a    patchTimer(global, set, clear, \x27Timeout\x27);\x0a    patchTimer(global, set, clear, \x27Interval\x27);\x0a    patchTimer(global, set, clear, \x27Immediate\x27);\x0a});\x0aZone.__load_patch(\x27requestAnimationFrame\x27, function (global) {\x0a    patchTimer(global, \x27request\x27, \x27cancel\x27, \x27AnimationFrame\x27);\x0a    patchTimer(global, \x27mozRequest\x27, \x27mozCancel\x27, \x27AnimationFrame\x27);\x0a    patchTimer(global, \x27webkitRequest\x27, \x27webkitCancel\x27, \x27AnimationFrame\x27);\x0a});\x0aZone.__load_patch(\x27blocking\x27, function (global, Zone) {\x0a    var blockingMethods = [\x27alert\x27, \x27prompt\x27, \x27confirm\x27];\x0a    for (var i = 0; i \x3c blockingMethods.length; i++) {\x0a        var name_1 = blockingMethods[i];\x0a        patchMethod(global, name_1, function (delegate, symbol, name) {\x0a            return function (s, args) {\x0a                return Zone.current.run(delegate, global, args, name);\x0a            };\x0a        });\x0a    }\x0a});\x0aZone.__load_patch(\x27EventTarget\x27, function (global, Zone, api) {\x0a    // load blackListEvents from global\x0a    var SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__(\x27BLACK_LISTED_EVENTS\x27);\x0a    if (global[SYMBOL_BLACK_LISTED_EVENTS]) {\x0a        Zone[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_BLACK_LISTED_EVENTS];\x0a    }\x0a    patchEvent(global, api);\x0a    eventTargetPatch(global, api);\x0a    // patch XMLHttpRequestEventTarget\x27s addEventListener/removeEventListener\x0a    var XMLHttpRequestEventTarget = global[\x27XMLHttpRequestEventTarget\x27];\x0a    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\x0a        api.patchEventTarget(global, [XMLHttpRequestEventTarget.prototype]);\x0a    }\x0a    patchClass(\x27MutationObserver\x27);\x0a    patchClass(\x27WebKitMutationObserver\x27);\x0a    patchClass(\x27IntersectionObserver\x27);\x0a    patchClass(\x27FileReader\x27);\x0a});\x0aZone.__load_patch(\x27on_property\x27, function (global, Zone, api) {\x0a    propertyDescriptorPatch(api, global);\x0a    propertyPatch();\x0a    registerElementPatch(global);\x0a});\x0aZone.__load_patch(\x27canvas\x27, function (global) {\x0a    var HTMLCanvasElement = global[\x27HTMLCanvasElement\x27];\x0a    if (typeof HTMLCanvasElement !== \x27undefined\x27 && HTMLCanvasElement.prototype &&\x0a        HTMLCanvasElement.prototype.toBlob) {\x0a        patchMacroTask(HTMLCanvasElement.prototype, \x27toBlob\x27, function (self, args) {\x0a            return { name: \x27HTMLCanvasElement.toBlob\x27, target: self, cbIdx: 0, args: args };\x0a        });\x0a    }\x0a});\x0aZone.__load_patch(\x27XHR\x27, function (global, Zone) {\x0a    // Treat XMLHttpRequest as a macrotask.\x0a    patchXHR(global);\x0a    var XHR_TASK = zoneSymbol(\x27xhrTask\x27);\x0a    var XHR_SYNC = zoneSymbol(\x27xhrSync\x27);\x0a    var XHR_LISTENER = zoneSymbol(\x27xhrListener\x27);\x0a    var XHR_SCHEDULED = zoneSymbol(\x27xhrScheduled\x27);\x0a    var XHR_URL = zoneSymbol(\x27xhrURL\x27);\x0a    function patchXHR(window) {\x0a        var XMLHttpRequestPrototype = XMLHttpRequest.prototype;\x0a        function findPendingTask(target) {\x0a            return target[XHR_TASK];\x0a        }\x0a        var oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\x0a        var oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\x0a        if (!oriAddListener) {\x0a            var XMLHttpRequestEventTarget = window[\x27XMLHttpRequestEventTarget\x27];\x0a            if (XMLHttpRequestEventTarget) {\x0a                var XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;\x0a                oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\x0a                oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\x0a            }\x0a        }\x0a        var READY_STATE_CHANGE = \x27readystatechange\x27;\x0a        var SCHEDULED = \x27scheduled\x27;\x0a        function scheduleTask(task) {\x0a            XMLHttpRequest[XHR_SCHEDULED] = false;\x0a            var data = task.data;\x0a            var target = data.target;\x0a            // remove existing event listener\x0a            var listener = target[XHR_LISTENER];\x0a            if (!oriAddListener) {\x0a                oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];\x0a                oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\x0a            }\x0a            if (listener) {\x0a                oriRemoveListener.call(target, READY_STATE_CHANGE, listener);\x0a            }\x0a            var newListener = target[XHR_LISTENER] = function () {\x0a                if (target.readyState === target.DONE) {\x0a                    // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with\x0a                    // readyState=4 multiple times, so we need to check task state here\x0a                    if (!data.aborted && XMLHttpRequest[XHR_SCHEDULED] && task.state === SCHEDULED) {\x0a                        task.invoke();\x0a                    }\x0a                }\x0a            };\x0a            oriAddListener.call(target, READY_STATE_CHANGE, newListener);\x0a            var storedTask = target[XHR_TASK];\x0a            if (!storedTask) {\x0a                target[XHR_TASK] = task;\x0a            }\x0a            sendNative.apply(target, data.args);\x0a            XMLHttpRequest[XHR_SCHEDULED] = true;\x0a            return task;\x0a        }\x0a        function placeholderCallback() { }\x0a        function clearTask(task) {\x0a            var data = task.data;\x0a            // Note - ideally, we would call data.target.removeEventListener here, but it\x27s too late\x0a            // to prevent it from firing. So instead, we store info for the event listener.\x0a            data.aborted = true;\x0a            return abortNative.apply(data.target, data.args);\x0a        }\x0a        var openNative = patchMethod(XMLHttpRequestPrototype, \x27open\x27, function () { return function (self, args) {\x0a            self[XHR_SYNC] = args[2] == false;\x0a            self[XHR_URL] = args[1];\x0a            return openNative.apply(self, args);\x0a        }; });\x0a        var XMLHTTPREQUEST_SOURCE = \x27XMLHttpRequest.send\x27;\x0a        var sendNative = patchMethod(XMLHttpRequestPrototype, \x27send\x27, function () { return function (self, args) {\x0a            if (self[XHR_SYNC]) {\x0a                // if the XHR is sync there is no task to schedule, just execute the code.\x0a                return sendNative.apply(self, args);\x0a            }\x0a            else {\x0a                var options = {\x0a                    target: self,\x0a                    url: self[XHR_URL],\x0a                    isPeriodic: false,\x0a                    delay: null,\x0a                    args: args,\x0a                    aborted: false\x0a                };\x0a                return scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);\x0a            }\x0a        }; });\x0a        var abortNative = patchMethod(XMLHttpRequestPrototype, \x27abort\x27, function () { return function (self) {\x0a            var task = findPendingTask(self);\x0a            if (task && typeof task.type == \x27string\x27) {\x0a                // If the XHR has already completed, do nothing.\x0a                // If the XHR has already been aborted, do nothing.\x0a                // Fix #569, call abort multiple times before done will cause\x0a                // macroTask task count be negative number\x0a                if (task.cancelFn == null || (task.data && task.data.aborted)) {\x0a                    return;\x0a                }\x0a                task.zone.cancelTask(task);\x0a            }\x0a            // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no\x0a            // task\x0a            // to cancel. Do nothing.\x0a        }; });\x0a    }\x0a});\x0aZone.__load_patch(\x27geolocation\x27, function (global) {\x0a    /// GEO_LOCATION\x0a    if (global[\x27navigator\x27] && global[\x27navigator\x27].geolocation) {\x0a        patchPrototype(global[\x27navigator\x27].geolocation, [\x27getCurrentPosition\x27, \x27watchPosition\x27]);\x0a    }\x0a});\x0aZone.__load_patch(\x27PromiseRejectionEvent\x27, function (global, Zone) {\x0a    // handle unhandled promise rejection\x0a    function findPromiseRejectionHandler(evtName) {\x0a        return function (e) {\x0a            var eventTasks = findEventTasks(global, evtName);\x0a            eventTasks.forEach(function (eventTask) {\x0a                // windows has added unhandledrejection event listener\x0a                // trigger the event listener\x0a                var PromiseRejectionEvent = global[\x27PromiseRejectionEvent\x27];\x0a                if (PromiseRejectionEvent) {\x0a                    var evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });\x0a                    eventTask.invoke(evt);\x0a                }\x0a            });\x0a        };\x0a    }\x0a    if (global[\x27PromiseRejectionEvent\x27]) {\x0a        Zone[zoneSymbol(\x27unhandledPromiseRejectionHandler\x27)] =\x0a            findPromiseRejectionHandler(\x27unhandledrejection\x27);\x0a        Zone[zoneSymbol(\x27rejectionHandledHandler\x27)] =\x0a            findPromiseRejectionHandler(\x27rejectionhandled\x27);\x0a    }\x0a});\x0a\x0a/**\x0a * @license\x0a * Copyright Google Inc. All Rights Reserved.\x0a *\x0a * Use of this source code is governed by an MIT-style license that can be\x0a * found in the LICENSE file at https://angular.io/license\x0a */\x0a\x0a})));\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ \x22./src/polyfills.ts\x22:\x0a/*!**************************!*\x5c\x0a  !*** ./src/polyfills.ts ***!\x0a  \x5c**************************/\x0a/*! no exports provided */\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony import */ var core_js_es7_reflect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/es7/reflect */ \x22./node_modules/core-js/es7/reflect.js\x22);\x0a/* harmony import */ var core_js_es7_reflect__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_es7_reflect__WEBPACK_IMPORTED_MODULE_0__);\x0a/* harmony import */ var zone_js_dist_zone__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zone.js/dist/zone */ \x22./node_modules/zone.js/dist/zone.js\x22);\x0a/* harmony import */ var zone_js_dist_zone__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zone_js_dist_zone__WEBPACK_IMPORTED_MODULE_1__);\x0a/**\x0a * This file includes polyfills needed by Angular and is loaded before the app.\x0a * You can add your own extra polyfills to this file.\x0a *\x0a * This file is divided into 2 sections:\x0a *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.\x0a *   2. Application imports. Files imported after ZoneJS that should be loaded before your main\x0a *      file.\x0a *\x0a * The current setup is for so-called \x22evergreen\x22 browsers; the last versions of browsers that\x0a * automatically update themselves. This includes Safari \x3e= 10, Chrome \x3e= 55 (including Opera),\x0a * Edge \x3e= 13 on the desktop, and iOS 10 and Chrome on mobile.\x0a *\x0a * Learn more in https://angular.io/docs/ts/latest/guide/browser-support.html\x0a */\x0a/***************************************************************************************************\x0a * BROWSER POLYFILLS\x0a */\x0a/** IE9, IE10 and IE11 requires all of the following polyfills. **/\x0a// import \x27core-js/es6/symbol\x27;\x0a// import \x27core-js/es6/object\x27;\x0a// import \x27core-js/es6/function\x27;\x0a// import \x27core-js/es6/parse-int\x27;\x0a// import \x27core-js/es6/parse-float\x27;\x0a// import \x27core-js/es6/number\x27;\x0a// import \x27core-js/es6/math\x27;\x0a// import \x27core-js/es6/string\x27;\x0a// import \x27core-js/es6/date\x27;\x0a// import \x27core-js/es6/array\x27;\x0a// import \x27core-js/es6/regexp\x27;\x0a// import \x27core-js/es6/map\x27;\x0a// import \x27core-js/es6/weak-map\x27;\x0a// import \x27core-js/es6/set\x27;\x0a/** IE10 and IE11 requires the following for NgClass support on SVG elements */\x0a// import \x27classlist.js\x27;  // Run `npm install --save classlist.js`.\x0a/** IE10 and IE11 requires the following for the Reflect API. */\x0a// import \x27core-js/es6/reflect\x27;\x0a/** Evergreen browsers require these. **/\x0a// Used for reflect-metadata in JIT. If you use AOT (and only Angular decorators), you can remove.\x0a\x0a/**\x0a * Web Animations `@angular/platform-browser/animations`\x0a * Only required if AnimationBuilder is used within the application and using IE/Edge or Safari.\x0a * Standard animation support in Angular DOES NOT require any polyfills (as of Angular 6.0).\x0a **/\x0a// import \x27web-animations-js\x27;  // Run `npm install --save web-animations-js`.\x0a/**\x0a * By default, zone.js will patch all possible macroTask and DomEvents\x0a * user can disable parts of macroTask/DomEvents patch by setting following flags\x0a */\x0a// (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame\x0a// (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick\x0a// (window as any).__zone_symbol__BLACK_LISTED_EVENTS = [\x27scroll\x27, \x27mousemove\x27]; // disable patch specified eventNames\x0a/*\x0a* in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js\x0a* with the following flag, it will bypass `zone.js` patch for IE/Edge\x0a*/\x0a// (window as any).__Zone_enable_cross_context_check = true;\x0a/***************************************************************************************************\x0a * Zone JS is required by default for Angular itself.\x0a */\x0a // Included with Angular CLI.\x0a/***************************************************************************************************\x0a * APPLICATION IMPORTS\x0a */\x0a// import \x27hammerjs/hammer\x27;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 1:\x0a/*!********************************!*\x5c\x0a  !*** multi ./src/polyfills.ts ***!\x0a  \x5c********************************/\x0a/*! no static exports found */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0amodule.exports = __webpack_require__(/*! /home/okkindel/Dokumenty/STUDIES/SEMESTR 5/Bezpiecze\xc5\x84stwo/LIST_6/frontend/src/polyfills.ts */\x22./src/polyfills.ts\x22);\x0a\x0a\x0a/***/ })\x0a\x0a},[[1,\x22runtime\x22]]]);\x0a//# sourceMappingURL=polyfills.js.map'}