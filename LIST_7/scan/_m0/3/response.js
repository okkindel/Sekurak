var res = {'data':'HTTP/1.1 200 Partial Content\x0aX-Powered-By: Express\x0aAccess-Control-Allow-Origin: *\x0aAccept-Ranges: bytes\x0aContent-Range: bytes 0-225160/225161\x0aContent-Type: null; charset=UTF-8\x0aContent-Length: 225161\x0aETag: W/\x2236f89-8Q3bnX7rIiIoGr1sWj+WyRA5BbE\x22\x0aDate: Thu, 06 Dec 2018 12:44:45 GMT\x0aConnection: keep-alive\x0a\x0a{\x22version\x22:3,\x22sources\x22:[\x22webpack:///./node_modules/core-js/es7/reflect.js\x22,\x22webpack:///./node_modules/core-js/modules/_a-function.js\x22,\x22webpack:///./node_modules/core-js/modules/_an-instance.js\x22,\x22webpack:///./node_modules/core-js/modules/_an-object.js\x22,\x22webpack:///./node_modules/core-js/modules/_array-from-iterable.js\x22,\x22webpack:///./node_modules/core-js/modules/_array-includes.js\x22,\x22webpack:///./node_modules/core-js/modules/_array-methods.js\x22,\x22webpack:///./node_modules/core-js/modules/_array-species-constructor.js\x22,\x22webpack:///./node_modules/core-js/modules/_array-species-create.js\x22,\x22webpack:///./node_modules/core-js/modules/_classof.js\x22,\x22webpack:///./node_modules/core-js/modules/_cof.js\x22,\x22webpack:///./node_modules/core-js/modules/_collection-strong.js\x22,\x22webpack:///./node_modules/core-js/modules/_collection-weak.js\x22,\x22webpack:///./node_modules/core-js/modules/_collection.js\x22,\x22webpack:///./node_modules/core-js/modules/_core.js\x22,\x22webpack:///./node_modules/core-js/modules/_ctx.js\x22,\x22webpack:///./node_modules/core-js/modules/_defined.js\x22,\x22webpack:///./node_modules/core-js/modules/_descriptors.js\x22,\x22webpack:///./node_modules/core-js/modules/_dom-create.js\x22,\x22webpack:///./node_modules/core-js/modules/_enum-bug-keys.js\x22,\x22webpack:///./node_modules/core-js/modules/_export.js\x22,\x22webpack:///./node_modules/core-js/modules/_fails.js\x22,\x22webpack:///./node_modules/core-js/modules/_for-of.js\x22,\x22webpack:///./node_modules/core-js/modules/_global.js\x22,\x22webpack:///./node_modules/core-js/modules/_has.js\x22,\x22webpack:///./node_modules/core-js/modules/_hide.js\x22,\x22webpack:///./node_modules/core-js/modules/_html.js\x22,\x22webpack:///./node_modules/core-js/modules/_ie8-dom-define.js\x22,\x22webpack:///./node_modules/core-js/modules/_inherit-if-required.js\x22,\x22webpack:///./node_modules/core-js/modules/_iobject.js\x22,\x22webpack:///./node_modules/core-js/modules/_is-array-iter.js\x22,\x22webpack:///./node_modules/core-js/modules/_is-array.js\x22,\x22webpack:///./node_modules/core-js/modules/_is-object.js\x22,\x22webpack:///./node_modules/core-js/modules/_iter-call.js\x22,\x22webpack:///./node_modules/core-js/modules/_iter-create.js\x22,\x22webpack:///./node_modules/core-js/modules/_iter-define.js\x22,\x22webpack:///./node_modules/core-js/modules/_iter-detect.js\x22,\x22webpack:///./node_modules/core-js/modules/_iter-step.js\x22,\x22webpack:///./node_modules/core-js/modules/_iterators.js\x22,\x22webpack:///./node_modules/core-js/modules/_library.js\x22,\x22webpack:///./node_modules/core-js/modules/_meta.js\x22,\x22webpack:///./node_modules/core-js/modules/_metadata.js\x22,\x22webpack:///./node_modules/core-js/modules/_object-assign.js\x22,\x22webpack:///./node_modules/core-js/modules/_object-create.js\x22,\x22webpack:///./node_modules/core-js/modules/_object-dp.js\x22,\x22webpack:///./node_modules/core-js/modules/_object-dps.js\x22,\x22webpack:///./node_modules/core-js/modules/_object-gopd.js\x22,\x22webpack:///./node_modules/core-js/modules/_object-gops.js\x22,\x22webpack:///./node_modules/core-js/modules/_object-gpo.js\x22,\x22webpack:///./node_modules/core-js/modules/_object-keys-internal.js\x22,\x22webpack:///./node_modules/core-js/modules/_object-keys.js\x22,\x22webpack:///./node_modules/core-js/modules/_object-pie.js\x22,\x22webpack:///./node_modules/core-js/modules/_property-desc.js\x22,\x22webpack:///./node_modules/core-js/modules/_redefine-all.js\x22,\x22webpack:///./node_modules/core-js/modules/_redefine.js\x22,\x22webpack:///./node_modules/core-js/modules/_set-proto.js\x22,\x22webpack:///./node_modules/core-js/modules/_set-species.js\x22,\x22webpack:///./node_modules/core-js/modules/_set-to-string-tag.js\x22,\x22webpack:///./node_modules/core-js/modules/_shared-key.js\x22,\x22webpack:///./node_modules/core-js/modules/_shared.js\x22,\x22webpack:///./node_modules/core-js/modules/_to-absolute-index.js\x22,\x22webpack:///./node_modules/core-js/modules/_to-integer.js\x22,\x22webpack:///./node_modules/core-js/modules/_to-iobject.js\x22,\x22webpack:///./node_modules/core-js/modules/_to-length.js\x22,\x22webpack:///./node_modules/core-js/modules/_to-object.js\x22,\x22webpack:///./node_modules/core-js/modules/_to-primitive.js\x22,\x22webpack:///./node_modules/core-js/modules/_uid.js\x22,\x22webpack:///./node_modules/core-js/modules/_validate-collection.js\x22,\x22webpack:///./node_modules/core-js/modules/_wks.js\x22,\x22webpack:///./node_modules/core-js/modules/core.get-iterator-method.js\x22,\x22webpack:///./node_modules/core-js/modules/es6.map.js\x22,\x22webpack:///./node_modules/core-js/modules/es6.set.js\x22,\x22webpack:///./node_modules/core-js/modules/es6.weak-map.js\x22,\x22webpack:///./node_modules/core-js/modules/es7.reflect.define-metadata.js\x22,\x22webpack:///./node_modules/core-js/modules/es7.reflect.delete-metadata.js\x22,\x22webpack:///./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js\x22,\x22webpack:///./node_modules/core-js/modules/es7.reflect.get-metadata.js\x22,\x22webpack:///./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js\x22,\x22webpack:///./node_modules/core-js/modules/es7.reflect.get-own-metadata.js\x22,\x22webpack:///./node_modules/core-js/modules/es7.reflect.has-metadata.js\x22,\x22webpack:///./node_modules/core-js/modules/es7.reflect.has-own-metadata.js\x22,\x22webpack:///./node_modules/core-js/modules/es7.reflect.metadata.js\x22,\x22webpack:///./node_modules/zone.js/dist/zone.js\x22,\x22webpack:///./src/polyfills.ts\x22],\x22names\x22:[],\x22mappings\x22:\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,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,qBAAqB;AACrB,0BAA0B;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;;;;;;;;;;;;AC/Ia;AACb,kBAAkB,mBAAO,CAAC,wEAAiB;AAC3C,cAAc,mBAAO,CAAC,wDAAS;AAC/B,eAAe,mBAAO,CAAC,kEAAc;AACrC,eAAe,mBAAO,CAAC,kEAAc;AACrC,iBAAiB,mBAAO,CAAC,sEAAgB;AACzC,YAAY,mBAAO,CAAC,4DAAW;AAC/B,wBAAwB,mBAAO,CAAC,0EAAkB;AAClD,WAAW,mBAAO,CAAC,sDAAQ;AAC3B,eAAe,mBAAO,CAAC,sFAAwB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qBAAqB;AACrB,0BAA0B;AAC1B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;ACpFa;AACb,aAAa,mBAAO,CAAC,4DAAW;AAChC,cAAc,mBAAO,CAAC,4DAAW;AACjC,eAAe,mBAAO,CAAC,gEAAa;AACpC,kBAAkB,mBAAO,CAAC,wEAAiB;AAC3C,WAAW,mBAAO,CAAC,wDAAS;AAC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AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;ACpEA,eAAe,mBAAO,CAAC,sDAAQ;AAC/B;;AAEA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA,iCAAiC,SAAS,EAAE;AAC5C,CAAC,YAAY;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS,qBAAqB;AAC3D,iCAAiC,aAAa;AAC9C;AACA,GAAG,YAAY;AACf;AACA;;;;;;;;;;;;ACrBA;AACA,UAAU;AACV;;;;;;;;;;;;ACFA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA,WAAW,mBAAO,CAAC,sDAAQ;AAC3B,eAAe,mBAAO,CAAC,kEAAc;AACrC,UAAU,mBAAO,CAAC,sDAAQ;AAC1B,cAAc,mBAAO,CAAC,kEAAc;AACpC;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,0DAAU;AAChC,iDAAiD;AACjD,CAAC;AACD;AACA,qBAAqB;AACrB;AACA,SAAS;AACT,GAAG,EAAE;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA,UAAU,mBAAO,CAAC,4DAAW;AAC7B,cAAc,mBAAO,CAAC,4DAAW;AACjC,aAAa,mBAAO,CAAC,4DAAW;AAChC,iDAAiD,mBAAO,CAAC,sEAAgB;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB,EAAE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDa;AACb;AACA,cAAc,mBAAO,CAAC,sEAAgB;AACtC,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CvC;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;;;;;;;;;;;;ACdH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,KAA4D;AAC7D,CAAC,SACW;AACZ,CAAC,qBAAqB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D,uCAAuC,kBAAkB;AACzD,oCAAoC,eAAe;AACnD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD,uCAAuC,kBAAkB;AACzD,oCAAoC,eAAe;AACnD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,kFAAkF,gEAAgE,EAAE;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B,EAAE;AACnE;AACA;AACA;AACA,wCAAwC,6DAA6D,EAAE;AACvG,uCAAuC,WAAW,EAAE;AACpD;AACA,kCAAkC,aAAa,EAAE;AACjD,oCAAoC,aAAa,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4HAA4H,wBAAwB,oCAAoC;AACxL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,sEAAsE;AACtJ;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oDAAoD;AAC5F;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,+CAA+C,sBAAsB;AACrE;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oCAAoC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA,UAAU,EAAE;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,EAAE;AACZ;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,EAAE;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,0BAA0B,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,6BAA6B,EAAE;AACpF;AACA;AACA;AACA;AACA,8CAA8C,kDAAkD,EAAE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,+BAA+B,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,gBAAgB;AACrF;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,yCAAyC,6BAA6B;AACtE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA,UAAU,EAAE;AACZ;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,EAAE;AACZ,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,EAAE;AACZ;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,0CAA0C;AAC5G;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;;;;;;ACn/FD;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;GAcG;AAEH;;GAEG;AAEH,mEAAmE;AACnE,+BAA+B;AAC/B,+BAA+B;AAC/B,iCAAiC;AACjC,kCAAkC;AAClC,oCAAoC;AACpC,+BAA+B;AAC/B,6BAA6B;AAC7B,+BAA+B;AAC/B,6BAA6B;AAC7B,8BAA8B;AAC9B,+BAA+B;AAC/B,4BAA4B;AAC5B,iCAAiC;AACjC,4BAA4B;AAE5B,+EAA+E;AAC/E,oEAAoE;AAEpE,gEAAgE;AAChE,gCAAgC;AAGhC,yCAAyC;AACzC,kGAAkG;AACrE;AAG7B;;;;IAII;AACJ,8EAA8E;AAE9E;;;GAGG;AAEF,sGAAsG;AACtG,iGAAiG;AACjG,sHAAsH;AAEtH;;;EAGE;AACH,4DAA4D;AAE5D;;GAEG;AACwB,CAAE,6BAA6B;AAI1D;;GAEG;AAEH,4BAA4B\x22,\x22file\x22:\x22polyfills.js\x22,\x22sourcesContent\x22:[\x22require(\x27../modules/es7.reflect.define-metadata\x27);\x5cnrequire(\x27../modules/es7.reflect.delete-metadata\x27);\x5cnrequire(\x27../modules/es7.reflect.get-metadata\x27);\x5cnrequire(\x27../modules/es7.reflect.get-metadata-keys\x27);\x5cnrequire(\x27../modules/es7.reflect.get-own-metadata\x27);\x5cnrequire(\x27../modules/es7.reflect.get-own-metadata-keys\x27);\x5cnrequire(\x27../modules/es7.reflect.has-metadata\x27);\x5cnrequire(\x27../modules/es7.reflect.has-own-metadata\x27);\x5cnrequire(\x27../modules/es7.reflect.metadata\x27);\x5cnmodule.exports = require(\x27../modules/_core\x27).Reflect;\x5cn\x22,\x22module.exports = function (it) {\x5cn  if (typeof it != \x27function\x27) throw TypeError(it + \x27 is not a function!\x27);\x5cn  return it;\x5cn};\x5cn\x22,\x22module.exports = function (it, Constructor, name, forbiddenField) {\x5cn  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\x5cn    throw TypeError(name + \x27: incorrect invocation!\x27);\x5cn  } return it;\x5cn};\x5cn\x22,\x22var isObject = require(\x27./_is-object\x27);\x5cnmodule.exports = function (it) {\x5cn  if (!isObject(it)) throw TypeError(it + \x27 is not an object!\x27);\x5cn  return it;\x5cn};\x5cn\x22,\x22var forOf = require(\x27./_for-of\x27);\x5cn\x5cnmodule.exports = function (iter, ITERATOR) {\x5cn  var result = [];\x5cn  forOf(iter, false, result.push, result, ITERATOR);\x5cn  return result;\x5cn};\x5cn\x22,\x22// false -\x3e Array#indexOf\x5cn// true  -\x3e Array#includes\x5cnvar toIObject = require(\x27./_to-iobject\x27);\x5cnvar toLength = require(\x27./_to-length\x27);\x5cnvar toAbsoluteIndex = require(\x27./_to-absolute-index\x27);\x5cnmodule.exports = function (IS_INCLUDES) {\x5cn  return function ($this, el, fromIndex) {\x5cn    var O = toIObject($this);\x5cn    var length = toLength(O.length);\x5cn    var index = toAbsoluteIndex(fromIndex, length);\x5cn    var value;\x5cn    // Array#includes uses SameValueZero equality algorithm\x5cn    // eslint-disable-next-line no-self-compare\x5cn    if (IS_INCLUDES && el != el) while (length \x3e index) {\x5cn      value = O[index++];\x5cn      // eslint-disable-next-line no-self-compare\x5cn      if (value != value) return true;\x5cn    // Array#indexOf ignores holes, Array#includes - not\x5cn    } else for (;length \x3e index; index++) if (IS_INCLUDES || index in O) {\x5cn      if (O[index] === el) return IS_INCLUDES || index || 0;\x5cn    } return !IS_INCLUDES && -1;\x5cn  };\x5cn};\x5cn\x22,\x22// 0 -\x3e Array#forEach\x5cn// 1 -\x3e Array#map\x5cn// 2 -\x3e Array#filter\x5cn// 3 -\x3e Array#some\x5cn// 4 -\x3e Array#every\x5cn// 5 -\x3e Array#find\x5cn// 6 -\x3e Array#findIndex\x5cnvar ctx = require(\x27./_ctx\x27);\x5cnvar IObject = require(\x27./_iobject\x27);\x5cnvar toObject = require(\x27./_to-object\x27);\x5cnvar toLength = require(\x27./_to-length\x27);\x5cnvar asc = require(\x27./_array-species-create\x27);\x5cnmodule.exports = function (TYPE, $create) {\x5cn  var IS_MAP = TYPE == 1;\x5cn  var IS_FILTER = TYPE == 2;\x5cn  var IS_SOME = TYPE == 3;\x5cn  var IS_EVERY = TYPE == 4;\x5cn  var IS_FIND_INDEX = TYPE == 6;\x5cn  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\x5cn  var create = $create || asc;\x5cn  return function ($this, callbackfn, that) {\x5cn    var O = toObject($this);\x5cn    var self = IObject(O);\x5cn    var f = ctx(callbackfn, that, 3);\x5cn    var length = toLength(self.length);\x5cn    var index = 0;\x5cn    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\x5cn    var val, res;\x5cn    for (;length \x3e index; index++) if (NO_HOLES || index in self) {\x5cn      val = self[index];\x5cn      res = f(val, index, O);\x5cn      if (TYPE) {\x5cn        if (IS_MAP) result[index] = res;   // map\x5cn        else if (res) switch (TYPE) {\x5cn          case 3: return true;             // some\x5cn          case 5: return val;              // find\x5cn          case 6: return index;            // findIndex\x5cn          case 2: result.push(val);        // filter\x5cn        } else if (IS_EVERY) return false; // every\x5cn      }\x5cn    }\x5cn    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\x5cn  };\x5cn};\x5cn\x22,\x22var isObject = require(\x27./_is-object\x27);\x5cnvar isArray = require(\x27./_is-array\x27);\x5cnvar SPECIES = require(\x27./_wks\x27)(\x27species\x27);\x5cn\x5cnmodule.exports = function (original) {\x5cn  var C;\x5cn  if (isArray(original)) {\x5cn    C = original.constructor;\x5cn    // cross-realm fallback\x5cn    if (typeof C == \x27function\x27 && (C === Array || isArray(C.prototype))) C = undefined;\x5cn    if (isObject(C)) {\x5cn      C = C[SPECIES];\x5cn      if (C === null) C = undefined;\x5cn    }\x5cn  } return C === undefined ? Array : C;\x5cn};\x5cn\x22,\x22// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\x5cnvar speciesConstructor = require(\x27./_array-species-constructor\x27);\x5cn\x5cnmodule.exports = function (original, length) {\x5cn  return new (speciesConstructor(original))(length);\x5cn};\x5cn\x22,\x22// getting tag from 19.1.3.6 Object.prototype.toString()\x5cnvar cof = require(\x27./_cof\x27);\x5cnvar TAG = require(\x27./_wks\x27)(\x27toStringTag\x27);\x5cn// ES3 wrong here\x5cnvar ARG = cof(function () { return arguments; }()) == \x27Arguments\x27;\x5cn\x5cn// fallback for IE11 Script Access Denied error\x5cnvar tryGet = function (it, key) {\x5cn  try {\x5cn    return it[key];\x5cn  } catch (e) { /* empty */ }\x5cn};\x5cn\x5cnmodule.exports = function (it) {\x5cn  var O, T, B;\x5cn  return it === undefined ? \x27Undefined\x27 : it === null ? \x27Null\x27\x5cn    // @@toStringTag case\x5cn    : typeof (T = tryGet(O = Object(it), TAG)) == \x27string\x27 ? T\x5cn    // builtinTag case\x5cn    : ARG ? cof(O)\x5cn    // ES3 arguments fallback\x5cn    : (B = cof(O)) == \x27Object\x27 && typeof O.callee == \x27function\x27 ? \x27Arguments\x27 : B;\x5cn};\x5cn\x22,\x22var toString = {}.toString;\x5cn\x5cnmodule.exports = function (it) {\x5cn  return toString.call(it).slice(8, -1);\x5cn};\x5cn\x22,\x22\x27use strict\x27;\x5cnvar dP = require(\x27./_object-dp\x27).f;\x5cnvar create = require(\x27./_object-create\x27);\x5cnvar redefineAll = require(\x27./_redefine-all\x27);\x5cnvar ctx = require(\x27./_ctx\x27);\x5cnvar anInstance = require(\x27./_an-instance\x27);\x5cnvar forOf = require(\x27./_for-of\x27);\x5cnvar $iterDefine = require(\x27./_iter-define\x27);\x5cnvar step = require(\x27./_iter-step\x27);\x5cnvar setSpecies = require(\x27./_set-species\x27);\x5cnvar DESCRIPTORS = require(\x27./_descriptors\x27);\x5cnvar fastKey = require(\x27./_meta\x27).fastKey;\x5cnvar validate = require(\x27./_validate-collection\x27);\x5cnvar SIZE = DESCRIPTORS ? \x27_s\x27 : \x27size\x27;\x5cn\x5cnvar getEntry = function (that, key) {\x5cn  // fast case\x5cn  var index = fastKey(key);\x5cn  var entry;\x5cn  if (index !== \x27F\x27) return that._i[index];\x5cn  // frozen object case\x5cn  for (entry = that._f; entry; entry = entry.n) {\x5cn    if (entry.k == key) return entry;\x5cn  }\x5cn};\x5cn\x5cnmodule.exports = {\x5cn  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\x5cn    var C = wrapper(function (that, iterable) {\x5cn      anInstance(that, C, NAME, \x27_i\x27);\x5cn      that._t = NAME;         // collection type\x5cn      that._i = create(null); // index\x5cn      that._f = undefined;    // first entry\x5cn      that._l = undefined;    // last entry\x5cn      that[SIZE] = 0;         // size\x5cn      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\x5cn    });\x5cn    redefineAll(C.prototype, {\x5cn      // 23.1.3.1 Map.prototype.clear()\x5cn      // 23.2.3.2 Set.prototype.clear()\x5cn      clear: function clear() {\x5cn        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\x5cn          entry.r = true;\x5cn          if (entry.p) entry.p = entry.p.n = undefined;\x5cn          delete data[entry.i];\x5cn        }\x5cn        that._f = that._l = undefined;\x5cn        that[SIZE] = 0;\x5cn      },\x5cn      // 23.1.3.3 Map.prototype.delete(key)\x5cn      // 23.2.3.4 Set.prototype.delete(value)\x5cn      \x27delete\x27: function (key) {\x5cn        var that = validate(this, NAME);\x5cn        var entry = getEntry(that, key);\x5cn        if (entry) {\x5cn          var next = entry.n;\x5cn          var prev = entry.p;\x5cn          delete that._i[entry.i];\x5cn          entry.r = true;\x5cn          if (prev) prev.n = next;\x5cn          if (next) next.p = prev;\x5cn          if (that._f == entry) that._f = next;\x5cn          if (that._l == entry) that._l = prev;\x5cn          that[SIZE]--;\x5cn        } return !!entry;\x5cn      },\x5cn      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\x5cn      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\x5cn      forEach: function forEach(callbackfn /* , that = undefined */) {\x5cn        validate(this, NAME);\x5cn        var f = ctx(callbackfn, arguments.length \x3e 1 ? arguments[1] : undefined, 3);\x5cn        var entry;\x5cn        while (entry = entry ? entry.n : this._f) {\x5cn          f(entry.v, entry.k, this);\x5cn          // revert to the last existing entry\x5cn          while (entry && entry.r) entry = entry.p;\x5cn        }\x5cn      },\x5cn      // 23.1.3.7 Map.prototype.has(key)\x5cn      // 23.2.3.7 Set.prototype.has(value)\x5cn      has: function has(key) {\x5cn        return !!getEntry(validate(this, NAME), key);\x5cn      }\x5cn    });\x5cn    if (DESCRIPTORS) dP(C.prototype, \x27size\x27, {\x5cn      get: function () {\x5cn        return validate(this, NAME)[SIZE];\x5cn      }\x5cn    });\x5cn    return C;\x5cn  },\x5cn  def: function (that, key, value) {\x5cn    var entry = getEntry(that, key);\x5cn    var prev, index;\x5cn    // change existing entry\x5cn    if (entry) {\x5cn      entry.v = value;\x5cn    // create new entry\x5cn    } else {\x5cn      that._l = entry = {\x5cn        i: index = fastKey(key, true), // \x3c- index\x5cn        k: key,                        // \x3c- key\x5cn        v: value,                      // \x3c- value\x5cn        p: prev = that._l,             // \x3c- previous entry\x5cn        n: undefined,                  // \x3c- next entry\x5cn        r: false                       // \x3c- removed\x5cn      };\x5cn      if (!that._f) that._f = entry;\x5cn      if (prev) prev.n = entry;\x5cn      that[SIZE]++;\x5cn      // add to index\x5cn      if (index !== \x27F\x27) that._i[index] = entry;\x5cn    } return that;\x5cn  },\x5cn  getEntry: getEntry,\x5cn  setStrong: function (C, NAME, IS_MAP) {\x5cn    // add .keys, .values, .entries, [@@iterator]\x5cn    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\x5cn    $iterDefine(C, NAME, function (iterated, kind) {\x5cn      this._t = validate(iterated, NAME); // target\x5cn      this._k = kind;                     // kind\x5cn      this._l = undefined;                // previous\x5cn    }, function () {\x5cn      var that = this;\x5cn      var kind = that._k;\x5cn      var entry = that._l;\x5cn      // revert to the last existing entry\x5cn      while (entry && entry.r) entry = entry.p;\x5cn      // get next entry\x5cn      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\x5cn        // or finish the iteration\x5cn        that._t = undefined;\x5cn        return step(1);\x5cn      }\x5cn      // return step by kind\x5cn      if (kind == \x27keys\x27) return step(0, entry.k);\x5cn      if (kind == \x27values\x27) return step(0, entry.v);\x5cn      return step(0, [entry.k, entry.v]);\x5cn    }, IS_MAP ? \x27entries\x27 : \x27values\x27, !IS_MAP, true);\x5cn\x5cn    // add [@@species], 23.1.2.2, 23.2.2.2\x5cn    setSpecies(NAME);\x5cn  }\x5cn};\x5cn\x22,\x22\x27use strict\x27;\x5cnvar redefineAll = require(\x27./_redefine-all\x27);\x5cnvar getWeak = require(\x27./_meta\x27).getWeak;\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar isObject = require(\x27./_is-object\x27);\x5cnvar anInstance = require(\x27./_an-instance\x27);\x5cnvar forOf = require(\x27./_for-of\x27);\x5cnvar createArrayMethod = require(\x27./_array-methods\x27);\x5cnvar $has = require(\x27./_has\x27);\x5cnvar validate = require(\x27./_validate-collection\x27);\x5cnvar arrayFind = createArrayMethod(5);\x5cnvar arrayFindIndex = createArrayMethod(6);\x5cnvar id = 0;\x5cn\x5cn// fallback for uncaught frozen keys\x5cnvar uncaughtFrozenStore = function (that) {\x5cn  return that._l || (that._l = new UncaughtFrozenStore());\x5cn};\x5cnvar UncaughtFrozenStore = function () {\x5cn  this.a = [];\x5cn};\x5cnvar findUncaughtFrozen = function (store, key) {\x5cn  return arrayFind(store.a, function (it) {\x5cn    return it[0] === key;\x5cn  });\x5cn};\x5cnUncaughtFrozenStore.prototype = {\x5cn  get: function (key) {\x5cn    var entry = findUncaughtFrozen(this, key);\x5cn    if (entry) return entry[1];\x5cn  },\x5cn  has: function (key) {\x5cn    return !!findUncaughtFrozen(this, key);\x5cn  },\x5cn  set: function (key, value) {\x5cn    var entry = findUncaughtFrozen(this, key);\x5cn    if (entry) entry[1] = value;\x5cn    else this.a.push([key, value]);\x5cn  },\x5cn  \x27delete\x27: function (key) {\x5cn    var index = arrayFindIndex(this.a, function (it) {\x5cn      return it[0] === key;\x5cn    });\x5cn    if (~index) this.a.splice(index, 1);\x5cn    return !!~index;\x5cn  }\x5cn};\x5cn\x5cnmodule.exports = {\x5cn  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\x5cn    var C = wrapper(function (that, iterable) {\x5cn      anInstance(that, C, NAME, \x27_i\x27);\x5cn      that._t = NAME;      // collection type\x5cn      that._i = id++;      // collection id\x5cn      that._l = undefined; // leak store for uncaught frozen objects\x5cn      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\x5cn    });\x5cn    redefineAll(C.prototype, {\x5cn      // 23.3.3.2 WeakMap.prototype.delete(key)\x5cn      // 23.4.3.3 WeakSet.prototype.delete(value)\x5cn      \x27delete\x27: function (key) {\x5cn        if (!isObject(key)) return false;\x5cn        var data = getWeak(key);\x5cn        if (data === true) return uncaughtFrozenStore(validate(this, NAME))[\x27delete\x27](key);\x5cn        return data && $has(data, this._i) && delete data[this._i];\x5cn      },\x5cn      // 23.3.3.4 WeakMap.prototype.has(key)\x5cn      // 23.4.3.4 WeakSet.prototype.has(value)\x5cn      has: function has(key) {\x5cn        if (!isObject(key)) return false;\x5cn        var data = getWeak(key);\x5cn        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\x5cn        return data && $has(data, this._i);\x5cn      }\x5cn    });\x5cn    return C;\x5cn  },\x5cn  def: function (that, key, value) {\x5cn    var data = getWeak(anObject(key), true);\x5cn    if (data === true) uncaughtFrozenStore(that).set(key, value);\x5cn    else data[that._i] = value;\x5cn    return that;\x5cn  },\x5cn  ufstore: uncaughtFrozenStore\x5cn};\x5cn\x22,\x22\x27use strict\x27;\x5cnvar global = require(\x27./_global\x27);\x5cnvar $export = require(\x27./_export\x27);\x5cnvar redefine = require(\x27./_redefine\x27);\x5cnvar redefineAll = require(\x27./_redefine-all\x27);\x5cnvar meta = require(\x27./_meta\x27);\x5cnvar forOf = require(\x27./_for-of\x27);\x5cnvar anInstance = require(\x27./_an-instance\x27);\x5cnvar isObject = require(\x27./_is-object\x27);\x5cnvar fails = require(\x27./_fails\x27);\x5cnvar $iterDetect = require(\x27./_iter-detect\x27);\x5cnvar setToStringTag = require(\x27./_set-to-string-tag\x27);\x5cnvar inheritIfRequired = require(\x27./_inherit-if-required\x27);\x5cn\x5cnmodule.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\x5cn  var Base = global[NAME];\x5cn  var C = Base;\x5cn  var ADDER = IS_MAP ? \x27set\x27 : \x27add\x27;\x5cn  var proto = C && C.prototype;\x5cn  var O = {};\x5cn  var fixMethod = function (KEY) {\x5cn    var fn = proto[KEY];\x5cn    redefine(proto, KEY,\x5cn      KEY == \x27delete\x27 ? function (a) {\x5cn        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\x5cn      } : KEY == \x27has\x27 ? function has(a) {\x5cn        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\x5cn      } : KEY == \x27get\x27 ? function get(a) {\x5cn        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\x5cn      } : KEY == \x27add\x27 ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }\x5cn        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }\x5cn    );\x5cn  };\x5cn  if (typeof C != \x27function\x27 || !(IS_WEAK || proto.forEach && !fails(function () {\x5cn    new C().entries().next();\x5cn  }))) {\x5cn    // create collection constructor\x5cn    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\x5cn    redefineAll(C.prototype, methods);\x5cn    meta.NEED = true;\x5cn  } else {\x5cn    var instance = new C();\x5cn    // early implementations not supports chaining\x5cn    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\x5cn    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\x5cn    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\x5cn    // most early implementations doesn\x27t supports iterables, most modern - not close it correctly\x5cn    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new\x5cn    // for early implementations -0 and +0 not the same\x5cn    var BUGGY_ZERO = !IS_WEAK && fails(function () {\x5cn      // V8 ~ Chromium 42- fails only with 5+ elements\x5cn      var $instance = new C();\x5cn      var index = 5;\x5cn      while (index--) $instance[ADDER](index, index);\x5cn      return !$instance.has(-0);\x5cn    });\x5cn    if (!ACCEPT_ITERABLES) {\x5cn      C = wrapper(function (target, iterable) {\x5cn        anInstance(target, C, NAME);\x5cn        var that = inheritIfRequired(new Base(), target, C);\x5cn        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\x5cn        return that;\x5cn      });\x5cn      C.prototype = proto;\x5cn      proto.constructor = C;\x5cn    }\x5cn    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\x5cn      fixMethod(\x27delete\x27);\x5cn      fixMethod(\x27has\x27);\x5cn      IS_MAP && fixMethod(\x27get\x27);\x5cn    }\x5cn    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\x5cn    // weak collections should not contains .clear method\x5cn    if (IS_WEAK && proto.clear) delete proto.clear;\x5cn  }\x5cn\x5cn  setToStringTag(C, NAME);\x5cn\x5cn  O[NAME] = C;\x5cn  $export($export.G + $export.W + $export.F * (C != Base), O);\x5cn\x5cn  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\x5cn\x5cn  return C;\x5cn};\x5cn\x22,\x22var core = module.exports = { version: \x272.5.7\x27 };\x5cnif (typeof __e == \x27number\x27) __e = core; // eslint-disable-line no-undef\x5cn\x22,\x22// optional / simple context binding\x5cnvar aFunction = require(\x27./_a-function\x27);\x5cnmodule.exports = function (fn, that, length) {\x5cn  aFunction(fn);\x5cn  if (that === undefined) return fn;\x5cn  switch (length) {\x5cn    case 1: return function (a) {\x5cn      return fn.call(that, a);\x5cn    };\x5cn    case 2: return function (a, b) {\x5cn      return fn.call(that, a, b);\x5cn    };\x5cn    case 3: return function (a, b, c) {\x5cn      return fn.call(that, a, b, c);\x5cn    };\x5cn  }\x5cn  return function (/* ...args */) {\x5cn    return fn.apply(that, arguments);\x5cn  };\x5cn};\x5cn\x22,\x22// 7.2.1 RequireObjectCoercible(argument)\x5cnmodule.exports = function (it) {\x5cn  if (it == undefined) throw TypeError(\x5c\x22Can\x27t call method on  \x5c\x22 + it);\x5cn  return it;\x5cn};\x5cn\x22,\x22// Thank\x27s IE8 for his funny defineProperty\x5cnmodule.exports = !require(\x27./_fails\x27)(function () {\x5cn  return Object.defineProperty({}, \x27a\x27, { get: function () { return 7; } }).a != 7;\x5cn});\x5cn\x22,\x22var isObject = require(\x27./_is-object\x27);\x5cnvar document = require(\x27./_global\x27).document;\x5cn// typeof document.createElement is \x27object\x27 in old IE\x5cnvar is = isObject(document) && isObject(document.createElement);\x5cnmodule.exports = function (it) {\x5cn  return is ? document.createElement(it) : {};\x5cn};\x5cn\x22,\x22// IE 8- don\x27t enum bug keys\x5cnmodule.exports = (\x5cn  \x27constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\x27\x5cn).split(\x27,\x27);\x5cn\x22,\x22var global = require(\x27./_global\x27);\x5cnvar core = require(\x27./_core\x27);\x5cnvar hide = require(\x27./_hide\x27);\x5cnvar redefine = require(\x27./_redefine\x27);\x5cnvar ctx = require(\x27./_ctx\x27);\x5cnvar PROTOTYPE = \x27prototype\x27;\x5cn\x5cnvar $export = function (type, name, source) {\x5cn  var IS_FORCED = type & $export.F;\x5cn  var IS_GLOBAL = type & $export.G;\x5cn  var IS_STATIC = type & $export.S;\x5cn  var IS_PROTO = type & $export.P;\x5cn  var IS_BIND = type & $export.B;\x5cn  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\x5cn  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\x5cn  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\x5cn  var key, own, out, exp;\x5cn  if (IS_GLOBAL) source = name;\x5cn  for (key in source) {\x5cn    // contains in native\x5cn    own = !IS_FORCED && target && target[key] !== undefined;\x5cn    // export native or passed\x5cn    out = (own ? target : source)[key];\x5cn    // bind timers to global for call from export context\x5cn    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == \x27function\x27 ? ctx(Function.call, out) : out;\x5cn    // extend global\x5cn    if (target) redefine(target, key, out, type & $export.U);\x5cn    // export\x5cn    if (exports[key] != out) hide(exports, key, exp);\x5cn    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\x5cn  }\x5cn};\x5cnglobal.core = core;\x5cn// type bitmap\x5cn$export.F = 1;   // forced\x5cn$export.G = 2;   // global\x5cn$export.S = 4;   // static\x5cn$export.P = 8;   // proto\x5cn$export.B = 16;  // bind\x5cn$export.W = 32;  // wrap\x5cn$export.U = 64;  // safe\x5cn$export.R = 128; // real proto method for `library`\x5cnmodule.exports = $export;\x5cn\x22,\x22module.exports = function (exec) {\x5cn  try {\x5cn    return !!exec();\x5cn  } catch (e) {\x5cn    return true;\x5cn  }\x5cn};\x5cn\x22,\x22var ctx = require(\x27./_ctx\x27);\x5cnvar call = require(\x27./_iter-call\x27);\x5cnvar isArrayIter = require(\x27./_is-array-iter\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar toLength = require(\x27./_to-length\x27);\x5cnvar getIterFn = require(\x27./core.get-iterator-method\x27);\x5cnvar BREAK = {};\x5cnvar RETURN = {};\x5cnvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\x5cn  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\x5cn  var f = ctx(fn, that, entries ? 2 : 1);\x5cn  var index = 0;\x5cn  var length, step, iterator, result;\x5cn  if (typeof iterFn != \x27function\x27) throw TypeError(iterable + \x27 is not iterable!\x27);\x5cn  // fast case for arrays with default iterator\x5cn  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length \x3e index; index++) {\x5cn    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\x5cn    if (result === BREAK || result === RETURN) return result;\x5cn  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\x5cn    result = call(iterator, f, step.value, entries);\x5cn    if (result === BREAK || result === RETURN) return result;\x5cn  }\x5cn};\x5cnexports.BREAK = BREAK;\x5cnexports.RETURN = RETURN;\x5cn\x22,\x22// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\x5cnvar global = module.exports = typeof window != \x27undefined\x27 && window.Math == Math\x5cn  ? window : typeof self != \x27undefined\x27 && self.Math == Math ? self\x5cn  // eslint-disable-next-line no-new-func\x5cn  : Function(\x27return this\x27)();\x5cnif (typeof __g == \x27number\x27) __g = global; // eslint-disable-line no-undef\x5cn\x22,\x22var hasOwnProperty = {}.hasOwnProperty;\x5cnmodule.exports = function (it, key) {\x5cn  return hasOwnProperty.call(it, key);\x5cn};\x5cn\x22,\x22var dP = require(\x27./_object-dp\x27);\x5cnvar createDesc = require(\x27./_property-desc\x27);\x5cnmodule.exports = require(\x27./_descriptors\x27) ? function (object, key, value) {\x5cn  return dP.f(object, key, createDesc(1, value));\x5cn} : function (object, key, value) {\x5cn  object[key] = value;\x5cn  return object;\x5cn};\x5cn\x22,\x22var document = require(\x27./_global\x27).document;\x5cnmodule.exports = document && document.documentElement;\x5cn\x22,\x22module.exports = !require(\x27./_descriptors\x27) && !require(\x27./_fails\x27)(function () {\x5cn  return Object.defineProperty(require(\x27./_dom-create\x27)(\x27div\x27), \x27a\x27, { get: function () { return 7; } }).a != 7;\x5cn});\x5cn\x22,\x22var isObject = require(\x27./_is-object\x27);\x5cnvar setPrototypeOf = require(\x27./_set-proto\x27).set;\x5cnmodule.exports = function (that, target, C) {\x5cn  var S = target.constructor;\x5cn  var P;\x5cn  if (S !== C && typeof S == \x27function\x27 && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {\x5cn    setPrototypeOf(that, P);\x5cn  } return that;\x5cn};\x5cn\x22,\x22// fallback for non-array-like ES3 and non-enumerable old V8 strings\x5cnvar cof = require(\x27./_cof\x27);\x5cn// eslint-disable-next-line no-prototype-builtins\x5cnmodule.exports = Object(\x27z\x27).propertyIsEnumerable(0) ? Object : function (it) {\x5cn  return cof(it) == \x27String\x27 ? it.split(\x27\x27) : Object(it);\x5cn};\x5cn\x22,\x22// check on default Array iterator\x5cnvar Iterators = require(\x27./_iterators\x27);\x5cnvar ITERATOR = require(\x27./_wks\x27)(\x27iterator\x27);\x5cnvar ArrayProto = Array.prototype;\x5cn\x5cnmodule.exports = function (it) {\x5cn  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\x5cn};\x5cn\x22,\x22// 7.2.2 IsArray(argument)\x5cnvar cof = require(\x27./_cof\x27);\x5cnmodule.exports = Array.isArray || function isArray(arg) {\x5cn  return cof(arg) == \x27Array\x27;\x5cn};\x5cn\x22,\x22module.exports = function (it) {\x5cn  return typeof it === \x27object\x27 ? it !== null : typeof it === \x27function\x27;\x5cn};\x5cn\x22,\x22// call something on iterator step with safe closing on error\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnmodule.exports = function (iterator, fn, value, entries) {\x5cn  try {\x5cn    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\x5cn  // 7.4.6 IteratorClose(iterator, completion)\x5cn  } catch (e) {\x5cn    var ret = iterator[\x27return\x27];\x5cn    if (ret !== undefined) anObject(ret.call(iterator));\x5cn    throw e;\x5cn  }\x5cn};\x5cn\x22,\x22\x27use strict\x27;\x5cnvar create = require(\x27./_object-create\x27);\x5cnvar descriptor = require(\x27./_property-desc\x27);\x5cnvar setToStringTag = require(\x27./_set-to-string-tag\x27);\x5cnvar IteratorPrototype = {};\x5cn\x5cn// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\x5cnrequire(\x27./_hide\x27)(IteratorPrototype, require(\x27./_wks\x27)(\x27iterator\x27), function () { return this; });\x5cn\x5cnmodule.exports = function (Constructor, NAME, next) {\x5cn  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\x5cn  setToStringTag(Constructor, NAME + \x27 Iterator\x27);\x5cn};\x5cn\x22,\x22\x27use strict\x27;\x5cnvar LIBRARY = require(\x27./_library\x27);\x5cnvar $export = require(\x27./_export\x27);\x5cnvar redefine = require(\x27./_redefine\x27);\x5cnvar hide = require(\x27./_hide\x27);\x5cnvar Iterators = require(\x27./_iterators\x27);\x5cnvar $iterCreate = require(\x27./_iter-create\x27);\x5cnvar setToStringTag = require(\x27./_set-to-string-tag\x27);\x5cnvar getPrototypeOf = require(\x27./_object-gpo\x27);\x5cnvar ITERATOR = require(\x27./_wks\x27)(\x27iterator\x27);\x5cnvar BUGGY = !([].keys && \x27next\x27 in [].keys()); // Safari has buggy iterators w/o `next`\x5cnvar FF_ITERATOR = \x27@@iterator\x27;\x5cnvar KEYS = \x27keys\x27;\x5cnvar VALUES = \x27values\x27;\x5cn\x5cnvar returnThis = function () { return this; };\x5cn\x5cnmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\x5cn  $iterCreate(Constructor, NAME, next);\x5cn  var getMethod = function (kind) {\x5cn    if (!BUGGY && kind in proto) return proto[kind];\x5cn    switch (kind) {\x5cn      case KEYS: return function keys() { return new Constructor(this, kind); };\x5cn      case VALUES: return function values() { return new Constructor(this, kind); };\x5cn    } return function entries() { return new Constructor(this, kind); };\x5cn  };\x5cn  var TAG = NAME + \x27 Iterator\x27;\x5cn  var DEF_VALUES = DEFAULT == VALUES;\x5cn  var VALUES_BUG = false;\x5cn  var proto = Base.prototype;\x5cn  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\x5cn  var $default = $native || getMethod(DEFAULT);\x5cn  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod(\x27entries\x27) : undefined;\x5cn  var $anyNative = NAME == \x27Array\x27 ? proto.entries || $native : $native;\x5cn  var methods, key, IteratorPrototype;\x5cn  // Fix native\x5cn  if ($anyNative) {\x5cn    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\x5cn    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\x5cn      // Set @@toStringTag to native iterators\x5cn      setToStringTag(IteratorPrototype, TAG, true);\x5cn      // fix for some old engines\x5cn      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != \x27function\x27) hide(IteratorPrototype, ITERATOR, returnThis);\x5cn    }\x5cn  }\x5cn  // fix Array#{values, @@iterator}.name in V8 / FF\x5cn  if (DEF_VALUES && $native && $native.name !== VALUES) {\x5cn    VALUES_BUG = true;\x5cn    $default = function values() { return $native.call(this); };\x5cn  }\x5cn  // Define iterator\x5cn  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\x5cn    hide(proto, ITERATOR, $default);\x5cn  }\x5cn  // Plug for library\x5cn  Iterators[NAME] = $default;\x5cn  Iterators[TAG] = returnThis;\x5cn  if (DEFAULT) {\x5cn    methods = {\x5cn      values: DEF_VALUES ? $default : getMethod(VALUES),\x5cn      keys: IS_SET ? $default : getMethod(KEYS),\x5cn      entries: $entries\x5cn    };\x5cn    if (FORCED) for (key in methods) {\x5cn      if (!(key in proto)) redefine(proto, key, methods[key]);\x5cn    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\x5cn  }\x5cn  return methods;\x5cn};\x5cn\x22,\x22var ITERATOR = require(\x27./_wks\x27)(\x27iterator\x27);\x5cnvar SAFE_CLOSING = false;\x5cn\x5cntry {\x5cn  var riter = [7][ITERATOR]();\x5cn  riter[\x27return\x27] = function () { SAFE_CLOSING = true; };\x5cn  // eslint-disable-next-line no-throw-literal\x5cn  Array.from(riter, function () { throw 2; });\x5cn} catch (e) { /* empty */ }\x5cn\x5cnmodule.exports = function (exec, skipClosing) {\x5cn  if (!skipClosing && !SAFE_CLOSING) return false;\x5cn  var safe = false;\x5cn  try {\x5cn    var arr = [7];\x5cn    var iter = arr[ITERATOR]();\x5cn    iter.next = function () { return { done: safe = true }; };\x5cn    arr[ITERATOR] = function () { return iter; };\x5cn    exec(arr);\x5cn  } catch (e) { /* empty */ }\x5cn  return safe;\x5cn};\x5cn\x22,\x22module.exports = function (done, value) {\x5cn  return { value: value, done: !!done };\x5cn};\x5cn\x22,\x22module.exports = {};\x5cn\x22,\x22module.exports = false;\x5cn\x22,\x22var META = require(\x27./_uid\x27)(\x27meta\x27);\x5cnvar isObject = require(\x27./_is-object\x27);\x5cnvar has = require(\x27./_has\x27);\x5cnvar setDesc = require(\x27./_object-dp\x27).f;\x5cnvar id = 0;\x5cnvar isExtensible = Object.isExtensible || function () {\x5cn  return true;\x5cn};\x5cnvar FREEZE = !require(\x27./_fails\x27)(function () {\x5cn  return isExtensible(Object.preventExtensions({}));\x5cn});\x5cnvar setMeta = function (it) {\x5cn  setDesc(it, META, { value: {\x5cn    i: \x27O\x27 + ++id, // object ID\x5cn    w: {}          // weak collections IDs\x5cn  } });\x5cn};\x5cnvar fastKey = function (it, create) {\x5cn  // return primitive with prefix\x5cn  if (!isObject(it)) return typeof it == \x27symbol\x27 ? it : (typeof it == \x27string\x27 ? \x27S\x27 : \x27P\x27) + it;\x5cn  if (!has(it, META)) {\x5cn    // can\x27t set metadata to uncaught frozen object\x5cn    if (!isExtensible(it)) return \x27F\x27;\x5cn    // not necessary to add metadata\x5cn    if (!create) return \x27E\x27;\x5cn    // add missing metadata\x5cn    setMeta(it);\x5cn  // return object ID\x5cn  } return it[META].i;\x5cn};\x5cnvar getWeak = function (it, create) {\x5cn  if (!has(it, META)) {\x5cn    // can\x27t set metadata to uncaught frozen object\x5cn    if (!isExtensible(it)) return true;\x5cn    // not necessary to add metadata\x5cn    if (!create) return false;\x5cn    // add missing metadata\x5cn    setMeta(it);\x5cn  // return hash weak collections IDs\x5cn  } return it[META].w;\x5cn};\x5cn// add metadata on freeze-family methods calling\x5cnvar onFreeze = function (it) {\x5cn  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\x5cn  return it;\x5cn};\x5cnvar meta = module.exports = {\x5cn  KEY: META,\x5cn  NEED: false,\x5cn  fastKey: fastKey,\x5cn  getWeak: getWeak,\x5cn  onFreeze: onFreeze\x5cn};\x5cn\x22,\x22var Map = require(\x27./es6.map\x27);\x5cnvar $export = require(\x27./_export\x27);\x5cnvar shared = require(\x27./_shared\x27)(\x27metadata\x27);\x5cnvar store = shared.store || (shared.store = new (require(\x27./es6.weak-map\x27))());\x5cn\x5cnvar getOrCreateMetadataMap = function (target, targetKey, create) {\x5cn  var targetMetadata = store.get(target);\x5cn  if (!targetMetadata) {\x5cn    if (!create) return undefined;\x5cn    store.set(target, targetMetadata = new Map());\x5cn  }\x5cn  var keyMetadata = targetMetadata.get(targetKey);\x5cn  if (!keyMetadata) {\x5cn    if (!create) return undefined;\x5cn    targetMetadata.set(targetKey, keyMetadata = new Map());\x5cn  } return keyMetadata;\x5cn};\x5cnvar ordinaryHasOwnMetadata = function (MetadataKey, O, P) {\x5cn  var metadataMap = getOrCreateMetadataMap(O, P, false);\x5cn  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);\x5cn};\x5cnvar ordinaryGetOwnMetadata = function (MetadataKey, O, P) {\x5cn  var metadataMap = getOrCreateMetadataMap(O, P, false);\x5cn  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);\x5cn};\x5cnvar ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {\x5cn  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);\x5cn};\x5cnvar ordinaryOwnMetadataKeys = function (target, targetKey) {\x5cn  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);\x5cn  var keys = [];\x5cn  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });\x5cn  return keys;\x5cn};\x5cnvar toMetaKey = function (it) {\x5cn  return it === undefined || typeof it == \x27symbol\x27 ? it : String(it);\x5cn};\x5cnvar exp = function (O) {\x5cn  $export($export.S, \x27Reflect\x27, O);\x5cn};\x5cn\x5cnmodule.exports = {\x5cn  store: store,\x5cn  map: getOrCreateMetadataMap,\x5cn  has: ordinaryHasOwnMetadata,\x5cn  get: ordinaryGetOwnMetadata,\x5cn  set: ordinaryDefineOwnMetadata,\x5cn  keys: ordinaryOwnMetadataKeys,\x5cn  key: toMetaKey,\x5cn  exp: exp\x5cn};\x5cn\x22,\x22\x27use strict\x27;\x5cn// 19.1.2.1 Object.assign(target, source, ...)\x5cnvar getKeys = require(\x27./_object-keys\x27);\x5cnvar gOPS = require(\x27./_object-gops\x27);\x5cnvar pIE = require(\x27./_object-pie\x27);\x5cnvar toObject = require(\x27./_to-object\x27);\x5cnvar IObject = require(\x27./_iobject\x27);\x5cnvar $assign = Object.assign;\x5cn\x5cn// should work with symbols and should have deterministic property order (V8 bug)\x5cnmodule.exports = !$assign || require(\x27./_fails\x27)(function () {\x5cn  var A = {};\x5cn  var B = {};\x5cn  // eslint-disable-next-line no-undef\x5cn  var S = Symbol();\x5cn  var K = \x27abcdefghijklmnopqrst\x27;\x5cn  A[S] = 7;\x5cn  K.split(\x27\x27).forEach(function (k) { B[k] = k; });\x5cn  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join(\x27\x27) != K;\x5cn}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\x5cn  var T = toObject(target);\x5cn  var aLen = arguments.length;\x5cn  var index = 1;\x5cn  var getSymbols = gOPS.f;\x5cn  var isEnum = pIE.f;\x5cn  while (aLen \x3e index) {\x5cn    var S = IObject(arguments[index++]);\x5cn    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\x5cn    var length = keys.length;\x5cn    var j = 0;\x5cn    var key;\x5cn    while (length \x3e j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\x5cn  } return T;\x5cn} : $assign;\x5cn\x22,\x22// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar dPs = require(\x27./_object-dps\x27);\x5cnvar enumBugKeys = require(\x27./_enum-bug-keys\x27);\x5cnvar IE_PROTO = require(\x27./_shared-key\x27)(\x27IE_PROTO\x27);\x5cnvar Empty = function () { /* empty */ };\x5cnvar PROTOTYPE = \x27prototype\x27;\x5cn\x5cn// Create object with fake `null` prototype: use iframe Object with cleared prototype\x5cnvar createDict = function () {\x5cn  // Thrash, waste and sodomy: IE GC bug\x5cn  var iframe = require(\x27./_dom-create\x27)(\x27iframe\x27);\x5cn  var i = enumBugKeys.length;\x5cn  var lt = \x27\x3c\x27;\x5cn  var gt = \x27\x3e\x27;\x5cn  var iframeDocument;\x5cn  iframe.style.display = \x27none\x27;\x5cn  require(\x27./_html\x27).appendChild(iframe);\x5cn  iframe.src = \x27javascript:\x27; // eslint-disable-line no-script-url\x5cn  // createDict = iframe.contentWindow.Object;\x5cn  // html.removeChild(iframe);\x5cn  iframeDocument = iframe.contentWindow.document;\x5cn  iframeDocument.open();\x5cn  iframeDocument.write(lt + \x27script\x27 + gt + \x27document.F=Object\x27 + lt + \x27/script\x27 + gt);\x5cn  iframeDocument.close();\x5cn  createDict = iframeDocument.F;\x5cn  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\x5cn  return createDict();\x5cn};\x5cn\x5cnmodule.exports = Object.create || function create(O, Properties) {\x5cn  var result;\x5cn  if (O !== null) {\x5cn    Empty[PROTOTYPE] = anObject(O);\x5cn    result = new Empty();\x5cn    Empty[PROTOTYPE] = null;\x5cn    // add \x5c\x22__proto__\x5c\x22 for Object.getPrototypeOf polyfill\x5cn    result[IE_PROTO] = O;\x5cn  } else result = createDict();\x5cn  return Properties === undefined ? result : dPs(result, Properties);\x5cn};\x5cn\x22,\x22var anObject = require(\x27./_an-object\x27);\x5cnvar IE8_DOM_DEFINE = require(\x27./_ie8-dom-define\x27);\x5cnvar toPrimitive = require(\x27./_to-primitive\x27);\x5cnvar dP = Object.defineProperty;\x5cn\x5cnexports.f = require(\x27./_descriptors\x27) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\x5cn  anObject(O);\x5cn  P = toPrimitive(P, true);\x5cn  anObject(Attributes);\x5cn  if (IE8_DOM_DEFINE) try {\x5cn    return dP(O, P, Attributes);\x5cn  } catch (e) { /* empty */ }\x5cn  if (\x27get\x27 in Attributes || \x27set\x27 in Attributes) throw TypeError(\x27Accessors not supported!\x27);\x5cn  if (\x27value\x27 in Attributes) O[P] = Attributes.value;\x5cn  return O;\x5cn};\x5cn\x22,\x22var dP = require(\x27./_object-dp\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar getKeys = require(\x27./_object-keys\x27);\x5cn\x5cnmodule.exports = require(\x27./_descriptors\x27) ? Object.defineProperties : function defineProperties(O, Properties) {\x5cn  anObject(O);\x5cn  var keys = getKeys(Properties);\x5cn  var length = keys.length;\x5cn  var i = 0;\x5cn  var P;\x5cn  while (length \x3e i) dP.f(O, P = keys[i++], Properties[P]);\x5cn  return O;\x5cn};\x5cn\x22,\x22var pIE = require(\x27./_object-pie\x27);\x5cnvar createDesc = require(\x27./_property-desc\x27);\x5cnvar toIObject = require(\x27./_to-iobject\x27);\x5cnvar toPrimitive = require(\x27./_to-primitive\x27);\x5cnvar has = require(\x27./_has\x27);\x5cnvar IE8_DOM_DEFINE = require(\x27./_ie8-dom-define\x27);\x5cnvar gOPD = Object.getOwnPropertyDescriptor;\x5cn\x5cnexports.f = require(\x27./_descriptors\x27) ? gOPD : function getOwnPropertyDescriptor(O, P) {\x5cn  O = toIObject(O);\x5cn  P = toPrimitive(P, true);\x5cn  if (IE8_DOM_DEFINE) try {\x5cn    return gOPD(O, P);\x5cn  } catch (e) { /* empty */ }\x5cn  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\x5cn};\x5cn\x22,\x22exports.f = Object.getOwnPropertySymbols;\x5cn\x22,\x22// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\x5cnvar has = require(\x27./_has\x27);\x5cnvar toObject = require(\x27./_to-object\x27);\x5cnvar IE_PROTO = require(\x27./_shared-key\x27)(\x27IE_PROTO\x27);\x5cnvar ObjectProto = Object.prototype;\x5cn\x5cnmodule.exports = Object.getPrototypeOf || function (O) {\x5cn  O = toObject(O);\x5cn  if (has(O, IE_PROTO)) return O[IE_PROTO];\x5cn  if (typeof O.constructor == \x27function\x27 && O instanceof O.constructor) {\x5cn    return O.constructor.prototype;\x5cn  } return O instanceof Object ? ObjectProto : null;\x5cn};\x5cn\x22,\x22var has = require(\x27./_has\x27);\x5cnvar toIObject = require(\x27./_to-iobject\x27);\x5cnvar arrayIndexOf = require(\x27./_array-includes\x27)(false);\x5cnvar IE_PROTO = require(\x27./_shared-key\x27)(\x27IE_PROTO\x27);\x5cn\x5cnmodule.exports = function (object, names) {\x5cn  var O = toIObject(object);\x5cn  var i = 0;\x5cn  var result = [];\x5cn  var key;\x5cn  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\x5cn  // Don\x27t enum bug & hidden keys\x5cn  while (names.length \x3e i) if (has(O, key = names[i++])) {\x5cn    ~arrayIndexOf(result, key) || result.push(key);\x5cn  }\x5cn  return result;\x5cn};\x5cn\x22,\x22// 19.1.2.14 / 15.2.3.14 Object.keys(O)\x5cnvar $keys = require(\x27./_object-keys-internal\x27);\x5cnvar enumBugKeys = require(\x27./_enum-bug-keys\x27);\x5cn\x5cnmodule.exports = Object.keys || function keys(O) {\x5cn  return $keys(O, enumBugKeys);\x5cn};\x5cn\x22,\x22exports.f = {}.propertyIsEnumerable;\x5cn\x22,\x22module.exports = function (bitmap, value) {\x5cn  return {\x5cn    enumerable: !(bitmap & 1),\x5cn    configurable: !(bitmap & 2),\x5cn    writable: !(bitmap & 4),\x5cn    value: value\x5cn  };\x5cn};\x5cn\x22,\x22var redefine = require(\x27./_redefine\x27);\x5cnmodule.exports = function (target, src, safe) {\x5cn  for (var key in src) redefine(target, key, src[key], safe);\x5cn  return target;\x5cn};\x5cn\x22,\x22var global = require(\x27./_global\x27);\x5cnvar hide = require(\x27./_hide\x27);\x5cnvar has = require(\x27./_has\x27);\x5cnvar SRC = require(\x27./_uid\x27)(\x27src\x27);\x5cnvar TO_STRING = \x27toString\x27;\x5cnvar $toString = Function[TO_STRING];\x5cnvar TPL = (\x27\x27 + $toString).split(TO_STRING);\x5cn\x5cnrequire(\x27./_core\x27).inspectSource = function (it) {\x5cn  return $toString.call(it);\x5cn};\x5cn\x5cn(module.exports = function (O, key, val, safe) {\x5cn  var isFunction = typeof val == \x27function\x27;\x5cn  if (isFunction) has(val, \x27name\x27) || hide(val, \x27name\x27, key);\x5cn  if (O[key] === val) return;\x5cn  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? \x27\x27 + O[key] : TPL.join(String(key)));\x5cn  if (O === global) {\x5cn    O[key] = val;\x5cn  } else if (!safe) {\x5cn    delete O[key];\x5cn    hide(O, key, val);\x5cn  } else if (O[key]) {\x5cn    O[key] = val;\x5cn  } else {\x5cn    hide(O, key, val);\x5cn  }\x5cn// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\x5cn})(Function.prototype, TO_STRING, function toString() {\x5cn  return typeof this == \x27function\x27 && this[SRC] || $toString.call(this);\x5cn});\x5cn\x22,\x22// Works with __proto__ only. Old v8 can\x27t work with null proto objects.\x5cn/* eslint-disable no-proto */\x5cnvar isObject = require(\x27./_is-object\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar check = function (O, proto) {\x5cn  anObject(O);\x5cn  if (!isObject(proto) && proto !== null) throw TypeError(proto + \x5c\x22: can\x27t set as prototype!\x5c\x22);\x5cn};\x5cnmodule.exports = {\x5cn  set: Object.setPrototypeOf || (\x27__proto__\x27 in {} ? // eslint-disable-line\x5cn    function (test, buggy, set) {\x5cn      try {\x5cn        set = require(\x27./_ctx\x27)(Function.call, require(\x27./_object-gopd\x27).f(Object.prototype, \x27__proto__\x27).set, 2);\x5cn        set(test, []);\x5cn        buggy = !(test instanceof Array);\x5cn      } catch (e) { buggy = true; }\x5cn      return function setPrototypeOf(O, proto) {\x5cn        check(O, proto);\x5cn        if (buggy) O.__proto__ = proto;\x5cn        else set(O, proto);\x5cn        return O;\x5cn      };\x5cn    }({}, false) : undefined),\x5cn  check: check\x5cn};\x5cn\x22,\x22\x27use strict\x27;\x5cnvar global = require(\x27./_global\x27);\x5cnvar dP = require(\x27./_object-dp\x27);\x5cnvar DESCRIPTORS = require(\x27./_descriptors\x27);\x5cnvar SPECIES = require(\x27./_wks\x27)(\x27species\x27);\x5cn\x5cnmodule.exports = function (KEY) {\x5cn  var C = global[KEY];\x5cn  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\x5cn    configurable: true,\x5cn    get: function () { return this; }\x5cn  });\x5cn};\x5cn\x22,\x22var def = require(\x27./_object-dp\x27).f;\x5cnvar has = require(\x27./_has\x27);\x5cnvar TAG = require(\x27./_wks\x27)(\x27toStringTag\x27);\x5cn\x5cnmodule.exports = function (it, tag, stat) {\x5cn  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\x5cn};\x5cn\x22,\x22var shared = require(\x27./_shared\x27)(\x27keys\x27);\x5cnvar uid = require(\x27./_uid\x27);\x5cnmodule.exports = function (key) {\x5cn  return shared[key] || (shared[key] = uid(key));\x5cn};\x5cn\x22,\x22var core = require(\x27./_core\x27);\x5cnvar global = require(\x27./_global\x27);\x5cnvar SHARED = \x27__core-js_shared__\x27;\x5cnvar store = global[SHARED] || (global[SHARED] = {});\x5cn\x5cn(module.exports = function (key, value) {\x5cn  return store[key] || (store[key] = value !== undefined ? value : {});\x5cn})(\x27versions\x27, []).push({\x5cn  version: core.version,\x5cn  mode: require(\x27./_library\x27) ? \x27pure\x27 : \x27global\x27,\x5cn  copyright: \x27\xc2\xa9 2018 Denis Pushkarev (zloirock.ru)\x27\x5cn});\x5cn\x22,\x22var toInteger = require(\x27./_to-integer\x27);\x5cnvar max = Math.max;\x5cnvar min = Math.min;\x5cnmodule.exports = function (index, length) {\x5cn  index = toInteger(index);\x5cn  return index \x3c 0 ? max(index + length, 0) : min(index, length);\x5cn};\x5cn\x22,\x22// 7.1.4 ToInteger\x5cnvar ceil = Math.ceil;\x5cnvar floor = Math.floor;\x5cnmodule.exports = function (it) {\x5cn  return isNaN(it = +it) ? 0 : (it \x3e 0 ? floor : ceil)(it);\x5cn};\x5cn\x22,\x22// to indexed object, toObject with fallback for non-array-like ES3 strings\x5cnvar IObject = require(\x27./_iobject\x27);\x5cnvar defined = require(\x27./_defined\x27);\x5cnmodule.exports = function (it) {\x5cn  return IObject(defined(it));\x5cn};\x5cn\x22,\x22// 7.1.15 ToLength\x5cnvar toInteger = require(\x27./_to-integer\x27);\x5cnvar min = Math.min;\x5cnmodule.exports = function (it) {\x5cn  return it \x3e 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\x5cn};\x5cn\x22,\x22// 7.1.13 ToObject(argument)\x5cnvar defined = require(\x27./_defined\x27);\x5cnmodule.exports = function (it) {\x5cn  return Object(defined(it));\x5cn};\x5cn\x22,\x22// 7.1.1 ToPrimitive(input [, PreferredType])\x5cnvar isObject = require(\x27./_is-object\x27);\x5cn// instead of the ES6 spec version, we didn\x27t implement @@toPrimitive case\x5cn// and the second argument - flag - preferred type is a string\x5cnmodule.exports = function (it, S) {\x5cn  if (!isObject(it)) return it;\x5cn  var fn, val;\x5cn  if (S && typeof (fn = it.toString) == \x27function\x27 && !isObject(val = fn.call(it))) return val;\x5cn  if (typeof (fn = it.valueOf) == \x27function\x27 && !isObject(val = fn.call(it))) return val;\x5cn  if (!S && typeof (fn = it.toString) == \x27function\x27 && !isObject(val = fn.call(it))) return val;\x5cn  throw TypeError(\x5c\x22Can\x27t convert object to primitive value\x5c\x22);\x5cn};\x5cn\x22,\x22var id = 0;\x5cnvar px = Math.random();\x5cnmodule.exports = function (key) {\x5cn  return \x27Symbol(\x27.concat(key === undefined ? \x27\x27 : key, \x27)_\x27, (++id + px).toString(36));\x5cn};\x5cn\x22,\x22var isObject = require(\x27./_is-object\x27);\x5cnmodule.exports = function (it, TYPE) {\x5cn  if (!isObject(it) || it._t !== TYPE) throw TypeError(\x27Incompatible receiver, \x27 + TYPE + \x27 required!\x27);\x5cn  return it;\x5cn};\x5cn\x22,\x22var store = require(\x27./_shared\x27)(\x27wks\x27);\x5cnvar uid = require(\x27./_uid\x27);\x5cnvar Symbol = require(\x27./_global\x27).Symbol;\x5cnvar USE_SYMBOL = typeof Symbol == \x27function\x27;\x5cn\x5cnvar $exports = module.exports = function (name) {\x5cn  return store[name] || (store[name] =\x5cn    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)(\x27Symbol.\x27 + name));\x5cn};\x5cn\x5cn$exports.store = store;\x5cn\x22,\x22var classof = require(\x27./_classof\x27);\x5cnvar ITERATOR = require(\x27./_wks\x27)(\x27iterator\x27);\x5cnvar Iterators = require(\x27./_iterators\x27);\x5cnmodule.exports = require(\x27./_core\x27).getIteratorMethod = function (it) {\x5cn  if (it != undefined) return it[ITERATOR]\x5cn    || it[\x27@@iterator\x27]\x5cn    || Iterators[classof(it)];\x5cn};\x5cn\x22,\x22\x27use strict\x27;\x5cnvar strong = require(\x27./_collection-strong\x27);\x5cnvar validate = require(\x27./_validate-collection\x27);\x5cnvar MAP = \x27Map\x27;\x5cn\x5cn// 23.1 Map Objects\x5cnmodule.exports = require(\x27./_collection\x27)(MAP, function (get) {\x5cn  return function Map() { return get(this, arguments.length \x3e 0 ? arguments[0] : undefined); };\x5cn}, {\x5cn  // 23.1.3.6 Map.prototype.get(key)\x5cn  get: function get(key) {\x5cn    var entry = strong.getEntry(validate(this, MAP), key);\x5cn    return entry && entry.v;\x5cn  },\x5cn  // 23.1.3.9 Map.prototype.set(key, value)\x5cn  set: function set(key, value) {\x5cn    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);\x5cn  }\x5cn}, strong, true);\x5cn\x22,\x22\x27use strict\x27;\x5cnvar strong = require(\x27./_collection-strong\x27);\x5cnvar validate = require(\x27./_validate-collection\x27);\x5cnvar SET = \x27Set\x27;\x5cn\x5cn// 23.2 Set Objects\x5cnmodule.exports = require(\x27./_collection\x27)(SET, function (get) {\x5cn  return function Set() { return get(this, arguments.length \x3e 0 ? arguments[0] : undefined); };\x5cn}, {\x5cn  // 23.2.3.1 Set.prototype.add(value)\x5cn  add: function add(value) {\x5cn    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);\x5cn  }\x5cn}, strong);\x5cn\x22,\x22\x27use strict\x27;\x5cnvar each = require(\x27./_array-methods\x27)(0);\x5cnvar redefine = require(\x27./_redefine\x27);\x5cnvar meta = require(\x27./_meta\x27);\x5cnvar assign = require(\x27./_object-assign\x27);\x5cnvar weak = require(\x27./_collection-weak\x27);\x5cnvar isObject = require(\x27./_is-object\x27);\x5cnvar fails = require(\x27./_fails\x27);\x5cnvar validate = require(\x27./_validate-collection\x27);\x5cnvar WEAK_MAP = \x27WeakMap\x27;\x5cnvar getWeak = meta.getWeak;\x5cnvar isExtensible = Object.isExtensible;\x5cnvar uncaughtFrozenStore = weak.ufstore;\x5cnvar tmp = {};\x5cnvar InternalMap;\x5cn\x5cnvar wrapper = function (get) {\x5cn  return function WeakMap() {\x5cn    return get(this, arguments.length \x3e 0 ? arguments[0] : undefined);\x5cn  };\x5cn};\x5cn\x5cnvar methods = {\x5cn  // 23.3.3.3 WeakMap.prototype.get(key)\x5cn  get: function get(key) {\x5cn    if (isObject(key)) {\x5cn      var data = getWeak(key);\x5cn      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\x5cn      return data ? data[this._i] : undefined;\x5cn    }\x5cn  },\x5cn  // 23.3.3.5 WeakMap.prototype.set(key, value)\x5cn  set: function set(key, value) {\x5cn    return weak.def(validate(this, WEAK_MAP), key, value);\x5cn  }\x5cn};\x5cn\x5cn// 23.3 WeakMap Objects\x5cnvar $WeakMap = module.exports = require(\x27./_collection\x27)(WEAK_MAP, wrapper, methods, weak, true, true);\x5cn\x5cn// IE11 WeakMap frozen keys fix\x5cnif (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {\x5cn  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\x5cn  assign(InternalMap.prototype, methods);\x5cn  meta.NEED = true;\x5cn  each([\x27delete\x27, \x27has\x27, \x27get\x27, \x27set\x27], function (key) {\x5cn    var proto = $WeakMap.prototype;\x5cn    var method = proto[key];\x5cn    redefine(proto, key, function (a, b) {\x5cn      // store frozen objects on internal weakmap shim\x5cn      if (isObject(a) && !isExtensible(a)) {\x5cn        if (!this._f) this._f = new InternalMap();\x5cn        var result = this._f[key](a, b);\x5cn        return key == \x27set\x27 ? this : result;\x5cn      // store all the rest on native weakmap\x5cn      } return method.call(this, a, b);\x5cn    });\x5cn  });\x5cn}\x5cn\x22,\x22var metadata = require(\x27./_metadata\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar toMetaKey = metadata.key;\x5cnvar ordinaryDefineOwnMetadata = metadata.set;\x5cn\x5cnmetadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {\x5cn  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));\x5cn} });\x5cn\x22,\x22var metadata = require(\x27./_metadata\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar toMetaKey = metadata.key;\x5cnvar getOrCreateMetadataMap = metadata.map;\x5cnvar store = metadata.store;\x5cn\x5cnmetadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {\x5cn  var targetKey = arguments.length \x3c 3 ? undefined : toMetaKey(arguments[2]);\x5cn  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);\x5cn  if (metadataMap === undefined || !metadataMap[\x27delete\x27](metadataKey)) return false;\x5cn  if (metadataMap.size) return true;\x5cn  var targetMetadata = store.get(target);\x5cn  targetMetadata[\x27delete\x27](targetKey);\x5cn  return !!targetMetadata.size || store[\x27delete\x27](target);\x5cn} });\x5cn\x22,\x22var Set = require(\x27./es6.set\x27);\x5cnvar from = require(\x27./_array-from-iterable\x27);\x5cnvar metadata = require(\x27./_metadata\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar getPrototypeOf = require(\x27./_object-gpo\x27);\x5cnvar ordinaryOwnMetadataKeys = metadata.keys;\x5cnvar toMetaKey = metadata.key;\x5cn\x5cnvar ordinaryMetadataKeys = function (O, P) {\x5cn  var oKeys = ordinaryOwnMetadataKeys(O, P);\x5cn  var parent = getPrototypeOf(O);\x5cn  if (parent === null) return oKeys;\x5cn  var pKeys = ordinaryMetadataKeys(parent, P);\x5cn  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;\x5cn};\x5cn\x5cnmetadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {\x5cn  return ordinaryMetadataKeys(anObject(target), arguments.length \x3c 2 ? undefined : toMetaKey(arguments[1]));\x5cn} });\x5cn\x22,\x22var metadata = require(\x27./_metadata\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar getPrototypeOf = require(\x27./_object-gpo\x27);\x5cnvar ordinaryHasOwnMetadata = metadata.has;\x5cnvar ordinaryGetOwnMetadata = metadata.get;\x5cnvar toMetaKey = metadata.key;\x5cn\x5cnvar ordinaryGetMetadata = function (MetadataKey, O, P) {\x5cn  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\x5cn  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);\x5cn  var parent = getPrototypeOf(O);\x5cn  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;\x5cn};\x5cn\x5cnmetadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {\x5cn  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length \x3c 3 ? undefined : toMetaKey(arguments[2]));\x5cn} });\x5cn\x22,\x22var metadata = require(\x27./_metadata\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar ordinaryOwnMetadataKeys = metadata.keys;\x5cnvar toMetaKey = metadata.key;\x5cn\x5cnmetadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {\x5cn  return ordinaryOwnMetadataKeys(anObject(target), arguments.length \x3c 2 ? undefined : toMetaKey(arguments[1]));\x5cn} });\x5cn\x22,\x22var metadata = require(\x27./_metadata\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar ordinaryGetOwnMetadata = metadata.get;\x5cnvar toMetaKey = metadata.key;\x5cn\x5cnmetadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {\x5cn  return ordinaryGetOwnMetadata(metadataKey, anObject(target)\x5cn    , arguments.length \x3c 3 ? undefined : toMetaKey(arguments[2]));\x5cn} });\x5cn\x22,\x22var metadata = require(\x27./_metadata\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar getPrototypeOf = require(\x27./_object-gpo\x27);\x5cnvar ordinaryHasOwnMetadata = metadata.has;\x5cnvar toMetaKey = metadata.key;\x5cn\x5cnvar ordinaryHasMetadata = function (MetadataKey, O, P) {\x5cn  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\x5cn  if (hasOwn) return true;\x5cn  var parent = getPrototypeOf(O);\x5cn  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;\x5cn};\x5cn\x5cnmetadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {\x5cn  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length \x3c 3 ? undefined : toMetaKey(arguments[2]));\x5cn} });\x5cn\x22,\x22var metadata = require(\x27./_metadata\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar ordinaryHasOwnMetadata = metadata.has;\x5cnvar toMetaKey = metadata.key;\x5cn\x5cnmetadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {\x5cn  return ordinaryHasOwnMetadata(metadataKey, anObject(target)\x5cn    , arguments.length \x3c 3 ? undefined : toMetaKey(arguments[2]));\x5cn} });\x5cn\x22,\x22var $metadata = require(\x27./_metadata\x27);\x5cnvar anObject = require(\x27./_an-object\x27);\x5cnvar aFunction = require(\x27./_a-function\x27);\x5cnvar toMetaKey = $metadata.key;\x5cnvar ordinaryDefineOwnMetadata = $metadata.set;\x5cn\x5cn$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {\x5cn  return function decorator(target, targetKey) {\x5cn    ordinaryDefineOwnMetadata(\x5cn      metadataKey, metadataValue,\x5cn      (targetKey !== undefined ? anObject : aFunction)(target),\x5cn      toMetaKey(targetKey)\x5cn    );\x5cn  };\x5cn} });\x5cn\x22,\x22/**\x5cn* @license\x5cn* Copyright Google Inc. All Rights Reserved.\x5cn*\x5cn* Use of this source code is governed by an MIT-style license that can be\x5cn* found in the LICENSE file at https://angular.io/license\x5cn*/\x5cn(function (global, factory) {\x5cn\x5cttypeof exports === \x27object\x27 && typeof module !== \x27undefined\x27 ? factory() :\x5cn\x5cttypeof define === \x27function\x27 && define.amd ? define(factory) :\x5cn\x5ct(factory());\x5cn}(this, (function () { \x27use strict\x27;\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cnvar Zone$1 = (function (global) {\x5cn    var FUNCTION = \x27function\x27;\x5cn    var performance = global[\x27performance\x27];\x5cn    function mark(name) {\x5cn        performance && performance[\x27mark\x27] && performance[\x27mark\x27](name);\x5cn    }\x5cn    function performanceMeasure(name, label) {\x5cn        performance && performance[\x27measure\x27] && performance[\x27measure\x27](name, label);\x5cn    }\x5cn    mark(\x27Zone\x27);\x5cn    if (global[\x27Zone\x27]) {\x5cn        throw new Error(\x27Zone already loaded.\x27);\x5cn    }\x5cn    var Zone = /** @class */ (function () {\x5cn        function Zone(parent, zoneSpec) {\x5cn            this._properties = null;\x5cn            this._parent = parent;\x5cn            this._name = zoneSpec ? zoneSpec.name || \x27unnamed\x27 : \x27\x3croot\x3e\x27;\x5cn            this._properties = zoneSpec && zoneSpec.properties || {};\x5cn            this._zoneDelegate =\x5cn                new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\x5cn        }\x5cn        Zone.assertZonePatched = function () {\x5cn            if (global[\x27Promise\x27] !== patches[\x27ZoneAwarePromise\x27]) {\x5cn                throw new Error(\x27Zone.js has detected that ZoneAwarePromise `(window|global).Promise` \x27 +\x5cn                    \x27has been overwritten.\x5c\x5cn\x27 +\x5cn                    \x27Most likely cause is that a Promise polyfill has been loaded \x27 +\x5cn                    \x27after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. \x27 +\x5cn                    \x27If you must load one, do so before loading zone.js.)\x27);\x5cn            }\x5cn        };\x5cn        Object.defineProperty(Zone, \x5c\x22root\x5c\x22, {\x5cn            get: function () {\x5cn                var zone = Zone.current;\x5cn                while (zone.parent) {\x5cn                    zone = zone.parent;\x5cn                }\x5cn                return zone;\x5cn            },\x5cn            enumerable: true,\x5cn            configurable: true\x5cn        });\x5cn        Object.defineProperty(Zone, \x5c\x22current\x5c\x22, {\x5cn            get: function () {\x5cn                return _currentZoneFrame.zone;\x5cn            },\x5cn            enumerable: true,\x5cn            configurable: true\x5cn        });\x5cn        Object.defineProperty(Zone, \x5c\x22currentTask\x5c\x22, {\x5cn            get: function () {\x5cn                return _currentTask;\x5cn            },\x5cn            enumerable: true,\x5cn            configurable: true\x5cn        });\x5cn        Zone.__load_patch = function (name, fn) {\x5cn            if (patches.hasOwnProperty(name)) {\x5cn                throw Error(\x27Already loaded patch: \x27 + name);\x5cn            }\x5cn            else if (!global[\x27__Zone_disable_\x27 + name]) {\x5cn                var perfName = \x27Zone:\x27 + name;\x5cn                mark(perfName);\x5cn                patches[name] = fn(global, Zone, _api);\x5cn                performanceMeasure(perfName, perfName);\x5cn            }\x5cn        };\x5cn        Object.defineProperty(Zone.prototype, \x5c\x22parent\x5c\x22, {\x5cn            get: function () {\x5cn                return this._parent;\x5cn            },\x5cn            enumerable: true,\x5cn            configurable: true\x5cn        });\x5cn        Object.defineProperty(Zone.prototype, \x5c\x22name\x5c\x22, {\x5cn            get: function () {\x5cn                return this._name;\x5cn            },\x5cn            enumerable: true,\x5cn            configurable: true\x5cn        });\x5cn        Zone.prototype.get = function (key) {\x5cn            var zone = this.getZoneWith(key);\x5cn            if (zone)\x5cn                return zone._properties[key];\x5cn        };\x5cn        Zone.prototype.getZoneWith = function (key) {\x5cn            var current = this;\x5cn            while (current) {\x5cn                if (current._properties.hasOwnProperty(key)) {\x5cn                    return current;\x5cn                }\x5cn                current = current._parent;\x5cn            }\x5cn            return null;\x5cn        };\x5cn        Zone.prototype.fork = function (zoneSpec) {\x5cn            if (!zoneSpec)\x5cn                throw new Error(\x27ZoneSpec required!\x27);\x5cn            return this._zoneDelegate.fork(this, zoneSpec);\x5cn        };\x5cn        Zone.prototype.wrap = function (callback, source) {\x5cn            if (typeof callback !== FUNCTION) {\x5cn                throw new Error(\x27Expecting function got: \x27 + callback);\x5cn            }\x5cn            var _callback = this._zoneDelegate.intercept(this, callback, source);\x5cn            var zone = this;\x5cn            return function () {\x5cn                return zone.runGuarded(_callback, this, arguments, source);\x5cn            };\x5cn        };\x5cn        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {\x5cn            if (applyThis === void 0) { applyThis = undefined; }\x5cn            if (applyArgs === void 0) { applyArgs = null; }\x5cn            if (source === void 0) { source = null; }\x5cn            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\x5cn            try {\x5cn                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\x5cn            }\x5cn            finally {\x5cn                _currentZoneFrame = _currentZoneFrame.parent;\x5cn            }\x5cn        };\x5cn        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {\x5cn            if (applyThis === void 0) { applyThis = null; }\x5cn            if (applyArgs === void 0) { applyArgs = null; }\x5cn            if (source === void 0) { source = null; }\x5cn            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\x5cn            try {\x5cn                try {\x5cn                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\x5cn                }\x5cn                catch (error) {\x5cn                    if (this._zoneDelegate.handleError(this, error)) {\x5cn                        throw error;\x5cn                    }\x5cn                }\x5cn            }\x5cn            finally {\x5cn                _currentZoneFrame = _currentZoneFrame.parent;\x5cn            }\x5cn        };\x5cn        Zone.prototype.runTask = function (task, applyThis, applyArgs) {\x5cn            if (task.zone != this) {\x5cn                throw new Error(\x27A task can only be run in the zone of creation! (Creation: \x27 +\x5cn                    (task.zone || NO_ZONE).name + \x27; Execution: \x27 + this.name + \x27)\x27);\x5cn            }\x5cn            // https://github.com/angular/zone.js/issues/778, sometimes eventTask\x5cn            // will run in notScheduled(canceled) state, we should not try to\x5cn            // run such kind of task but just return\x5cn            // we have to define an variable here, if not\x5cn            // typescript compiler will complain below\x5cn            var isNotScheduled = task.state === notScheduled;\x5cn            if (isNotScheduled && task.type === eventTask) {\x5cn                return;\x5cn            }\x5cn            var reEntryGuard = task.state != running;\x5cn            reEntryGuard && task._transitionTo(running, scheduled);\x5cn            task.runCount++;\x5cn            var previousTask = _currentTask;\x5cn            _currentTask = task;\x5cn            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\x5cn            try {\x5cn                if (task.type == macroTask && task.data && !task.data.isPeriodic) {\x5cn                    task.cancelFn = null;\x5cn                }\x5cn                try {\x5cn                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\x5cn                }\x5cn                catch (error) {\x5cn                    if (this._zoneDelegate.handleError(this, error)) {\x5cn                        throw error;\x5cn                    }\x5cn                }\x5cn            }\x5cn            finally {\x5cn                // if the task\x27s state is notScheduled or unknown, then it has already been cancelled\x5cn                // we should not reset the state to scheduled\x5cn                if (task.state !== notScheduled && task.state !== unknown) {\x5cn                    if (task.type == eventTask || (task.data && task.data.isPeriodic)) {\x5cn                        reEntryGuard && task._transitionTo(scheduled, running);\x5cn                    }\x5cn                    else {\x5cn                        task.runCount = 0;\x5cn                        this._updateTaskCount(task, -1);\x5cn                        reEntryGuard &&\x5cn                            task._transitionTo(notScheduled, running, notScheduled);\x5cn                    }\x5cn                }\x5cn                _currentZoneFrame = _currentZoneFrame.parent;\x5cn                _currentTask = previousTask;\x5cn            }\x5cn        };\x5cn        Zone.prototype.scheduleTask = function (task) {\x5cn            if (task.zone && task.zone !== this) {\x5cn                // check if the task was rescheduled, the newZone\x5cn                // should not be the children of the original zone\x5cn                var newZone = this;\x5cn                while (newZone) {\x5cn                    if (newZone === task.zone) {\x5cn                        throw Error(\x5c\x22can not reschedule task to \x5c\x22 + this\x5cn                            .name + \x5c\x22 which is descendants of the original zone \x5c\x22 + task.zone.name);\x5cn                    }\x5cn                    newZone = newZone.parent;\x5cn                }\x5cn            }\x5cn            task._transitionTo(scheduling, notScheduled);\x5cn            var zoneDelegates = [];\x5cn            task._zoneDelegates = zoneDelegates;\x5cn            task._zone = this;\x5cn            try {\x5cn                task = this._zoneDelegate.scheduleTask(this, task);\x5cn            }\x5cn            catch (err) {\x5cn                // should set task\x27s state to unknown when scheduleTask throw error\x5cn                // because the err may from reschedule, so the fromState maybe notScheduled\x5cn                task._transitionTo(unknown, scheduling, notScheduled);\x5cn                // TODO: @JiaLiPassion, should we check the result from handleError?\x5cn                this._zoneDelegate.handleError(this, err);\x5cn                throw err;\x5cn            }\x5cn            if (task._zoneDelegates === zoneDelegates) {\x5cn                // we have to check because internally the delegate can reschedule the task.\x5cn                this._updateTaskCount(task, 1);\x5cn            }\x5cn            if (task.state == scheduling) {\x5cn                task._transitionTo(scheduled, scheduling);\x5cn            }\x5cn            return task;\x5cn        };\x5cn        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {\x5cn            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, null));\x5cn        };\x5cn        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {\x5cn            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\x5cn        };\x5cn        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {\x5cn            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\x5cn        };\x5cn        Zone.prototype.cancelTask = function (task) {\x5cn            if (task.zone != this)\x5cn                throw new Error(\x27A task can only be cancelled in the zone of creation! (Creation: \x27 +\x5cn                    (task.zone || NO_ZONE).name + \x27; Execution: \x27 + this.name + \x27)\x27);\x5cn            task._transitionTo(canceling, scheduled, running);\x5cn            try {\x5cn                this._zoneDelegate.cancelTask(this, task);\x5cn            }\x5cn            catch (err) {\x5cn                // if error occurs when cancelTask, transit the state to unknown\x5cn                task._transitionTo(unknown, canceling);\x5cn                this._zoneDelegate.handleError(this, err);\x5cn                throw err;\x5cn            }\x5cn            this._updateTaskCount(task, -1);\x5cn            task._transitionTo(notScheduled, canceling);\x5cn            task.runCount = 0;\x5cn            return task;\x5cn        };\x5cn        Zone.prototype._updateTaskCount = function (task, count) {\x5cn            var zoneDelegates = task._zoneDelegates;\x5cn            if (count == -1) {\x5cn                task._zoneDelegates = null;\x5cn            }\x5cn            for (var i = 0; i \x3c zoneDelegates.length; i++) {\x5cn                zoneDelegates[i]._updateTaskCount(task.type, count);\x5cn            }\x5cn        };\x5cn        Zone.__symbol__ = __symbol__;\x5cn        return Zone;\x5cn    }());\x5cn    var DELEGATE_ZS = {\x5cn        name: \x27\x27,\x5cn        onHasTask: function (delegate, _, target, hasTaskState) {\x5cn            return delegate.hasTask(target, hasTaskState);\x5cn        },\x5cn        onScheduleTask: function (delegate, _, target, task) {\x5cn            return delegate.scheduleTask(target, task);\x5cn        },\x5cn        onInvokeTask: function (delegate, _, target, task, applyThis, applyArgs) { return delegate.invokeTask(target, task, applyThis, applyArgs); },\x5cn        onCancelTask: function (delegate, _, target, task) {\x5cn            return delegate.cancelTask(target, task);\x5cn        }\x5cn    };\x5cn    var ZoneDelegate = /** @class */ (function () {\x5cn        function ZoneDelegate(zone, parentDelegate, zoneSpec) {\x5cn            this._taskCounts = { \x27microTask\x27: 0, \x27macroTask\x27: 0, \x27eventTask\x27: 0 };\x5cn            this.zone = zone;\x5cn            this._parentDelegate = parentDelegate;\x5cn            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\x5cn            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\x5cn            this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate.zone);\x5cn            this._interceptZS =\x5cn                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\x5cn            this._interceptDlgt =\x5cn                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\x5cn            this._interceptCurrZone =\x5cn                zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);\x5cn            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\x5cn            this._invokeDlgt =\x5cn                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\x5cn            this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);\x5cn            this._handleErrorZS =\x5cn                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\x5cn            this._handleErrorDlgt =\x5cn                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\x5cn            this._handleErrorCurrZone =\x5cn                zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);\x5cn            this._scheduleTaskZS =\x5cn                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\x5cn            this._scheduleTaskDlgt =\x5cn                zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\x5cn            this._scheduleTaskCurrZone =\x5cn                zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);\x5cn            this._invokeTaskZS =\x5cn                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\x5cn            this._invokeTaskDlgt =\x5cn                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\x5cn            this._invokeTaskCurrZone =\x5cn                zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);\x5cn            this._cancelTaskZS =\x5cn                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\x5cn            this._cancelTaskDlgt =\x5cn                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\x5cn            this._cancelTaskCurrZone =\x5cn                zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);\x5cn            this._hasTaskZS = null;\x5cn            this._hasTaskDlgt = null;\x5cn            this._hasTaskDlgtOwner = null;\x5cn            this._hasTaskCurrZone = null;\x5cn            var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\x5cn            var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\x5cn            if (zoneSpecHasTask || parentHasTask) {\x5cn                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such\x5cn                // a case all task related interceptors must go through this ZD. We can\x27t short circuit it.\x5cn                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\x5cn                this._hasTaskDlgt = parentDelegate;\x5cn                this._hasTaskDlgtOwner = this;\x5cn                this._hasTaskCurrZone = zone;\x5cn                if (!zoneSpec.onScheduleTask) {\x5cn                    this._scheduleTaskZS = DELEGATE_ZS;\x5cn                    this._scheduleTaskDlgt = parentDelegate;\x5cn                    this._scheduleTaskCurrZone = this.zone;\x5cn                }\x5cn                if (!zoneSpec.onInvokeTask) {\x5cn                    this._invokeTaskZS = DELEGATE_ZS;\x5cn                    this._invokeTaskDlgt = parentDelegate;\x5cn                    this._invokeTaskCurrZone = this.zone;\x5cn                }\x5cn                if (!zoneSpec.onCancelTask) {\x5cn                    this._cancelTaskZS = DELEGATE_ZS;\x5cn                    this._cancelTaskDlgt = parentDelegate;\x5cn                    this._cancelTaskCurrZone = this.zone;\x5cn                }\x5cn            }\x5cn        }\x5cn        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {\x5cn            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :\x5cn                new Zone(targetZone, zoneSpec);\x5cn        };\x5cn        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {\x5cn            return this._interceptZS ?\x5cn                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :\x5cn                callback;\x5cn        };\x5cn        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {\x5cn            return this._invokeZS ?\x5cn                this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :\x5cn                callback.apply(applyThis, applyArgs);\x5cn        };\x5cn        ZoneDelegate.prototype.handleError = function (targetZone, error) {\x5cn            return this._handleErrorZS ?\x5cn                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :\x5cn                true;\x5cn        };\x5cn        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {\x5cn            var returnTask = task;\x5cn            if (this._scheduleTaskZS) {\x5cn                if (this._hasTaskZS) {\x5cn                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\x5cn                }\x5cn                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\x5cn                if (!returnTask)\x5cn                    returnTask = task;\x5cn            }\x5cn            else {\x5cn                if (task.scheduleFn) {\x5cn                    task.scheduleFn(task);\x5cn                }\x5cn                else if (task.type == microTask) {\x5cn                    scheduleMicroTask(task);\x5cn                }\x5cn                else {\x5cn                    throw new Error(\x27Task is missing scheduleFn.\x27);\x5cn                }\x5cn            }\x5cn            return returnTask;\x5cn        };\x5cn        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {\x5cn            return this._invokeTaskZS ?\x5cn                this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :\x5cn                task.callback.apply(applyThis, applyArgs);\x5cn        };\x5cn        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {\x5cn            var value;\x5cn            if (this._cancelTaskZS) {\x5cn                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\x5cn            }\x5cn            else {\x5cn                if (!task.cancelFn) {\x5cn                    throw Error(\x27Task is not cancelable\x27);\x5cn                }\x5cn                value = task.cancelFn(task);\x5cn            }\x5cn            return value;\x5cn        };\x5cn        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {\x5cn            // hasTask should not throw error so other ZoneDelegate\x5cn            // can still trigger hasTask callback\x5cn            try {\x5cn                return this._hasTaskZS &&\x5cn                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\x5cn            }\x5cn            catch (err) {\x5cn                this.handleError(targetZone, err);\x5cn            }\x5cn        };\x5cn        ZoneDelegate.prototype._updateTaskCount = function (type, count) {\x5cn            var counts = this._taskCounts;\x5cn            var prev = counts[type];\x5cn            var next = counts[type] = prev + count;\x5cn            if (next \x3c 0) {\x5cn                throw new Error(\x27More tasks executed then were scheduled.\x27);\x5cn            }\x5cn            if (prev == 0 || next == 0) {\x5cn                var isEmpty = {\x5cn                    microTask: counts[\x27microTask\x27] \x3e 0,\x5cn                    macroTask: counts[\x27macroTask\x27] \x3e 0,\x5cn                    eventTask: counts[\x27eventTask\x27] \x3e 0,\x5cn                    change: type\x5cn                };\x5cn                this.hasTask(this.zone, isEmpty);\x5cn            }\x5cn        };\x5cn        return ZoneDelegate;\x5cn    }());\x5cn    var ZoneTask = /** @class */ (function () {\x5cn        function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {\x5cn            this._zone = null;\x5cn            this.runCount = 0;\x5cn            this._zoneDelegates = null;\x5cn            this._state = \x27notScheduled\x27;\x5cn            this.type = type;\x5cn            this.source = source;\x5cn            this.data = options;\x5cn            this.scheduleFn = scheduleFn;\x5cn            this.cancelFn = cancelFn;\x5cn            this.callback = callback;\x5cn            var self = this;\x5cn            // TODO: @JiaLiPassion options should have interface\x5cn            if (type === eventTask && options && options.useG) {\x5cn                this.invoke = ZoneTask.invokeTask;\x5cn            }\x5cn            else {\x5cn                this.invoke = function () {\x5cn                    return ZoneTask.invokeTask.call(global, self, this, arguments);\x5cn                };\x5cn            }\x5cn        }\x5cn        ZoneTask.invokeTask = function (task, target, args) {\x5cn            if (!task) {\x5cn                task = this;\x5cn            }\x5cn            _numberOfNestedTaskFrames++;\x5cn            try {\x5cn                task.runCount++;\x5cn                return task.zone.runTask(task, target, args);\x5cn            }\x5cn            finally {\x5cn                if (_numberOfNestedTaskFrames == 1) {\x5cn                    drainMicroTaskQueue();\x5cn                }\x5cn                _numberOfNestedTaskFrames--;\x5cn            }\x5cn        };\x5cn        Object.defineProperty(ZoneTask.prototype, \x5c\x22zone\x5c\x22, {\x5cn            get: function () {\x5cn                return this._zone;\x5cn            },\x5cn            enumerable: true,\x5cn            configurable: true\x5cn        });\x5cn        Object.defineProperty(ZoneTask.prototype, \x5c\x22state\x5c\x22, {\x5cn            get: function () {\x5cn                return this._state;\x5cn            },\x5cn            enumerable: true,\x5cn            configurable: true\x5cn        });\x5cn        ZoneTask.prototype.cancelScheduleRequest = function () {\x5cn            this._transitionTo(notScheduled, scheduling);\x5cn        };\x5cn        ZoneTask.prototype._transitionTo = function (toState, fromState1, fromState2) {\x5cn            if (this._state === fromState1 || this._state === fromState2) {\x5cn                this._state = toState;\x5cn                if (toState == notScheduled) {\x5cn                    this._zoneDelegates = null;\x5cn                }\x5cn            }\x5cn            else {\x5cn                throw new Error(this.type + \x5c\x22 \x27\x5c\x22 + this.source + \x5c\x22\x27: can not transition to \x27\x5c\x22 + toState + \x5c\x22\x27, expecting state \x27\x5c\x22 + fromState1 + \x5c\x22\x27\x5c\x22 + (fromState2 ?\x5cn                    \x27 or \x5c\x5c\x27\x27 + fromState2 + \x27\x5c\x5c\x27\x27 :\x5cn                    \x27\x27) + \x5c\x22, was \x27\x5c\x22 + this._state + \x5c\x22\x27.\x5c\x22);\x5cn            }\x5cn        };\x5cn        ZoneTask.prototype.toString = function () {\x5cn            if (this.data && typeof this.data.handleId !== \x27undefined\x27) {\x5cn                return this.data.handleId;\x5cn            }\x5cn            else {\x5cn                return Object.prototype.toString.call(this);\x5cn            }\x5cn        };\x5cn        // add toJSON method to prevent cyclic error when\x5cn        // call JSON.stringify(zoneTask)\x5cn        ZoneTask.prototype.toJSON = function () {\x5cn            return {\x5cn                type: this.type,\x5cn                state: this.state,\x5cn                source: this.source,\x5cn                zone: this.zone.name,\x5cn                runCount: this.runCount\x5cn            };\x5cn        };\x5cn        return ZoneTask;\x5cn    }());\x5cn    //////////////////////////////////////////////////////\x5cn    //////////////////////////////////////////////////////\x5cn    ///  MICROTASK QUEUE\x5cn    //////////////////////////////////////////////////////\x5cn    //////////////////////////////////////////////////////\x5cn    var symbolSetTimeout = __symbol__(\x27setTimeout\x27);\x5cn    var symbolPromise = __symbol__(\x27Promise\x27);\x5cn    var symbolThen = __symbol__(\x27then\x27);\x5cn    var _microTaskQueue = [];\x5cn    var _isDrainingMicrotaskQueue = false;\x5cn    var nativeMicroTaskQueuePromise;\x5cn    function scheduleMicroTask(task) {\x5cn        // if we are not running in any task, and there has not been anything scheduled\x5cn        // we must bootstrap the initial task creation by manually scheduling the drain\x5cn        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\x5cn            // We are not running in Task, so we need to kickstart the microtask queue.\x5cn            if (!nativeMicroTaskQueuePromise) {\x5cn                if (global[symbolPromise]) {\x5cn                    nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);\x5cn                }\x5cn            }\x5cn            if (nativeMicroTaskQueuePromise) {\x5cn                nativeMicroTaskQueuePromise[symbolThen](drainMicroTaskQueue);\x5cn            }\x5cn            else {\x5cn                global[symbolSetTimeout](drainMicroTaskQueue, 0);\x5cn            }\x5cn        }\x5cn        task && _microTaskQueue.push(task);\x5cn    }\x5cn    function drainMicroTaskQueue() {\x5cn        if (!_isDrainingMicrotaskQueue) {\x5cn            _isDrainingMicrotaskQueue = true;\x5cn            while (_microTaskQueue.length) {\x5cn                var queue = _microTaskQueue;\x5cn                _microTaskQueue = [];\x5cn                for (var i = 0; i \x3c queue.length; i++) {\x5cn                    var task = queue[i];\x5cn                    try {\x5cn                        task.zone.runTask(task, null, null);\x5cn                    }\x5cn                    catch (error) {\x5cn                        _api.onUnhandledError(error);\x5cn                    }\x5cn                }\x5cn            }\x5cn            _api.microtaskDrainDone();\x5cn            _isDrainingMicrotaskQueue = false;\x5cn        }\x5cn    }\x5cn    //////////////////////////////////////////////////////\x5cn    //////////////////////////////////////////////////////\x5cn    ///  BOOTSTRAP\x5cn    //////////////////////////////////////////////////////\x5cn    //////////////////////////////////////////////////////\x5cn    var NO_ZONE = { name: \x27NO ZONE\x27 };\x5cn    var notScheduled = \x27notScheduled\x27, scheduling = \x27scheduling\x27, scheduled = \x27scheduled\x27, running = \x27running\x27, canceling = \x27canceling\x27, unknown = \x27unknown\x27;\x5cn    var microTask = \x27microTask\x27, macroTask = \x27macroTask\x27, eventTask = \x27eventTask\x27;\x5cn    var patches = {};\x5cn    var _api = {\x5cn        symbol: __symbol__,\x5cn        currentZoneFrame: function () { return _currentZoneFrame; },\x5cn        onUnhandledError: noop,\x5cn        microtaskDrainDone: noop,\x5cn        scheduleMicroTask: scheduleMicroTask,\x5cn        showUncaughtError: function () { return !Zone[__symbol__(\x27ignoreConsoleErrorUncaughtError\x27)]; },\x5cn        patchEventTarget: function () { return []; },\x5cn        patchOnProperties: noop,\x5cn        patchMethod: function () { return noop; },\x5cn        bindArguments: function () { return null; },\x5cn        setNativePromise: function (NativePromise) {\x5cn            // sometimes NativePromise.resolve static function\x5cn            // is not ready yet, (such as core-js/es6.promise)\x5cn            // so we need to check here.\x5cn            if (NativePromise && typeof NativePromise.resolve === FUNCTION) {\x5cn                nativeMicroTaskQueuePromise = NativePromise.resolve(0);\x5cn            }\x5cn        },\x5cn    };\x5cn    var _currentZoneFrame = { parent: null, zone: new Zone(null, null) };\x5cn    var _currentTask = null;\x5cn    var _numberOfNestedTaskFrames = 0;\x5cn    function noop() { }\x5cn    function __symbol__(name) {\x5cn        return \x27__zone_symbol__\x27 + name;\x5cn    }\x5cn    performanceMeasure(\x27Zone\x27, \x27Zone\x27);\x5cn    return global[\x27Zone\x27] = Zone;\x5cn})(typeof window !== \x27undefined\x27 && window || typeof self !== \x27undefined\x27 && self || global);\x5cn\x5cnZone.__load_patch(\x27ZoneAwarePromise\x27, function (global, Zone, api) {\x5cn    var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\x5cn    var ObjectDefineProperty = Object.defineProperty;\x5cn    function readableObjectToString(obj) {\x5cn        if (obj && obj.toString === Object.prototype.toString) {\x5cn            var className = obj.constructor && obj.constructor.name;\x5cn            return (className ? className : \x27\x27) + \x27: \x27 + JSON.stringify(obj);\x5cn        }\x5cn        return obj ? obj.toString() : Object.prototype.toString.call(obj);\x5cn    }\x5cn    var __symbol__ = api.symbol;\x5cn    var _uncaughtPromiseErrors = [];\x5cn    var symbolPromise = __symbol__(\x27Promise\x27);\x5cn    var symbolThen = __symbol__(\x27then\x27);\x5cn    var creationTrace = \x27__creationTrace__\x27;\x5cn    api.onUnhandledError = function (e) {\x5cn        if (api.showUncaughtError()) {\x5cn            var rejection = e && e.rejection;\x5cn            if (rejection) {\x5cn                console.error(\x27Unhandled Promise rejection:\x27, rejection instanceof Error ? rejection.message : rejection, \x27; Zone:\x27, e.zone.name, \x27; Task:\x27, e.task && e.task.source, \x27; Value:\x27, rejection, rejection instanceof Error ? rejection.stack : undefined);\x5cn            }\x5cn            else {\x5cn                console.error(e);\x5cn            }\x5cn        }\x5cn    };\x5cn    api.microtaskDrainDone = function () {\x5cn        while (_uncaughtPromiseErrors.length) {\x5cn            var _loop_1 = function () {\x5cn                var uncaughtPromiseError = _uncaughtPromiseErrors.shift();\x5cn                try {\x5cn                    uncaughtPromiseError.zone.runGuarded(function () {\x5cn                        throw uncaughtPromiseError;\x5cn                    });\x5cn                }\x5cn                catch (error) {\x5cn                    handleUnhandledRejection(error);\x5cn                }\x5cn            };\x5cn            while (_uncaughtPromiseErrors.length) {\x5cn                _loop_1();\x5cn            }\x5cn        }\x5cn    };\x5cn    var UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__(\x27unhandledPromiseRejectionHandler\x27);\x5cn    function handleUnhandledRejection(e) {\x5cn        api.onUnhandledError(e);\x5cn        try {\x5cn            var handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];\x5cn            if (handler && typeof handler === \x27function\x27) {\x5cn                handler.call(this, e);\x5cn            }\x5cn        }\x5cn        catch (err) {\x5cn        }\x5cn    }\x5cn    function isThenable(value) {\x5cn        return value && value.then;\x5cn    }\x5cn    function forwardResolution(value) {\x5cn        return value;\x5cn    }\x5cn    function forwardRejection(rejection) {\x5cn        return ZoneAwarePromise.reject(rejection);\x5cn    }\x5cn    var symbolState = __symbol__(\x27state\x27);\x5cn    var symbolValue = __symbol__(\x27value\x27);\x5cn    var symbolFinally = __symbol__(\x27finally\x27);\x5cn    var symbolParentPromiseValue = __symbol__(\x27parentPromiseValue\x27);\x5cn    var symbolParentPromiseState = __symbol__(\x27parentPromiseState\x27);\x5cn    var source = \x27Promise.then\x27;\x5cn    var UNRESOLVED = null;\x5cn    var RESOLVED = true;\x5cn    var REJECTED = false;\x5cn    var REJECTED_NO_CATCH = 0;\x5cn    function makeResolver(promise, state) {\x5cn        return function (v) {\x5cn            try {\x5cn                resolvePromise(promise, state, v);\x5cn            }\x5cn            catch (err) {\x5cn                resolvePromise(promise, false, err);\x5cn            }\x5cn            // Do not return value or you will break the Promise spec.\x5cn        };\x5cn    }\x5cn    var once = function () {\x5cn        var wasCalled = false;\x5cn        return function wrapper(wrappedFunction) {\x5cn            return function () {\x5cn                if (wasCalled) {\x5cn                    return;\x5cn                }\x5cn                wasCalled = true;\x5cn                wrappedFunction.apply(null, arguments);\x5cn            };\x5cn        };\x5cn    };\x5cn    var TYPE_ERROR = \x27Promise resolved with itself\x27;\x5cn    var CURRENT_TASK_TRACE_SYMBOL = __symbol__(\x27currentTaskTrace\x27);\x5cn    // Promise Resolution\x5cn    function resolvePromise(promise, state, value) {\x5cn        var onceWrapper = once();\x5cn        if (promise === value) {\x5cn            throw new TypeError(TYPE_ERROR);\x5cn        }\x5cn        if (promise[symbolState] === UNRESOLVED) {\x5cn            // should only get value.then once based on promise spec.\x5cn            var then = null;\x5cn            try {\x5cn                if (typeof value === \x27object\x27 || typeof value === \x27function\x27) {\x5cn                    then = value && value.then;\x5cn                }\x5cn            }\x5cn            catch (err) {\x5cn                onceWrapper(function () {\x5cn                    resolvePromise(promise, false, err);\x5cn                })();\x5cn                return promise;\x5cn            }\x5cn            // if (value instanceof ZoneAwarePromise) {\x5cn            if (state !== REJECTED && value instanceof ZoneAwarePromise &&\x5cn                value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) &&\x5cn                value[symbolState] !== UNRESOLVED) {\x5cn                clearRejectedNoCatch(value);\x5cn                resolvePromise(promise, value[symbolState], value[symbolValue]);\x5cn            }\x5cn            else if (state !== REJECTED && typeof then === \x27function\x27) {\x5cn                try {\x5cn                    then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));\x5cn                }\x5cn                catch (err) {\x5cn                    onceWrapper(function () {\x5cn                        resolvePromise(promise, false, err);\x5cn                    })();\x5cn                }\x5cn            }\x5cn            else {\x5cn                promise[symbolState] = state;\x5cn                var queue = promise[symbolValue];\x5cn                promise[symbolValue] = value;\x5cn                if (promise[symbolFinally] === symbolFinally) {\x5cn                    // the promise is generated by Promise.prototype.finally          \x5cn                    if (state === RESOLVED) {\x5cn                        // the state is resolved, should ignore the value\x5cn                        // and use parent promise value\x5cn                        promise[symbolState] = promise[symbolParentPromiseState];\x5cn                        promise[symbolValue] = promise[symbolParentPromiseValue];\x5cn                    }\x5cn                }\x5cn                // record task information in value when error occurs, so we can\x5cn                // do some additional work such as render longStackTrace\x5cn                if (state === REJECTED && value instanceof Error) {\x5cn                    // check if longStackTraceZone is here\x5cn                    var trace = Zone.currentTask && Zone.currentTask.data &&\x5cn                        Zone.currentTask.data[creationTrace];\x5cn                    if (trace) {\x5cn                        // only keep the long stack trace into error when in longStackTraceZone\x5cn                        ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, { configurable: true, enumerable: false, writable: true, value: trace });\x5cn                    }\x5cn                }\x5cn                for (var i = 0; i \x3c queue.length;) {\x5cn                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\x5cn                }\x5cn                if (queue.length == 0 && state == REJECTED) {\x5cn                    promise[symbolState] = REJECTED_NO_CATCH;\x5cn                    try {\x5cn                        // try to print more readable error log\x5cn                        throw new Error(\x27Uncaught (in promise): \x27 + readableObjectToString(value) +\x5cn                            (value && value.stack ? \x27\x5c\x5cn\x27 + value.stack : \x27\x27));\x5cn                    }\x5cn                    catch (err) {\x5cn                        var error_1 = err;\x5cn                        error_1.rejection = value;\x5cn                        error_1.promise = promise;\x5cn                        error_1.zone = Zone.current;\x5cn                        error_1.task = Zone.currentTask;\x5cn                        _uncaughtPromiseErrors.push(error_1);\x5cn                        api.scheduleMicroTask(); // to make sure that it is running\x5cn                    }\x5cn                }\x5cn            }\x5cn        }\x5cn        // Resolving an already resolved promise is a noop.\x5cn        return promise;\x5cn    }\x5cn    var REJECTION_HANDLED_HANDLER = __symbol__(\x27rejectionHandledHandler\x27);\x5cn    function clearRejectedNoCatch(promise) {\x5cn        if (promise[symbolState] === REJECTED_NO_CATCH) {\x5cn            // if the promise is rejected no catch status\x5cn            // and queue.length \x3e 0, means there is a error handler\x5cn            // here to handle the rejected promise, we should trigger\x5cn            // windows.rejectionhandled eventHandler or nodejs rejectionHandled\x5cn            // eventHandler\x5cn            try {\x5cn                var handler = Zone[REJECTION_HANDLED_HANDLER];\x5cn                if (handler && typeof handler === \x27function\x27) {\x5cn                    handler.call(this, { rejection: promise[symbolValue], promise: promise });\x5cn                }\x5cn            }\x5cn            catch (err) {\x5cn            }\x5cn            promise[symbolState] = REJECTED;\x5cn            for (var i = 0; i \x3c _uncaughtPromiseErrors.length; i++) {\x5cn                if (promise === _uncaughtPromiseErrors[i].promise) {\x5cn                    _uncaughtPromiseErrors.splice(i, 1);\x5cn                }\x5cn            }\x5cn        }\x5cn    }\x5cn    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\x5cn        clearRejectedNoCatch(promise);\x5cn        var promiseState = promise[symbolState];\x5cn        var delegate = promiseState ?\x5cn            (typeof onFulfilled === \x27function\x27) ? onFulfilled : forwardResolution :\x5cn            (typeof onRejected === \x27function\x27) ? onRejected : forwardRejection;\x5cn        zone.scheduleMicroTask(source, function () {\x5cn            try {\x5cn                var parentPromiseValue = promise[symbolValue];\x5cn                var isFinallyPromise = chainPromise && symbolFinally === chainPromise[symbolFinally];\x5cn                if (isFinallyPromise) {\x5cn                    // if the promise is generated from finally call, keep parent promise\x27s state and value\x5cn                    chainPromise[symbolParentPromiseValue] = parentPromiseValue;\x5cn                    chainPromise[symbolParentPromiseState] = promiseState;\x5cn                }\x5cn                // should not pass value to finally callback\x5cn                var value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);\x5cn                resolvePromise(chainPromise, true, value);\x5cn            }\x5cn            catch (error) {\x5cn                // if error occurs, should always return this error\x5cn                resolvePromise(chainPromise, false, error);\x5cn            }\x5cn        }, chainPromise);\x5cn    }\x5cn    var ZONE_AWARE_PROMISE_TO_STRING = \x27function ZoneAwarePromise() { [native code] }\x27;\x5cn    var ZoneAwarePromise = /** @class */ (function () {\x5cn        function ZoneAwarePromise(executor) {\x5cn            var promise = this;\x5cn            if (!(promise instanceof ZoneAwarePromise)) {\x5cn                throw new Error(\x27Must be an instanceof Promise.\x27);\x5cn            }\x5cn            promise[symbolState] = UNRESOLVED;\x5cn            promise[symbolValue] = []; // queue;\x5cn            try {\x5cn                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\x5cn            }\x5cn            catch (error) {\x5cn                resolvePromise(promise, false, error);\x5cn            }\x5cn        }\x5cn        ZoneAwarePromise.toString = function () {\x5cn            return ZONE_AWARE_PROMISE_TO_STRING;\x5cn        };\x5cn        ZoneAwarePromise.resolve = function (value) {\x5cn            return resolvePromise(new this(null), RESOLVED, value);\x5cn        };\x5cn        ZoneAwarePromise.reject = function (error) {\x5cn            return resolvePromise(new this(null), REJECTED, error);\x5cn        };\x5cn        ZoneAwarePromise.race = function (values) {\x5cn            var resolve;\x5cn            var reject;\x5cn            var promise = new this(function (res, rej) {\x5cn                resolve = res;\x5cn                reject = rej;\x5cn            });\x5cn            function onResolve(value) {\x5cn                promise && (promise = null || resolve(value));\x5cn            }\x5cn            function onReject(error) {\x5cn                promise && (promise = null || reject(error));\x5cn            }\x5cn            for (var _i = 0, values_1 = values; _i \x3c values_1.length; _i++) {\x5cn                var value = values_1[_i];\x5cn                if (!isThenable(value)) {\x5cn                    value = this.resolve(value);\x5cn                }\x5cn                value.then(onResolve, onReject);\x5cn            }\x5cn            return promise;\x5cn        };\x5cn        ZoneAwarePromise.all = function (values) {\x5cn            var resolve;\x5cn            var reject;\x5cn            var promise = new this(function (res, rej) {\x5cn                resolve = res;\x5cn                reject = rej;\x5cn            });\x5cn            var count = 0;\x5cn            var resolvedValues = [];\x5cn            for (var _i = 0, values_2 = values; _i \x3c values_2.length; _i++) {\x5cn                var value = values_2[_i];\x5cn                if (!isThenable(value)) {\x5cn                    value = this.resolve(value);\x5cn                }\x5cn                value.then((function (index) { return function (value) {\x5cn                    resolvedValues[index] = value;\x5cn                    count--;\x5cn                    if (!count) {\x5cn                        resolve(resolvedValues);\x5cn                    }\x5cn                }; })(count), reject);\x5cn                count++;\x5cn            }\x5cn            if (!count)\x5cn                resolve(resolvedValues);\x5cn            return promise;\x5cn        };\x5cn        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {\x5cn            var chainPromise = new this.constructor(null);\x5cn            var zone = Zone.current;\x5cn            if (this[symbolState] == UNRESOLVED) {\x5cn                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\x5cn            }\x5cn            else {\x5cn                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\x5cn            }\x5cn            return chainPromise;\x5cn        };\x5cn        ZoneAwarePromise.prototype.catch = function (onRejected) {\x5cn            return this.then(null, onRejected);\x5cn        };\x5cn        ZoneAwarePromise.prototype.finally = function (onFinally) {\x5cn            var chainPromise = new this.constructor(null);\x5cn            chainPromise[symbolFinally] = symbolFinally;\x5cn            var zone = Zone.current;\x5cn            if (this[symbolState] == UNRESOLVED) {\x5cn                this[symbolValue].push(zone, chainPromise, onFinally, onFinally);\x5cn            }\x5cn            else {\x5cn                scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);\x5cn            }\x5cn            return chainPromise;\x5cn        };\x5cn        return ZoneAwarePromise;\x5cn    }());\x5cn    // Protect against aggressive optimizers dropping seemingly unused properties.\x5cn    // E.g. Closure Compiler in advanced mode.\x5cn    ZoneAwarePromise[\x27resolve\x27] = ZoneAwarePromise.resolve;\x5cn    ZoneAwarePromise[\x27reject\x27] = ZoneAwarePromise.reject;\x5cn    ZoneAwarePromise[\x27race\x27] = ZoneAwarePromise.race;\x5cn    ZoneAwarePromise[\x27all\x27] = ZoneAwarePromise.all;\x5cn    var NativePromise = global[symbolPromise] = global[\x27Promise\x27];\x5cn    var ZONE_AWARE_PROMISE = Zone.__symbol__(\x27ZoneAwarePromise\x27);\x5cn    var desc = ObjectGetOwnPropertyDescriptor(global, \x27Promise\x27);\x5cn    if (!desc || desc.configurable) {\x5cn        desc && delete desc.writable;\x5cn        desc && delete desc.value;\x5cn        if (!desc) {\x5cn            desc = { configurable: true, enumerable: true };\x5cn        }\x5cn        desc.get = function () {\x5cn            // if we already set ZoneAwarePromise, use patched one\x5cn            // otherwise return native one.\x5cn            return global[ZONE_AWARE_PROMISE] ? global[ZONE_AWARE_PROMISE] : global[symbolPromise];\x5cn        };\x5cn        desc.set = function (NewNativePromise) {\x5cn            if (NewNativePromise === ZoneAwarePromise) {\x5cn                // if the NewNativePromise is ZoneAwarePromise\x5cn                // save to global\x5cn                global[ZONE_AWARE_PROMISE] = NewNativePromise;\x5cn            }\x5cn            else {\x5cn                // if the NewNativePromise is not ZoneAwarePromise\x5cn                // for example: after load zone.js, some library just\x5cn                // set es6-promise to global, if we set it to global\x5cn                // directly, assertZonePatched will fail and angular\x5cn                // will not loaded, so we just set the NewNativePromise\x5cn                // to global[symbolPromise], so the result is just like\x5cn                // we load ES6 Promise before zone.js\x5cn                global[symbolPromise] = NewNativePromise;\x5cn                if (!NewNativePromise.prototype[symbolThen]) {\x5cn                    patchThen(NewNativePromise);\x5cn                }\x5cn                api.setNativePromise(NewNativePromise);\x5cn            }\x5cn        };\x5cn        ObjectDefineProperty(global, \x27Promise\x27, desc);\x5cn    }\x5cn    global[\x27Promise\x27] = ZoneAwarePromise;\x5cn    var symbolThenPatched = __symbol__(\x27thenPatched\x27);\x5cn    function patchThen(Ctor) {\x5cn        var proto = Ctor.prototype;\x5cn        var prop = ObjectGetOwnPropertyDescriptor(proto, \x27then\x27);\x5cn        if (prop && (prop.writable === false || !prop.configurable)) {\x5cn            // check Ctor.prototype.then propertyDescriptor is writable or not\x5cn            // in meteor env, writable is false, we should ignore such case\x5cn            return;\x5cn        }\x5cn        var originalThen = proto.then;\x5cn        // Keep a reference to the original method.\x5cn        proto[symbolThen] = originalThen;\x5cn        Ctor.prototype.then = function (onResolve, onReject) {\x5cn            var _this = this;\x5cn            var wrapped = new ZoneAwarePromise(function (resolve, reject) {\x5cn                originalThen.call(_this, resolve, reject);\x5cn            });\x5cn            return wrapped.then(onResolve, onReject);\x5cn        };\x5cn        Ctor[symbolThenPatched] = true;\x5cn    }\x5cn    function zoneify(fn) {\x5cn        return function () {\x5cn            var resultPromise = fn.apply(this, arguments);\x5cn            if (resultPromise instanceof ZoneAwarePromise) {\x5cn                return resultPromise;\x5cn            }\x5cn            var ctor = resultPromise.constructor;\x5cn            if (!ctor[symbolThenPatched]) {\x5cn                patchThen(ctor);\x5cn            }\x5cn            return resultPromise;\x5cn        };\x5cn    }\x5cn    if (NativePromise) {\x5cn        patchThen(NativePromise);\x5cn        var fetch_1 = global[\x27fetch\x27];\x5cn        if (typeof fetch_1 == \x27function\x27) {\x5cn            global[\x27fetch\x27] = zoneify(fetch_1);\x5cn        }\x5cn    }\x5cn    // This is not part of public API, but it is useful for tests, so we expose it.\x5cn    Promise[Zone.__symbol__(\x27uncaughtPromiseErrors\x27)] = _uncaughtPromiseErrors;\x5cn    return ZoneAwarePromise;\x5cn});\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cn/**\x5cn * Suppress closure compiler errors about unknown \x27Zone\x27 variable\x5cn * @fileoverview\x5cn * @suppress {undefinedVars,globalThis,missingRequire}\x5cn */\x5cn// issue #989, to reduce bundle size, use short name\x5cn/** Object.getOwnPropertyDescriptor */\x5cnvar ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\x5cn/** Object.defineProperty */\x5cnvar ObjectDefineProperty = Object.defineProperty;\x5cn/** Object.getPrototypeOf */\x5cnvar ObjectGetPrototypeOf = Object.getPrototypeOf;\x5cn/** Object.create */\x5cnvar ObjectCreate = Object.create;\x5cn/** Array.prototype.slice */\x5cnvar ArraySlice = Array.prototype.slice;\x5cn/** addEventListener string const */\x5cnvar ADD_EVENT_LISTENER_STR = \x27addEventListener\x27;\x5cn/** removeEventListener string const */\x5cnvar REMOVE_EVENT_LISTENER_STR = \x27removeEventListener\x27;\x5cn/** zoneSymbol addEventListener */\x5cnvar ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);\x5cn/** zoneSymbol removeEventListener */\x5cnvar ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);\x5cn/** true string const */\x5cnvar TRUE_STR = \x27true\x27;\x5cn/** false string const */\x5cnvar FALSE_STR = \x27false\x27;\x5cn/** __zone_symbol__ string const */\x5cnvar ZONE_SYMBOL_PREFIX = \x27__zone_symbol__\x27;\x5cnfunction wrapWithCurrentZone(callback, source) {\x5cn    return Zone.current.wrap(callback, source);\x5cn}\x5cnfunction scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {\x5cn    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);\x5cn}\x5cnvar zoneSymbol = Zone.__symbol__;\x5cnvar isWindowExists = typeof window !== \x27undefined\x27;\x5cnvar internalWindow = isWindowExists ? window : undefined;\x5cnvar _global = isWindowExists && internalWindow || typeof self === \x27object\x27 && self || global;\x5cnvar REMOVE_ATTRIBUTE = \x27removeAttribute\x27;\x5cnvar NULL_ON_PROP_VALUE = [null];\x5cnfunction bindArguments(args, source) {\x5cn    for (var i = args.length - 1; i \x3e= 0; i--) {\x5cn        if (typeof args[i] === \x27function\x27) {\x5cn            args[i] = wrapWithCurrentZone(args[i], source + \x27_\x27 + i);\x5cn        }\x5cn    }\x5cn    return args;\x5cn}\x5cnfunction patchPrototype(prototype, fnNames) {\x5cn    var source = prototype.constructor[\x27name\x27];\x5cn    var _loop_1 = function (i) {\x5cn        var name_1 = fnNames[i];\x5cn        var delegate = prototype[name_1];\x5cn        if (delegate) {\x5cn            var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name_1);\x5cn            if (!isPropertyWritable(prototypeDesc)) {\x5cn                return \x5c\x22continue\x5c\x22;\x5cn            }\x5cn            prototype[name_1] = (function (delegate) {\x5cn                var patched = function () {\x5cn                    return delegate.apply(this, bindArguments(arguments, source + \x27.\x27 + name_1));\x5cn                };\x5cn                attachOriginToPatched(patched, delegate);\x5cn                return patched;\x5cn            })(delegate);\x5cn        }\x5cn    };\x5cn    for (var i = 0; i \x3c fnNames.length; i++) {\x5cn        _loop_1(i);\x5cn    }\x5cn}\x5cnfunction isPropertyWritable(propertyDesc) {\x5cn    if (!propertyDesc) {\x5cn        return true;\x5cn    }\x5cn    if (propertyDesc.writable === false) {\x5cn        return false;\x5cn    }\x5cn    return !(typeof propertyDesc.get === \x27function\x27 && typeof propertyDesc.set === \x27undefined\x27);\x5cn}\x5cnvar isWebWorker = (typeof WorkerGlobalScope !== \x27undefined\x27 && self instanceof WorkerGlobalScope);\x5cn// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\x5cn// this code.\x5cnvar isNode = (!(\x27nw\x27 in _global) && typeof _global.process !== \x27undefined\x27 &&\x5cn    {}.toString.call(_global.process) === \x27[object process]\x27);\x5cnvar isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow[\x27HTMLElement\x27]);\x5cn// we are in electron of nw, so we are both browser and nodejs\x5cn// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\x5cn// this code.\x5cnvar isMix = typeof _global.process !== \x27undefined\x27 &&\x5cn    {}.toString.call(_global.process) === \x27[object process]\x27 && !isWebWorker &&\x5cn    !!(isWindowExists && internalWindow[\x27HTMLElement\x27]);\x5cnvar zoneSymbolEventNames = {};\x5cnvar wrapFn = function (event) {\x5cn    // https://github.com/angular/zone.js/issues/911, in IE, sometimes\x5cn    // event will be undefined, so we need to use window.event\x5cn    event = event || _global.event;\x5cn    if (!event) {\x5cn        return;\x5cn    }\x5cn    var eventNameSymbol = zoneSymbolEventNames[event.type];\x5cn    if (!eventNameSymbol) {\x5cn        eventNameSymbol = zoneSymbolEventNames[event.type] = zoneSymbol(\x27ON_PROPERTY\x27 + event.type);\x5cn    }\x5cn    var target = this || event.target || _global;\x5cn    var listener = target[eventNameSymbol];\x5cn    var result = listener && listener.apply(this, arguments);\x5cn    if (result != undefined && !result) {\x5cn        event.preventDefault();\x5cn    }\x5cn    return result;\x5cn};\x5cnfunction patchProperty(obj, prop, prototype) {\x5cn    var desc = ObjectGetOwnPropertyDescriptor(obj, prop);\x5cn    if (!desc && prototype) {\x5cn        // when patch window object, use prototype to check prop exist or not\x5cn        var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);\x5cn        if (prototypeDesc) {\x5cn            desc = { enumerable: true, configurable: true };\x5cn        }\x5cn    }\x5cn    // if the descriptor not exists or is not configurable\x5cn    // just return\x5cn    if (!desc || !desc.configurable) {\x5cn        return;\x5cn    }\x5cn    // A property descriptor cannot have getter/setter and be writable\x5cn    // deleting the writable and value properties avoids this error:\x5cn    //\x5cn    // TypeError: property descriptors must not specify a value or be writable when a\x5cn    // getter or setter has been specified\x5cn    delete desc.writable;\x5cn    delete desc.value;\x5cn    var originalDescGet = desc.get;\x5cn    var originalDescSet = desc.set;\x5cn    // substr(2) cuz \x27onclick\x27 -\x3e \x27click\x27, etc\x5cn    var eventName = prop.substr(2);\x5cn    var eventNameSymbol = zoneSymbolEventNames[eventName];\x5cn    if (!eventNameSymbol) {\x5cn        eventNameSymbol = zoneSymbolEventNames[eventName] = zoneSymbol(\x27ON_PROPERTY\x27 + eventName);\x5cn    }\x5cn    desc.set = function (newValue) {\x5cn        // in some of windows\x27s onproperty callback, this is undefined\x5cn        // so we need to check it\x5cn        var target = this;\x5cn        if (!target && obj === _global) {\x5cn            target = _global;\x5cn        }\x5cn        if (!target) {\x5cn            return;\x5cn        }\x5cn        var previousValue = target[eventNameSymbol];\x5cn        if (previousValue) {\x5cn            target.removeEventListener(eventName, wrapFn);\x5cn        }\x5cn        // issue #978, when onload handler was added before loading zone.js\x5cn        // we should remove it with originalDescSet\x5cn        if (originalDescSet) {\x5cn            originalDescSet.apply(target, NULL_ON_PROP_VALUE);\x5cn        }\x5cn        if (typeof newValue === \x27function\x27) {\x5cn            target[eventNameSymbol] = newValue;\x5cn            target.addEventListener(eventName, wrapFn, false);\x5cn        }\x5cn        else {\x5cn            target[eventNameSymbol] = null;\x5cn        }\x5cn    };\x5cn    // The getter would return undefined for unassigned properties but the default value of an\x5cn    // unassigned property is null\x5cn    desc.get = function () {\x5cn        // in some of windows\x27s onproperty callback, this is undefined\x5cn        // so we need to check it\x5cn        var target = this;\x5cn        if (!target && obj === _global) {\x5cn            target = _global;\x5cn        }\x5cn        if (!target) {\x5cn            return null;\x5cn        }\x5cn        var listener = target[eventNameSymbol];\x5cn        if (listener) {\x5cn            return listener;\x5cn        }\x5cn        else if (originalDescGet) {\x5cn            // result will be null when use inline event attribute,\x5cn            // such as \x3cbutton onclick=\x5c\x22func();\x5c\x22\x3eOK\x3c/button\x3e\x5cn            // because the onclick function is internal raw uncompiled handler\x5cn            // the onclick will be evaluated when first time event was triggered or\x5cn            // the property is accessed, https://github.com/angular/zone.js/issues/525\x5cn            // so we should use original native get to retrieve the handler\x5cn            var value = originalDescGet && originalDescGet.call(this);\x5cn            if (value) {\x5cn                desc.set.call(this, value);\x5cn                if (typeof target[REMOVE_ATTRIBUTE] === \x27function\x27) {\x5cn                    target.removeAttribute(prop);\x5cn                }\x5cn                return value;\x5cn            }\x5cn        }\x5cn        return null;\x5cn    };\x5cn    ObjectDefineProperty(obj, prop, desc);\x5cn}\x5cnfunction patchOnProperties(obj, properties, prototype) {\x5cn    if (properties) {\x5cn        for (var i = 0; i \x3c properties.length; i++) {\x5cn            patchProperty(obj, \x27on\x27 + properties[i], prototype);\x5cn        }\x5cn    }\x5cn    else {\x5cn        var onProperties = [];\x5cn        for (var prop in obj) {\x5cn            if (prop.substr(0, 2) == \x27on\x27) {\x5cn                onProperties.push(prop);\x5cn            }\x5cn        }\x5cn        for (var j = 0; j \x3c onProperties.length; j++) {\x5cn            patchProperty(obj, onProperties[j], prototype);\x5cn        }\x5cn    }\x5cn}\x5cnvar originalInstanceKey = zoneSymbol(\x27originalInstance\x27);\x5cn// wrap some native API on `window`\x5cnfunction patchClass(className) {\x5cn    var OriginalClass = _global[className];\x5cn    if (!OriginalClass)\x5cn        return;\x5cn    // keep original class in global\x5cn    _global[zoneSymbol(className)] = OriginalClass;\x5cn    _global[className] = function () {\x5cn        var a = bindArguments(arguments, className);\x5cn        switch (a.length) {\x5cn            case 0:\x5cn                this[originalInstanceKey] = new OriginalClass();\x5cn                break;\x5cn            case 1:\x5cn                this[originalInstanceKey] = new OriginalClass(a[0]);\x5cn                break;\x5cn            case 2:\x5cn                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\x5cn                break;\x5cn            case 3:\x5cn                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\x5cn                break;\x5cn            case 4:\x5cn                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\x5cn                break;\x5cn            default:\x5cn                throw new Error(\x27Arg list too long.\x27);\x5cn        }\x5cn    };\x5cn    // attach original delegate to patched function\x5cn    attachOriginToPatched(_global[className], OriginalClass);\x5cn    var instance = new OriginalClass(function () { });\x5cn    var prop;\x5cn    for (prop in instance) {\x5cn        // https://bugs.webkit.org/show_bug.cgi?id=44721\x5cn        if (className === \x27XMLHttpRequest\x27 && prop === \x27responseBlob\x27)\x5cn            continue;\x5cn        (function (prop) {\x5cn            if (typeof instance[prop] === \x27function\x27) {\x5cn                _global[className].prototype[prop] = function () {\x5cn                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\x5cn                };\x5cn            }\x5cn            else {\x5cn                ObjectDefineProperty(_global[className].prototype, prop, {\x5cn                    set: function (fn) {\x5cn                        if (typeof fn === \x27function\x27) {\x5cn                            this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + \x27.\x27 + prop);\x5cn                            // keep callback in wrapped function so we can\x5cn                            // use it in Function.prototype.toString to return\x5cn                            // the native one.\x5cn                            attachOriginToPatched(this[originalInstanceKey][prop], fn);\x5cn                        }\x5cn                        else {\x5cn                            this[originalInstanceKey][prop] = fn;\x5cn                        }\x5cn                    },\x5cn                    get: function () {\x5cn                        return this[originalInstanceKey][prop];\x5cn                    }\x5cn                });\x5cn            }\x5cn        }(prop));\x5cn    }\x5cn    for (prop in OriginalClass) {\x5cn        if (prop !== \x27prototype\x27 && OriginalClass.hasOwnProperty(prop)) {\x5cn            _global[className][prop] = OriginalClass[prop];\x5cn        }\x5cn    }\x5cn}\x5cnfunction patchMethod(target, name, patchFn) {\x5cn    var proto = target;\x5cn    while (proto && !proto.hasOwnProperty(name)) {\x5cn        proto = ObjectGetPrototypeOf(proto);\x5cn    }\x5cn    if (!proto && target[name]) {\x5cn        // somehow we did not find it, but we can see it. This happens on IE for Window properties.\x5cn        proto = target;\x5cn    }\x5cn    var delegateName = zoneSymbol(name);\x5cn    var delegate;\x5cn    if (proto && !(delegate = proto[delegateName])) {\x5cn        delegate = proto[delegateName] = proto[name];\x5cn        // check whether proto[name] is writable\x5cn        // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob\x5cn        var desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);\x5cn        if (isPropertyWritable(desc)) {\x5cn            var patchDelegate_1 = patchFn(delegate, delegateName, name);\x5cn            proto[name] = function () {\x5cn                return patchDelegate_1(this, arguments);\x5cn            };\x5cn            attachOriginToPatched(proto[name], delegate);\x5cn        }\x5cn    }\x5cn    return delegate;\x5cn}\x5cn// TODO: @JiaLiPassion, support cancel task later if necessary\x5cnfunction patchMacroTask(obj, funcName, metaCreator) {\x5cn    var setNative = null;\x5cn    function scheduleTask(task) {\x5cn        var data = task.data;\x5cn        data.args[data.cbIdx] = function () {\x5cn            task.invoke.apply(this, arguments);\x5cn        };\x5cn        setNative.apply(data.target, data.args);\x5cn        return task;\x5cn    }\x5cn    setNative = patchMethod(obj, funcName, function (delegate) { return function (self, args) {\x5cn        var meta = metaCreator(self, args);\x5cn        if (meta.cbIdx \x3e= 0 && typeof args[meta.cbIdx] === \x27function\x27) {\x5cn            return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask, null);\x5cn        }\x5cn        else {\x5cn            // cause an error by calling it directly.\x5cn            return delegate.apply(self, args);\x5cn        }\x5cn    }; });\x5cn}\x5cn\x5cnfunction attachOriginToPatched(patched, original) {\x5cn    patched[zoneSymbol(\x27OriginalDelegate\x27)] = original;\x5cn}\x5cnvar isDetectedIEOrEdge = false;\x5cnvar ieOrEdge = false;\x5cnfunction isIEOrEdge() {\x5cn    if (isDetectedIEOrEdge) {\x5cn        return ieOrEdge;\x5cn    }\x5cn    isDetectedIEOrEdge = true;\x5cn    try {\x5cn        var ua = internalWindow.navigator.userAgent;\x5cn        if (ua.indexOf(\x27MSIE \x27) !== -1 || ua.indexOf(\x27Trident/\x27) !== -1 || ua.indexOf(\x27Edge/\x27) !== -1) {\x5cn            ieOrEdge = true;\x5cn        }\x5cn        return ieOrEdge;\x5cn    }\x5cn    catch (error) {\x5cn    }\x5cn}\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cn// override Function.prototype.toString to make zone.js patched function\x5cn// look like native function\x5cnZone.__load_patch(\x27toString\x27, function (global) {\x5cn    // patch Func.prototype.toString to let them look like native\x5cn    var originalFunctionToString = Function.prototype.toString;\x5cn    var ORIGINAL_DELEGATE_SYMBOL = zoneSymbol(\x27OriginalDelegate\x27);\x5cn    var PROMISE_SYMBOL = zoneSymbol(\x27Promise\x27);\x5cn    var ERROR_SYMBOL = zoneSymbol(\x27Error\x27);\x5cn    var newFunctionToString = function toString() {\x5cn        if (typeof this === \x27function\x27) {\x5cn            var originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];\x5cn            if (originalDelegate) {\x5cn                if (typeof originalDelegate === \x27function\x27) {\x5cn                    return originalFunctionToString.apply(this[ORIGINAL_DELEGATE_SYMBOL], arguments);\x5cn                }\x5cn                else {\x5cn                    return Object.prototype.toString.call(originalDelegate);\x5cn                }\x5cn            }\x5cn            if (this === Promise) {\x5cn                var nativePromise = global[PROMISE_SYMBOL];\x5cn                if (nativePromise) {\x5cn                    return originalFunctionToString.apply(nativePromise, arguments);\x5cn                }\x5cn            }\x5cn            if (this === Error) {\x5cn                var nativeError = global[ERROR_SYMBOL];\x5cn                if (nativeError) {\x5cn                    return originalFunctionToString.apply(nativeError, arguments);\x5cn                }\x5cn            }\x5cn        }\x5cn        return originalFunctionToString.apply(this, arguments);\x5cn    };\x5cn    newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;\x5cn    Function.prototype.toString = newFunctionToString;\x5cn    // patch Object.prototype.toString to let them look like native\x5cn    var originalObjectToString = Object.prototype.toString;\x5cn    var PROMISE_OBJECT_TO_STRING = \x27[object Promise]\x27;\x5cn    Object.prototype.toString = function () {\x5cn        if (this instanceof Promise) {\x5cn            return PROMISE_OBJECT_TO_STRING;\x5cn        }\x5cn        return originalObjectToString.apply(this, arguments);\x5cn    };\x5cn});\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cn/**\x5cn * @fileoverview\x5cn * @suppress {missingRequire}\x5cn */\x5cn// an identifier to tell ZoneTask do not create a new invoke closure\x5cnvar OPTIMIZED_ZONE_EVENT_TASK_DATA = {\x5cn    useG: true\x5cn};\x5cnvar zoneSymbolEventNames$1 = {};\x5cnvar globalSources = {};\x5cnvar EVENT_NAME_SYMBOL_REGX = /^__zone_symbol__(\x5c\x5cw+)(true|false)$/;\x5cnvar IMMEDIATE_PROPAGATION_SYMBOL = (\x27__zone_symbol__propagationStopped\x27);\x5cnfunction patchEventTarget(_global, apis, patchOptions) {\x5cn    var ADD_EVENT_LISTENER = (patchOptions && patchOptions.add) || ADD_EVENT_LISTENER_STR;\x5cn    var REMOVE_EVENT_LISTENER = (patchOptions && patchOptions.rm) || REMOVE_EVENT_LISTENER_STR;\x5cn    var LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.listeners) || \x27eventListeners\x27;\x5cn    var REMOVE_ALL_LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.rmAll) || \x27removeAllListeners\x27;\x5cn    var zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);\x5cn    var ADD_EVENT_LISTENER_SOURCE = \x27.\x27 + ADD_EVENT_LISTENER + \x27:\x27;\x5cn    var PREPEND_EVENT_LISTENER = \x27prependListener\x27;\x5cn    var PREPEND_EVENT_LISTENER_SOURCE = \x27.\x27 + PREPEND_EVENT_LISTENER + \x27:\x27;\x5cn    var invokeTask = function (task, target, event) {\x5cn        // for better performance, check isRemoved which is set\x5cn        // by removeEventListener\x5cn        if (task.isRemoved) {\x5cn            return;\x5cn        }\x5cn        var delegate = task.callback;\x5cn        if (typeof delegate === \x27object\x27 && delegate.handleEvent) {\x5cn            // create the bind version of handleEvent when invoke\x5cn            task.callback = function (event) { return delegate.handleEvent(event); };\x5cn            task.originalDelegate = delegate;\x5cn        }\x5cn        // invoke static task.invoke\x5cn        task.invoke(task, target, [event]);\x5cn        var options = task.options;\x5cn        if (options && typeof options === \x27object\x27 && options.once) {\x5cn            // if options.once is true, after invoke once remove listener here\x5cn            // only browser need to do this, nodejs eventEmitter will cal removeListener\x5cn            // inside EventEmitter.once\x5cn            var delegate_1 = task.originalDelegate ? task.originalDelegate : task.callback;\x5cn            target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate_1, options);\x5cn        }\x5cn    };\x5cn    // global shared zoneAwareCallback to handle all event callback with capture = false\x5cn    var globalZoneAwareCallback = function (event) {\x5cn        // https://github.com/angular/zone.js/issues/911, in IE, sometimes\x5cn        // event will be undefined, so we need to use window.event\x5cn        event = event || _global.event;\x5cn        if (!event) {\x5cn            return;\x5cn        }\x5cn        // event.target is needed for Samsung TV and SourceBuffer\x5cn        // || global is needed https://github.com/angular/zone.js/issues/190\x5cn        var target = this || event.target || _global;\x5cn        var tasks = target[zoneSymbolEventNames$1[event.type][FALSE_STR]];\x5cn        if (tasks) {\x5cn            // invoke all tasks which attached to current target with given event.type and capture = false\x5cn            // for performance concern, if task.length === 1, just invoke\x5cn            if (tasks.length === 1) {\x5cn                invokeTask(tasks[0], target, event);\x5cn            }\x5cn            else {\x5cn                // https://github.com/angular/zone.js/issues/836\x5cn                // copy the tasks array before invoke, to avoid\x5cn                // the callback will remove itself or other listener\x5cn                var copyTasks = tasks.slice();\x5cn                for (var i = 0; i \x3c copyTasks.length; i++) {\x5cn                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\x5cn                        break;\x5cn                    }\x5cn                    invokeTask(copyTasks[i], target, event);\x5cn                }\x5cn            }\x5cn        }\x5cn    };\x5cn    // global shared zoneAwareCallback to handle all event callback with capture = true\x5cn    var globalZoneAwareCaptureCallback = function (event) {\x5cn        // https://github.com/angular/zone.js/issues/911, in IE, sometimes\x5cn        // event will be undefined, so we need to use window.event\x5cn        event = event || _global.event;\x5cn        if (!event) {\x5cn            return;\x5cn        }\x5cn        // event.target is needed for Samsung TV and SourceBuffer\x5cn        // || global is needed https://github.com/angular/zone.js/issues/190\x5cn        var target = this || event.target || _global;\x5cn        var tasks = target[zoneSymbolEventNames$1[event.type][TRUE_STR]];\x5cn        if (tasks) {\x5cn            // invoke all tasks which attached to current target with given event.type and capture = false\x5cn            // for performance concern, if task.length === 1, just invoke\x5cn            if (tasks.length === 1) {\x5cn                invokeTask(tasks[0], target, event);\x5cn            }\x5cn            else {\x5cn                // https://github.com/angular/zone.js/issues/836\x5cn                // copy the tasks array before invoke, to avoid\x5cn                // the callback will remove itself or other listener\x5cn                var copyTasks = tasks.slice();\x5cn                for (var i = 0; i \x3c copyTasks.length; i++) {\x5cn                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\x5cn                        break;\x5cn                    }\x5cn                    invokeTask(copyTasks[i], target, event);\x5cn                }\x5cn            }\x5cn        }\x5cn    };\x5cn    function patchEventTargetMethods(obj, patchOptions) {\x5cn        if (!obj) {\x5cn            return false;\x5cn        }\x5cn        var useGlobalCallback = true;\x5cn        if (patchOptions && patchOptions.useG !== undefined) {\x5cn            useGlobalCallback = patchOptions.useG;\x5cn        }\x5cn        var validateHandler = patchOptions && patchOptions.vh;\x5cn        var checkDuplicate = true;\x5cn        if (patchOptions && patchOptions.chkDup !== undefined) {\x5cn            checkDuplicate = patchOptions.chkDup;\x5cn        }\x5cn        var returnTarget = false;\x5cn        if (patchOptions && patchOptions.rt !== undefined) {\x5cn            returnTarget = patchOptions.rt;\x5cn        }\x5cn        var proto = obj;\x5cn        while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {\x5cn            proto = ObjectGetPrototypeOf(proto);\x5cn        }\x5cn        if (!proto && obj[ADD_EVENT_LISTENER]) {\x5cn            // somehow we did not find it, but we can see it. This happens on IE for Window properties.\x5cn            proto = obj;\x5cn        }\x5cn        if (!proto) {\x5cn            return false;\x5cn        }\x5cn        if (proto[zoneSymbolAddEventListener]) {\x5cn            return false;\x5cn        }\x5cn        // a shared global taskData to pass data for scheduleEventTask\x5cn        // so we do not need to create a new object just for pass some data\x5cn        var taskData = {};\x5cn        var nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];\x5cn        var nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] =\x5cn            proto[REMOVE_EVENT_LISTENER];\x5cn        var nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] =\x5cn            proto[LISTENERS_EVENT_LISTENER];\x5cn        var nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] =\x5cn            proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];\x5cn        var nativePrependEventListener;\x5cn        if (patchOptions && patchOptions.prepend) {\x5cn            nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] =\x5cn                proto[patchOptions.prepend];\x5cn        }\x5cn        var customScheduleGlobal = function () {\x5cn            // if there is already a task for the eventName + capture,\x5cn            // just return, because we use the shared globalZoneAwareCallback here.\x5cn            if (taskData.isExisting) {\x5cn                return;\x5cn            }\x5cn            return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);\x5cn        };\x5cn        var customCancelGlobal = function (task) {\x5cn            // if task is not marked as isRemoved, this call is directly\x5cn            // from Zone.prototype.cancelTask, we should remove the task\x5cn            // from tasksList of target first\x5cn            if (!task.isRemoved) {\x5cn                var symbolEventNames = zoneSymbolEventNames$1[task.eventName];\x5cn                var symbolEventName = void 0;\x5cn                if (symbolEventNames) {\x5cn                    symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];\x5cn                }\x5cn                var existingTasks = symbolEventName && task.target[symbolEventName];\x5cn                if (existingTasks) {\x5cn                    for (var i = 0; i \x3c existingTasks.length; i++) {\x5cn                        var existingTask = existingTasks[i];\x5cn                        if (existingTask === task) {\x5cn                            existingTasks.splice(i, 1);\x5cn                            // set isRemoved to data for faster invokeTask check\x5cn                            task.isRemoved = true;\x5cn                            if (existingTasks.length === 0) {\x5cn                                // all tasks for the eventName + capture have gone,\x5cn                                // remove globalZoneAwareCallback and remove the task cache from target\x5cn                                task.allRemoved = true;\x5cn                                task.target[symbolEventName] = null;\x5cn                            }\x5cn                            break;\x5cn                        }\x5cn                    }\x5cn                }\x5cn            }\x5cn            // if all tasks for the eventName + capture have gone,\x5cn            // we will really remove the global event callback,\x5cn            // if not, return\x5cn            if (!task.allRemoved) {\x5cn                return;\x5cn            }\x5cn            return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);\x5cn        };\x5cn        var customScheduleNonGlobal = function (task) {\x5cn            return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\x5cn        };\x5cn        var customSchedulePrepend = function (task) {\x5cn            return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\x5cn        };\x5cn        var customCancelNonGlobal = function (task) {\x5cn            return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);\x5cn        };\x5cn        var customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;\x5cn        var customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;\x5cn        var compareTaskCallbackVsDelegate = function (task, delegate) {\x5cn            var typeOfDelegate = typeof delegate;\x5cn            return (typeOfDelegate === \x27function\x27 && task.callback === delegate) ||\x5cn                (typeOfDelegate === \x27object\x27 && task.originalDelegate === delegate);\x5cn        };\x5cn        var compare = (patchOptions && patchOptions.diff) ? patchOptions.diff : compareTaskCallbackVsDelegate;\x5cn        var blackListedEvents = Zone[Zone.__symbol__(\x27BLACK_LISTED_EVENTS\x27)];\x5cn        var makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget, prepend) {\x5cn            if (returnTarget === void 0) { returnTarget = false; }\x5cn            if (prepend === void 0) { prepend = false; }\x5cn            return function () {\x5cn                var target = this || _global;\x5cn                var delegate = arguments[1];\x5cn                if (!delegate) {\x5cn                    return nativeListener.apply(this, arguments);\x5cn                }\x5cn                // don\x27t create the bind delegate function for handleEvent\x5cn                // case here to improve addEventListener performance\x5cn                // we will create the bind delegate when invoke\x5cn                var isHandleEvent = false;\x5cn                if (typeof delegate !== \x27function\x27) {\x5cn                    if (!delegate.handleEvent) {\x5cn                        return nativeListener.apply(this, arguments);\x5cn                    }\x5cn                    isHandleEvent = true;\x5cn                }\x5cn                if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {\x5cn                    return;\x5cn                }\x5cn                var eventName = arguments[0];\x5cn                var options = arguments[2];\x5cn                if (blackListedEvents) {\x5cn                    // check black list\x5cn                    for (var i = 0; i \x3c blackListedEvents.length; i++) {\x5cn                        if (eventName === blackListedEvents[i]) {\x5cn                            return nativeListener.apply(this, arguments);\x5cn                        }\x5cn                    }\x5cn                }\x5cn                var capture;\x5cn                var once = false;\x5cn                if (options === undefined) {\x5cn                    capture = false;\x5cn                }\x5cn                else if (options === true) {\x5cn                    capture = true;\x5cn                }\x5cn                else if (options === false) {\x5cn                    capture = false;\x5cn                }\x5cn                else {\x5cn                    capture = options ? !!options.capture : false;\x5cn                    once = options ? !!options.once : false;\x5cn                }\x5cn                var zone = Zone.current;\x5cn                var symbolEventNames = zoneSymbolEventNames$1[eventName];\x5cn                var symbolEventName;\x5cn                if (!symbolEventNames) {\x5cn                    // the code is duplicate, but I just want to get some better performance\x5cn                    var falseEventName = eventName + FALSE_STR;\x5cn                    var trueEventName = eventName + TRUE_STR;\x5cn                    var symbol = ZONE_SYMBOL_PREFIX + falseEventName;\x5cn                    var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\x5cn                    zoneSymbolEventNames$1[eventName] = {};\x5cn                    zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;\x5cn                    zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;\x5cn                    symbolEventName = capture ? symbolCapture : symbol;\x5cn                }\x5cn                else {\x5cn                    symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\x5cn                }\x5cn                var existingTasks = target[symbolEventName];\x5cn                var isExisting = false;\x5cn                if (existingTasks) {\x5cn                    // already have task registered\x5cn                    isExisting = true;\x5cn                    if (checkDuplicate) {\x5cn                        for (var i = 0; i \x3c existingTasks.length; i++) {\x5cn                            if (compare(existingTasks[i], delegate)) {\x5cn                                // same callback, same capture, same event name, just return\x5cn                                return;\x5cn                            }\x5cn                        }\x5cn                    }\x5cn                }\x5cn                else {\x5cn                    existingTasks = target[symbolEventName] = [];\x5cn                }\x5cn                var source;\x5cn                var constructorName = target.constructor[\x27name\x27];\x5cn                var targetSource = globalSources[constructorName];\x5cn                if (targetSource) {\x5cn                    source = targetSource[eventName];\x5cn                }\x5cn                if (!source) {\x5cn                    source = constructorName + addSource + eventName;\x5cn                }\x5cn                // do not create a new object as task.data to pass those things\x5cn                // just use the global shared one\x5cn                taskData.options = options;\x5cn                if (once) {\x5cn                    // if addEventListener with once options, we don\x27t pass it to\x5cn                    // native addEventListener, instead we keep the once setting\x5cn                    // and handle ourselves.\x5cn                    taskData.options.once = false;\x5cn                }\x5cn                taskData.target = target;\x5cn                taskData.capture = capture;\x5cn                taskData.eventName = eventName;\x5cn                taskData.isExisting = isExisting;\x5cn                var data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : null;\x5cn                // keep taskData into data to allow onScheduleEventTask to access the task information\x5cn                if (data) {\x5cn                    data.taskData = taskData;\x5cn                }\x5cn                var task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);\x5cn                // should clear taskData.target to avoid memory leak\x5cn                // issue, https://github.com/angular/angular/issues/20442\x5cn                taskData.target = null;\x5cn                // need to clear up taskData because it is a global object\x5cn                if (data) {\x5cn                    data.taskData = null;\x5cn                }\x5cn                // have to save those information to task in case\x5cn                // application may call task.zone.cancelTask() directly\x5cn                if (once) {\x5cn                    options.once = true;\x5cn                }\x5cn                task.options = options;\x5cn                task.target = target;\x5cn                task.capture = capture;\x5cn                task.eventName = eventName;\x5cn                if (isHandleEvent) {\x5cn                    // save original delegate for compare to check duplicate\x5cn                    task.originalDelegate = delegate;\x5cn                }\x5cn                if (!prepend) {\x5cn                    existingTasks.push(task);\x5cn                }\x5cn                else {\x5cn                    existingTasks.unshift(task);\x5cn                }\x5cn                if (returnTarget) {\x5cn                    return target;\x5cn                }\x5cn            };\x5cn        };\x5cn        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);\x5cn        if (nativePrependEventListener) {\x5cn            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);\x5cn        }\x5cn        proto[REMOVE_EVENT_LISTENER] = function () {\x5cn            var target = this || _global;\x5cn            var eventName = arguments[0];\x5cn            var options = arguments[2];\x5cn            var capture;\x5cn            if (options === undefined) {\x5cn                capture = false;\x5cn            }\x5cn            else if (options === true) {\x5cn                capture = true;\x5cn            }\x5cn            else if (options === false) {\x5cn                capture = false;\x5cn            }\x5cn            else {\x5cn                capture = options ? !!options.capture : false;\x5cn            }\x5cn            var delegate = arguments[1];\x5cn            if (!delegate) {\x5cn                return nativeRemoveEventListener.apply(this, arguments);\x5cn            }\x5cn            if (validateHandler &&\x5cn                !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {\x5cn                return;\x5cn            }\x5cn            var symbolEventNames = zoneSymbolEventNames$1[eventName];\x5cn            var symbolEventName;\x5cn            if (symbolEventNames) {\x5cn                symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\x5cn            }\x5cn            var existingTasks = symbolEventName && target[symbolEventName];\x5cn            if (existingTasks) {\x5cn                for (var i = 0; i \x3c existingTasks.length; i++) {\x5cn                    var existingTask = existingTasks[i];\x5cn                    if (compare(existingTask, delegate)) {\x5cn                        existingTasks.splice(i, 1);\x5cn                        // set isRemoved to data for faster invokeTask check\x5cn                        existingTask.isRemoved = true;\x5cn                        if (existingTasks.length === 0) {\x5cn                            // all tasks for the eventName + capture have gone,\x5cn                            // remove globalZoneAwareCallback and remove the task cache from target\x5cn                            existingTask.allRemoved = true;\x5cn                            target[symbolEventName] = null;\x5cn                        }\x5cn                        existingTask.zone.cancelTask(existingTask);\x5cn                        if (returnTarget) {\x5cn                            return target;\x5cn                        }\x5cn                        return;\x5cn                    }\x5cn                }\x5cn            }\x5cn            // issue 930, didn\x27t find the event name or callback\x5cn            // from zone kept existingTasks, the callback maybe\x5cn            // added outside of zone, we need to call native removeEventListener\x5cn            // to try to remove it.\x5cn            return nativeRemoveEventListener.apply(this, arguments);\x5cn        };\x5cn        proto[LISTENERS_EVENT_LISTENER] = function () {\x5cn            var target = this || _global;\x5cn            var eventName = arguments[0];\x5cn            var listeners = [];\x5cn            var tasks = findEventTasks(target, eventName);\x5cn            for (var i = 0; i \x3c tasks.length; i++) {\x5cn                var task = tasks[i];\x5cn                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\x5cn                listeners.push(delegate);\x5cn            }\x5cn            return listeners;\x5cn        };\x5cn        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {\x5cn            var target = this || _global;\x5cn            var eventName = arguments[0];\x5cn            if (!eventName) {\x5cn                var keys = Object.keys(target);\x5cn                for (var i = 0; i \x3c keys.length; i++) {\x5cn                    var prop = keys[i];\x5cn                    var match = EVENT_NAME_SYMBOL_REGX.exec(prop);\x5cn                    var evtName = match && match[1];\x5cn                    // in nodejs EventEmitter, removeListener event is\x5cn                    // used for monitoring the removeListener call,\x5cn                    // so just keep removeListener eventListener until\x5cn                    // all other eventListeners are removed\x5cn                    if (evtName && evtName !== \x27removeListener\x27) {\x5cn                        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);\x5cn                    }\x5cn                }\x5cn                // remove removeListener listener finally\x5cn                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, \x27removeListener\x27);\x5cn            }\x5cn            else {\x5cn                var symbolEventNames = zoneSymbolEventNames$1[eventName];\x5cn                if (symbolEventNames) {\x5cn                    var symbolEventName = symbolEventNames[FALSE_STR];\x5cn                    var symbolCaptureEventName = symbolEventNames[TRUE_STR];\x5cn                    var tasks = target[symbolEventName];\x5cn                    var captureTasks = target[symbolCaptureEventName];\x5cn                    if (tasks) {\x5cn                        var removeTasks = tasks.slice();\x5cn                        for (var i = 0; i \x3c removeTasks.length; i++) {\x5cn                            var task = removeTasks[i];\x5cn                            var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\x5cn                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\x5cn                        }\x5cn                    }\x5cn                    if (captureTasks) {\x5cn                        var removeTasks = captureTasks.slice();\x5cn                        for (var i = 0; i \x3c removeTasks.length; i++) {\x5cn                            var task = removeTasks[i];\x5cn                            var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\x5cn                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\x5cn                        }\x5cn                    }\x5cn                }\x5cn            }\x5cn            if (returnTarget) {\x5cn                return this;\x5cn            }\x5cn        };\x5cn        // for native toString patch\x5cn        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);\x5cn        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);\x5cn        if (nativeRemoveAllListeners) {\x5cn            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);\x5cn        }\x5cn        if (nativeListeners) {\x5cn            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);\x5cn        }\x5cn        return true;\x5cn    }\x5cn    var results = [];\x5cn    for (var i = 0; i \x3c apis.length; i++) {\x5cn        results[i] = patchEventTargetMethods(apis[i], patchOptions);\x5cn    }\x5cn    return results;\x5cn}\x5cnfunction findEventTasks(target, eventName) {\x5cn    var foundTasks = [];\x5cn    for (var prop in target) {\x5cn        var match = EVENT_NAME_SYMBOL_REGX.exec(prop);\x5cn        var evtName = match && match[1];\x5cn        if (evtName && (!eventName || evtName === eventName)) {\x5cn            var tasks = target[prop];\x5cn            if (tasks) {\x5cn                for (var i = 0; i \x3c tasks.length; i++) {\x5cn                    foundTasks.push(tasks[i]);\x5cn                }\x5cn            }\x5cn        }\x5cn    }\x5cn    return foundTasks;\x5cn}\x5cnfunction patchEventPrototype(global, api) {\x5cn    var Event = global[\x27Event\x27];\x5cn    if (Event && Event.prototype) {\x5cn        api.patchMethod(Event.prototype, \x27stopImmediatePropagation\x27, function (delegate) { return function (self, args) {\x5cn            self[IMMEDIATE_PROPAGATION_SYMBOL] = true;\x5cn            // we need to call the native stopImmediatePropagation\x5cn            // in case in some hybrid application, some part of\x5cn            // application will be controlled by zone, some are not\x5cn            delegate && delegate.apply(self, args);\x5cn        }; });\x5cn    }\x5cn}\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cn/**\x5cn * @fileoverview\x5cn * @suppress {missingRequire}\x5cn */\x5cnvar taskSymbol = zoneSymbol(\x27zoneTask\x27);\x5cnfunction patchTimer(window, setName, cancelName, nameSuffix) {\x5cn    var setNative = null;\x5cn    var clearNative = null;\x5cn    setName += nameSuffix;\x5cn    cancelName += nameSuffix;\x5cn    var tasksByHandleId = {};\x5cn    function scheduleTask(task) {\x5cn        var data = task.data;\x5cn        function timer() {\x5cn            try {\x5cn                task.invoke.apply(this, arguments);\x5cn            }\x5cn            finally {\x5cn                // issue-934, task will be cancelled\x5cn                // even it is a periodic task such as\x5cn                // setInterval\x5cn                if (!(task.data && task.data.isPeriodic)) {\x5cn                    if (typeof data.handleId === \x27number\x27) {\x5cn                        // in non-nodejs env, we remove timerId\x5cn                        // from local cache\x5cn                        delete tasksByHandleId[data.handleId];\x5cn                    }\x5cn                    else if (data.handleId) {\x5cn                        // Node returns complex objects as handleIds\x5cn                        // we remove task reference from timer object\x5cn                        data.handleId[taskSymbol] = null;\x5cn                    }\x5cn                }\x5cn            }\x5cn        }\x5cn        data.args[0] = timer;\x5cn        data.handleId = setNative.apply(window, data.args);\x5cn        return task;\x5cn    }\x5cn    function clearTask(task) {\x5cn        return clearNative(task.data.handleId);\x5cn    }\x5cn    setNative =\x5cn        patchMethod(window, setName, function (delegate) { return function (self, args) {\x5cn            if (typeof args[0] === \x27function\x27) {\x5cn                var options = {\x5cn                    handleId: null,\x5cn                    isPeriodic: nameSuffix === \x27Interval\x27,\x5cn                    delay: (nameSuffix === \x27Timeout\x27 || nameSuffix === \x27Interval\x27) ? args[1] || 0 : null,\x5cn                    args: args\x5cn                };\x5cn                var task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);\x5cn                if (!task) {\x5cn                    return task;\x5cn                }\x5cn                // Node.js must additionally support the ref and unref functions.\x5cn                var handle = task.data.handleId;\x5cn                if (typeof handle === \x27number\x27) {\x5cn                    // for non nodejs env, we save handleId: task\x5cn                    // mapping in local cache for clearTimeout\x5cn                    tasksByHandleId[handle] = task;\x5cn                }\x5cn                else if (handle) {\x5cn                    // for nodejs env, we save task\x5cn                    // reference in timerId Object for clearTimeout\x5cn                    handle[taskSymbol] = task;\x5cn                }\x5cn                // check whether handle is null, because some polyfill or browser\x5cn                // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame\x5cn                if (handle && handle.ref && handle.unref && typeof handle.ref === \x27function\x27 &&\x5cn                    typeof handle.unref === \x27function\x27) {\x5cn                    task.ref = handle.ref.bind(handle);\x5cn                    task.unref = handle.unref.bind(handle);\x5cn                }\x5cn                if (typeof handle === \x27number\x27 || handle) {\x5cn                    return handle;\x5cn                }\x5cn                return task;\x5cn            }\x5cn            else {\x5cn                // cause an error by calling it directly.\x5cn                return delegate.apply(window, args);\x5cn            }\x5cn        }; });\x5cn    clearNative =\x5cn        patchMethod(window, cancelName, function (delegate) { return function (self, args) {\x5cn            var id = args[0];\x5cn            var task;\x5cn            if (typeof id === \x27number\x27) {\x5cn                // non nodejs env.\x5cn                task = tasksByHandleId[id];\x5cn            }\x5cn            else {\x5cn                // nodejs env.\x5cn                task = id && id[taskSymbol];\x5cn                // other environments.\x5cn                if (!task) {\x5cn                    task = id;\x5cn                }\x5cn            }\x5cn            if (task && typeof task.type === \x27string\x27) {\x5cn                if (task.state !== \x27notScheduled\x27 &&\x5cn                    (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {\x5cn                    if (typeof id === \x27number\x27) {\x5cn                        delete tasksByHandleId[id];\x5cn                    }\x5cn                    else if (id) {\x5cn                        id[taskSymbol] = null;\x5cn                    }\x5cn                    // Do not cancel already canceled functions\x5cn                    task.zone.cancelTask(task);\x5cn                }\x5cn            }\x5cn            else {\x5cn                // cause an error by calling it directly.\x5cn                delegate.apply(window, args);\x5cn            }\x5cn        }; });\x5cn}\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cn/*\x5cn * This is necessary for Chrome and Chrome mobile, to enable\x5cn * things like redefining `createdCallback` on an element.\x5cn */\x5cnvar _defineProperty = Object[zoneSymbol(\x27defineProperty\x27)] = Object.defineProperty;\x5cnvar _getOwnPropertyDescriptor = Object[zoneSymbol(\x27getOwnPropertyDescriptor\x27)] =\x5cn    Object.getOwnPropertyDescriptor;\x5cnvar _create = Object.create;\x5cnvar unconfigurablesKey = zoneSymbol(\x27unconfigurables\x27);\x5cnfunction propertyPatch() {\x5cn    Object.defineProperty = function (obj, prop, desc) {\x5cn        if (isUnconfigurable(obj, prop)) {\x5cn            throw new TypeError(\x27Cannot assign to read only property \x5c\x5c\x27\x27 + prop + \x27\x5c\x5c\x27 of \x27 + obj);\x5cn        }\x5cn        var originalConfigurableFlag = desc.configurable;\x5cn        if (prop !== \x27prototype\x27) {\x5cn            desc = rewriteDescriptor(obj, prop, desc);\x5cn        }\x5cn        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\x5cn    };\x5cn    Object.defineProperties = function (obj, props) {\x5cn        Object.keys(props).forEach(function (prop) {\x5cn            Object.defineProperty(obj, prop, props[prop]);\x5cn        });\x5cn        return obj;\x5cn    };\x5cn    Object.create = function (obj, proto) {\x5cn        if (typeof proto === \x27object\x27 && !Object.isFrozen(proto)) {\x5cn            Object.keys(proto).forEach(function (prop) {\x5cn                proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);\x5cn            });\x5cn        }\x5cn        return _create(obj, proto);\x5cn    };\x5cn    Object.getOwnPropertyDescriptor = function (obj, prop) {\x5cn        var desc = _getOwnPropertyDescriptor(obj, prop);\x5cn        if (isUnconfigurable(obj, prop)) {\x5cn            desc.configurable = false;\x5cn        }\x5cn        return desc;\x5cn    };\x5cn}\x5cnfunction _redefineProperty(obj, prop, desc) {\x5cn    var originalConfigurableFlag = desc.configurable;\x5cn    desc = rewriteDescriptor(obj, prop, desc);\x5cn    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\x5cn}\x5cnfunction isUnconfigurable(obj, prop) {\x5cn    return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];\x5cn}\x5cnfunction rewriteDescriptor(obj, prop, desc) {\x5cn    // issue-927, if the desc is frozen, don\x27t try to change the desc\x5cn    if (!Object.isFrozen(desc)) {\x5cn        desc.configurable = true;\x5cn    }\x5cn    if (!desc.configurable) {\x5cn        // issue-927, if the obj is frozen, don\x27t try to set the desc to obj\x5cn        if (!obj[unconfigurablesKey] && !Object.isFrozen(obj)) {\x5cn            _defineProperty(obj, unconfigurablesKey, { writable: true, value: {} });\x5cn        }\x5cn        if (obj[unconfigurablesKey]) {\x5cn            obj[unconfigurablesKey][prop] = true;\x5cn        }\x5cn    }\x5cn    return desc;\x5cn}\x5cnfunction _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {\x5cn    try {\x5cn        return _defineProperty(obj, prop, desc);\x5cn    }\x5cn    catch (error) {\x5cn        if (desc.configurable) {\x5cn            // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let\x27s\x5cn            // retry with the original flag value\x5cn            if (typeof originalConfigurableFlag == \x27undefined\x27) {\x5cn                delete desc.configurable;\x5cn            }\x5cn            else {\x5cn                desc.configurable = originalConfigurableFlag;\x5cn            }\x5cn            try {\x5cn                return _defineProperty(obj, prop, desc);\x5cn            }\x5cn            catch (error) {\x5cn                var descJson = null;\x5cn                try {\x5cn                    descJson = JSON.stringify(desc);\x5cn                }\x5cn                catch (error) {\x5cn                    descJson = desc.toString();\x5cn                }\x5cn                console.log(\x5c\x22Attempting to configure \x27\x5c\x22 + prop + \x5c\x22\x27 with descriptor \x27\x5c\x22 + descJson + \x5c\x22\x27 on object \x27\x5c\x22 + obj + \x5c\x22\x27 and got error, giving up: \x5c\x22 + error);\x5cn            }\x5cn        }\x5cn        else {\x5cn            throw error;\x5cn        }\x5cn    }\x5cn}\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cn// we have to patch the instance since the proto is non-configurable\x5cnfunction apply(api, _global) {\x5cn    var WS = _global.WebSocket;\x5cn    // On Safari window.EventTarget doesn\x27t exist so need to patch WS add/removeEventListener\x5cn    // On older Chrome, no need since EventTarget was already patched\x5cn    if (!_global.EventTarget) {\x5cn        patchEventTarget(_global, [WS.prototype]);\x5cn    }\x5cn    _global.WebSocket = function (x, y) {\x5cn        var socket = arguments.length \x3e 1 ? new WS(x, y) : new WS(x);\x5cn        var proxySocket;\x5cn        var proxySocketProto;\x5cn        // Safari 7.0 has non-configurable own \x27onmessage\x27 and friends properties on the socket instance\x5cn        var onmessageDesc = ObjectGetOwnPropertyDescriptor(socket, \x27onmessage\x27);\x5cn        if (onmessageDesc && onmessageDesc.configurable === false) {\x5cn            proxySocket = ObjectCreate(socket);\x5cn            // socket have own property descriptor \x27onopen\x27, \x27onmessage\x27, \x27onclose\x27, \x27onerror\x27\x5cn            // but proxySocket not, so we will keep socket as prototype and pass it to\x5cn            // patchOnProperties method\x5cn            proxySocketProto = socket;\x5cn            [ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, \x27send\x27, \x27close\x27].forEach(function (propName) {\x5cn                proxySocket[propName] = function () {\x5cn                    var args = ArraySlice.call(arguments);\x5cn                    if (propName === ADD_EVENT_LISTENER_STR || propName === REMOVE_EVENT_LISTENER_STR) {\x5cn                        var eventName = args.length \x3e 0 ? args[0] : undefined;\x5cn                        if (eventName) {\x5cn                            var propertySymbol = Zone.__symbol__(\x27ON_PROPERTY\x27 + eventName);\x5cn                            socket[propertySymbol] = proxySocket[propertySymbol];\x5cn                        }\x5cn                    }\x5cn                    return socket[propName].apply(socket, args);\x5cn                };\x5cn            });\x5cn        }\x5cn        else {\x5cn            // we can patch the real socket\x5cn            proxySocket = socket;\x5cn        }\x5cn        patchOnProperties(proxySocket, [\x27close\x27, \x27error\x27, \x27message\x27, \x27open\x27], proxySocketProto);\x5cn        return proxySocket;\x5cn    };\x5cn    var globalWebSocket = _global[\x27WebSocket\x27];\x5cn    for (var prop in WS) {\x5cn        globalWebSocket[prop] = WS[prop];\x5cn    }\x5cn}\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cn/**\x5cn * @fileoverview\x5cn * @suppress {globalThis}\x5cn */\x5cnvar globalEventHandlersEventNames = [\x5cn    \x27abort\x27,\x5cn    \x27animationcancel\x27,\x5cn    \x27animationend\x27,\x5cn    \x27animationiteration\x27,\x5cn    \x27auxclick\x27,\x5cn    \x27beforeinput\x27,\x5cn    \x27blur\x27,\x5cn    \x27cancel\x27,\x5cn    \x27canplay\x27,\x5cn    \x27canplaythrough\x27,\x5cn    \x27change\x27,\x5cn    \x27compositionstart\x27,\x5cn    \x27compositionupdate\x27,\x5cn    \x27compositionend\x27,\x5cn    \x27cuechange\x27,\x5cn    \x27click\x27,\x5cn    \x27close\x27,\x5cn    \x27contextmenu\x27,\x5cn    \x27curechange\x27,\x5cn    \x27dblclick\x27,\x5cn    \x27drag\x27,\x5cn    \x27dragend\x27,\x5cn    \x27dragenter\x27,\x5cn    \x27dragexit\x27,\x5cn    \x27dragleave\x27,\x5cn    \x27dragover\x27,\x5cn    \x27drop\x27,\x5cn    \x27durationchange\x27,\x5cn    \x27emptied\x27,\x5cn    \x27ended\x27,\x5cn    \x27error\x27,\x5cn    \x27focus\x27,\x5cn    \x27focusin\x27,\x5cn    \x27focusout\x27,\x5cn    \x27gotpointercapture\x27,\x5cn    \x27input\x27,\x5cn    \x27invalid\x27,\x5cn    \x27keydown\x27,\x5cn    \x27keypress\x27,\x5cn    \x27keyup\x27,\x5cn    \x27load\x27,\x5cn    \x27loadstart\x27,\x5cn    \x27loadeddata\x27,\x5cn    \x27loadedmetadata\x27,\x5cn    \x27lostpointercapture\x27,\x5cn    \x27mousedown\x27,\x5cn    \x27mouseenter\x27,\x5cn    \x27mouseleave\x27,\x5cn    \x27mousemove\x27,\x5cn    \x27mouseout\x27,\x5cn    \x27mouseover\x27,\x5cn    \x27mouseup\x27,\x5cn    \x27mousewheel\x27,\x5cn    \x27orientationchange\x27,\x5cn    \x27pause\x27,\x5cn    \x27play\x27,\x5cn    \x27playing\x27,\x5cn    \x27pointercancel\x27,\x5cn    \x27pointerdown\x27,\x5cn    \x27pointerenter\x27,\x5cn    \x27pointerleave\x27,\x5cn    \x27pointerlockchange\x27,\x5cn    \x27mozpointerlockchange\x27,\x5cn    \x27webkitpointerlockerchange\x27,\x5cn    \x27pointerlockerror\x27,\x5cn    \x27mozpointerlockerror\x27,\x5cn    \x27webkitpointerlockerror\x27,\x5cn    \x27pointermove\x27,\x5cn    \x27pointout\x27,\x5cn    \x27pointerover\x27,\x5cn    \x27pointerup\x27,\x5cn    \x27progress\x27,\x5cn    \x27ratechange\x27,\x5cn    \x27reset\x27,\x5cn    \x27resize\x27,\x5cn    \x27scroll\x27,\x5cn    \x27seeked\x27,\x5cn    \x27seeking\x27,\x5cn    \x27select\x27,\x5cn    \x27selectionchange\x27,\x5cn    \x27selectstart\x27,\x5cn    \x27show\x27,\x5cn    \x27sort\x27,\x5cn    \x27stalled\x27,\x5cn    \x27submit\x27,\x5cn    \x27suspend\x27,\x5cn    \x27timeupdate\x27,\x5cn    \x27volumechange\x27,\x5cn    \x27touchcancel\x27,\x5cn    \x27touchmove\x27,\x5cn    \x27touchstart\x27,\x5cn    \x27touchend\x27,\x5cn    \x27transitioncancel\x27,\x5cn    \x27transitionend\x27,\x5cn    \x27waiting\x27,\x5cn    \x27wheel\x27\x5cn];\x5cnvar documentEventNames = [\x5cn    \x27afterscriptexecute\x27, \x27beforescriptexecute\x27, \x27DOMContentLoaded\x27, \x27fullscreenchange\x27,\x5cn    \x27mozfullscreenchange\x27, \x27webkitfullscreenchange\x27, \x27msfullscreenchange\x27, \x27fullscreenerror\x27,\x5cn    \x27mozfullscreenerror\x27, \x27webkitfullscreenerror\x27, \x27msfullscreenerror\x27, \x27readystatechange\x27,\x5cn    \x27visibilitychange\x27\x5cn];\x5cnvar windowEventNames = [\x5cn    \x27absolutedeviceorientation\x27,\x5cn    \x27afterinput\x27,\x5cn    \x27afterprint\x27,\x5cn    \x27appinstalled\x27,\x5cn    \x27beforeinstallprompt\x27,\x5cn    \x27beforeprint\x27,\x5cn    \x27beforeunload\x27,\x5cn    \x27devicelight\x27,\x5cn    \x27devicemotion\x27,\x5cn    \x27deviceorientation\x27,\x5cn    \x27deviceorientationabsolute\x27,\x5cn    \x27deviceproximity\x27,\x5cn    \x27hashchange\x27,\x5cn    \x27languagechange\x27,\x5cn    \x27message\x27,\x5cn    \x27mozbeforepaint\x27,\x5cn    \x27offline\x27,\x5cn    \x27online\x27,\x5cn    \x27paint\x27,\x5cn    \x27pageshow\x27,\x5cn    \x27pagehide\x27,\x5cn    \x27popstate\x27,\x5cn    \x27rejectionhandled\x27,\x5cn    \x27storage\x27,\x5cn    \x27unhandledrejection\x27,\x5cn    \x27unload\x27,\x5cn    \x27userproximity\x27,\x5cn    \x27vrdisplyconnected\x27,\x5cn    \x27vrdisplaydisconnected\x27,\x5cn    \x27vrdisplaypresentchange\x27\x5cn];\x5cnvar htmlElementEventNames = [\x5cn    \x27beforecopy\x27, \x27beforecut\x27, \x27beforepaste\x27, \x27copy\x27, \x27cut\x27, \x27paste\x27, \x27dragstart\x27, \x27loadend\x27,\x5cn    \x27animationstart\x27, \x27search\x27, \x27transitionrun\x27, \x27transitionstart\x27, \x27webkitanimationend\x27,\x5cn    \x27webkitanimationiteration\x27, \x27webkitanimationstart\x27, \x27webkittransitionend\x27\x5cn];\x5cnvar mediaElementEventNames = [\x27encrypted\x27, \x27waitingforkey\x27, \x27msneedkey\x27, \x27mozinterruptbegin\x27, \x27mozinterruptend\x27];\x5cnvar ieElementEventNames = [\x5cn    \x27activate\x27,\x5cn    \x27afterupdate\x27,\x5cn    \x27ariarequest\x27,\x5cn    \x27beforeactivate\x27,\x5cn    \x27beforedeactivate\x27,\x5cn    \x27beforeeditfocus\x27,\x5cn    \x27beforeupdate\x27,\x5cn    \x27cellchange\x27,\x5cn    \x27controlselect\x27,\x5cn    \x27dataavailable\x27,\x5cn    \x27datasetchanged\x27,\x5cn    \x27datasetcomplete\x27,\x5cn    \x27errorupdate\x27,\x5cn    \x27filterchange\x27,\x5cn    \x27layoutcomplete\x27,\x5cn    \x27losecapture\x27,\x5cn    \x27move\x27,\x5cn    \x27moveend\x27,\x5cn    \x27movestart\x27,\x5cn    \x27propertychange\x27,\x5cn    \x27resizeend\x27,\x5cn    \x27resizestart\x27,\x5cn    \x27rowenter\x27,\x5cn    \x27rowexit\x27,\x5cn    \x27rowsdelete\x27,\x5cn    \x27rowsinserted\x27,\x5cn    \x27command\x27,\x5cn    \x27compassneedscalibration\x27,\x5cn    \x27deactivate\x27,\x5cn    \x27help\x27,\x5cn    \x27mscontentzoom\x27,\x5cn    \x27msmanipulationstatechanged\x27,\x5cn    \x27msgesturechange\x27,\x5cn    \x27msgesturedoubletap\x27,\x5cn    \x27msgestureend\x27,\x5cn    \x27msgesturehold\x27,\x5cn    \x27msgesturestart\x27,\x5cn    \x27msgesturetap\x27,\x5cn    \x27msgotpointercapture\x27,\x5cn    \x27msinertiastart\x27,\x5cn    \x27mslostpointercapture\x27,\x5cn    \x27mspointercancel\x27,\x5cn    \x27mspointerdown\x27,\x5cn    \x27mspointerenter\x27,\x5cn    \x27mspointerhover\x27,\x5cn    \x27mspointerleave\x27,\x5cn    \x27mspointermove\x27,\x5cn    \x27mspointerout\x27,\x5cn    \x27mspointerover\x27,\x5cn    \x27mspointerup\x27,\x5cn    \x27pointerout\x27,\x5cn    \x27mssitemodejumplistitemremoved\x27,\x5cn    \x27msthumbnailclick\x27,\x5cn    \x27stop\x27,\x5cn    \x27storagecommit\x27\x5cn];\x5cnvar webglEventNames = [\x27webglcontextrestored\x27, \x27webglcontextlost\x27, \x27webglcontextcreationerror\x27];\x5cnvar formEventNames = [\x27autocomplete\x27, \x27autocompleteerror\x27];\x5cnvar detailEventNames = [\x27toggle\x27];\x5cnvar frameEventNames = [\x27load\x27];\x5cnvar frameSetEventNames = [\x27blur\x27, \x27error\x27, \x27focus\x27, \x27load\x27, \x27resize\x27, \x27scroll\x27, \x27messageerror\x27];\x5cnvar marqueeEventNames = [\x27bounce\x27, \x27finish\x27, \x27start\x27];\x5cnvar XMLHttpRequestEventNames = [\x5cn    \x27loadstart\x27, \x27progress\x27, \x27abort\x27, \x27error\x27, \x27load\x27, \x27progress\x27, \x27timeout\x27, \x27loadend\x27,\x5cn    \x27readystatechange\x27\x5cn];\x5cnvar IDBIndexEventNames = [\x27upgradeneeded\x27, \x27complete\x27, \x27abort\x27, \x27success\x27, \x27error\x27, \x27blocked\x27, \x27versionchange\x27, \x27close\x27];\x5cnvar websocketEventNames = [\x27close\x27, \x27error\x27, \x27open\x27, \x27message\x27];\x5cnvar workerEventNames = [\x27error\x27, \x27message\x27];\x5cnvar eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);\x5cnfunction filterProperties(target, onProperties, ignoreProperties) {\x5cn    if (!ignoreProperties) {\x5cn        return onProperties;\x5cn    }\x5cn    var tip = ignoreProperties.filter(function (ip) { return ip.target === target; });\x5cn    if (!tip || tip.length === 0) {\x5cn        return onProperties;\x5cn    }\x5cn    var targetIgnoreProperties = tip[0].ignoreProperties;\x5cn    return onProperties.filter(function (op) { return targetIgnoreProperties.indexOf(op) === -1; });\x5cn}\x5cnfunction patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {\x5cn    // check whether target is available, sometimes target will be undefined\x5cn    // because different browser or some 3rd party plugin.\x5cn    if (!target) {\x5cn        return;\x5cn    }\x5cn    var filteredProperties = filterProperties(target, onProperties, ignoreProperties);\x5cn    patchOnProperties(target, filteredProperties, prototype);\x5cn}\x5cnfunction propertyDescriptorPatch(api, _global) {\x5cn    if (isNode && !isMix) {\x5cn        return;\x5cn    }\x5cn    var supportsWebSocket = typeof WebSocket !== \x27undefined\x27;\x5cn    if (canPatchViaPropertyDescriptor()) {\x5cn        var ignoreProperties = _global.__Zone_ignore_on_properties;\x5cn        // for browsers that we can patch the descriptor:  Chrome & Firefox\x5cn        if (isBrowser) {\x5cn            var internalWindow = window;\x5cn            // in IE/Edge, onProp not exist in window object, but in WindowPrototype\x5cn            // so we need to pass WindowPrototype to check onProp exist or not\x5cn            patchFilteredProperties(internalWindow, eventNames.concat([\x27messageerror\x27]), ignoreProperties, ObjectGetPrototypeOf(internalWindow));\x5cn            patchFilteredProperties(Document.prototype, eventNames, ignoreProperties);\x5cn            if (typeof internalWindow[\x27SVGElement\x27] !== \x27undefined\x27) {\x5cn                patchFilteredProperties(internalWindow[\x27SVGElement\x27].prototype, eventNames, ignoreProperties);\x5cn            }\x5cn            patchFilteredProperties(Element.prototype, eventNames, ignoreProperties);\x5cn            patchFilteredProperties(HTMLElement.prototype, eventNames, ignoreProperties);\x5cn            patchFilteredProperties(HTMLMediaElement.prototype, mediaElementEventNames, ignoreProperties);\x5cn            patchFilteredProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);\x5cn            patchFilteredProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);\x5cn            patchFilteredProperties(HTMLFrameElement.prototype, frameEventNames, ignoreProperties);\x5cn            patchFilteredProperties(HTMLIFrameElement.prototype, frameEventNames, ignoreProperties);\x5cn            var HTMLMarqueeElement_1 = internalWindow[\x27HTMLMarqueeElement\x27];\x5cn            if (HTMLMarqueeElement_1) {\x5cn                patchFilteredProperties(HTMLMarqueeElement_1.prototype, marqueeEventNames, ignoreProperties);\x5cn            }\x5cn            var Worker_1 = internalWindow[\x27Worker\x27];\x5cn            if (Worker_1) {\x5cn                patchFilteredProperties(Worker_1.prototype, workerEventNames, ignoreProperties);\x5cn            }\x5cn        }\x5cn        patchFilteredProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames, ignoreProperties);\x5cn        var XMLHttpRequestEventTarget = _global[\x27XMLHttpRequestEventTarget\x27];\x5cn        if (XMLHttpRequestEventTarget) {\x5cn            patchFilteredProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames, ignoreProperties);\x5cn        }\x5cn        if (typeof IDBIndex !== \x27undefined\x27) {\x5cn            patchFilteredProperties(IDBIndex.prototype, IDBIndexEventNames, ignoreProperties);\x5cn            patchFilteredProperties(IDBRequest.prototype, IDBIndexEventNames, ignoreProperties);\x5cn            patchFilteredProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames, ignoreProperties);\x5cn            patchFilteredProperties(IDBDatabase.prototype, IDBIndexEventNames, ignoreProperties);\x5cn            patchFilteredProperties(IDBTransaction.prototype, IDBIndexEventNames, ignoreProperties);\x5cn            patchFilteredProperties(IDBCursor.prototype, IDBIndexEventNames, ignoreProperties);\x5cn        }\x5cn        if (supportsWebSocket) {\x5cn            patchFilteredProperties(WebSocket.prototype, websocketEventNames, ignoreProperties);\x5cn        }\x5cn    }\x5cn    else {\x5cn        // Safari, Android browsers (Jelly Bean)\x5cn        patchViaCapturingAllTheEvents();\x5cn        patchClass(\x27XMLHttpRequest\x27);\x5cn        if (supportsWebSocket) {\x5cn            apply(api, _global);\x5cn        }\x5cn    }\x5cn}\x5cnfunction canPatchViaPropertyDescriptor() {\x5cn    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, \x27onclick\x27) &&\x5cn        typeof Element !== \x27undefined\x27) {\x5cn        // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364\x5cn        // IDL interface attributes are not configurable\x5cn        var desc = ObjectGetOwnPropertyDescriptor(Element.prototype, \x27onclick\x27);\x5cn        if (desc && !desc.configurable)\x5cn            return false;\x5cn    }\x5cn    var ON_READY_STATE_CHANGE = \x27onreadystatechange\x27;\x5cn    var XMLHttpRequestPrototype = XMLHttpRequest.prototype;\x5cn    var xhrDesc = ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);\x5cn    // add enumerable and configurable here because in opera\x5cn    // by default XMLHttpRequest.prototype.onreadystatechange is undefined\x5cn    // without adding enumerable and configurable will cause onreadystatechange\x5cn    // non-configurable\x5cn    // and if XMLHttpRequest.prototype.onreadystatechange is undefined,\x5cn    // we should set a real desc instead a fake one\x5cn    if (xhrDesc) {\x5cn        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {\x5cn            enumerable: true,\x5cn            configurable: true,\x5cn            get: function () {\x5cn                return true;\x5cn            }\x5cn        });\x5cn        var req = new XMLHttpRequest();\x5cn        var result = !!req.onreadystatechange;\x5cn        // restore original desc\x5cn        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});\x5cn        return result;\x5cn    }\x5cn    else {\x5cn        var SYMBOL_FAKE_ONREADYSTATECHANGE_1 = zoneSymbol(\x27fake\x27);\x5cn        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {\x5cn            enumerable: true,\x5cn            configurable: true,\x5cn            get: function () {\x5cn                return this[SYMBOL_FAKE_ONREADYSTATECHANGE_1];\x5cn            },\x5cn            set: function (value) {\x5cn                this[SYMBOL_FAKE_ONREADYSTATECHANGE_1] = value;\x5cn            }\x5cn        });\x5cn        var req = new XMLHttpRequest();\x5cn        var detectFunc = function () { };\x5cn        req.onreadystatechange = detectFunc;\x5cn        var result = req[SYMBOL_FAKE_ONREADYSTATECHANGE_1] === detectFunc;\x5cn        req.onreadystatechange = null;\x5cn        return result;\x5cn    }\x5cn}\x5cnvar unboundKey = zoneSymbol(\x27unbound\x27);\x5cn// Whenever any eventListener fires, we check the eventListener target and all parents\x5cn// for `onwhatever` properties and replace them with zone-bound functions\x5cn// - Chrome (for now)\x5cnfunction patchViaCapturingAllTheEvents() {\x5cn    var _loop_1 = function (i) {\x5cn        var property = eventNames[i];\x5cn        var onproperty = \x27on\x27 + property;\x5cn        self.addEventListener(property, function (event) {\x5cn            var elt = event.target, bound, source;\x5cn            if (elt) {\x5cn                source = elt.constructor[\x27name\x27] + \x27.\x27 + onproperty;\x5cn            }\x5cn            else {\x5cn                source = \x27unknown.\x27 + onproperty;\x5cn            }\x5cn            while (elt) {\x5cn                if (elt[onproperty] && !elt[onproperty][unboundKey]) {\x5cn                    bound = wrapWithCurrentZone(elt[onproperty], source);\x5cn                    bound[unboundKey] = elt[onproperty];\x5cn                    elt[onproperty] = bound;\x5cn                }\x5cn                elt = elt.parentElement;\x5cn            }\x5cn        }, true);\x5cn    };\x5cn    for (var i = 0; i \x3c eventNames.length; i++) {\x5cn        _loop_1(i);\x5cn    }\x5cn}\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cnfunction eventTargetPatch(_global, api) {\x5cn    var WTF_ISSUE_555 = \x27Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video\x27;\x5cn    var NO_EVENT_TARGET = \x27ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket\x27\x5cn        .split(\x27,\x27);\x5cn    var EVENT_TARGET = \x27EventTarget\x27;\x5cn    var apis = [];\x5cn    var isWtf = _global[\x27wtf\x27];\x5cn    var WTF_ISSUE_555_ARRAY = WTF_ISSUE_555.split(\x27,\x27);\x5cn    if (isWtf) {\x5cn        // Workaround for: https://github.com/google/tracing-framework/issues/555\x5cn        apis = WTF_ISSUE_555_ARRAY.map(function (v) { return \x27HTML\x27 + v + \x27Element\x27; }).concat(NO_EVENT_TARGET);\x5cn    }\x5cn    else if (_global[EVENT_TARGET]) {\x5cn        apis.push(EVENT_TARGET);\x5cn    }\x5cn    else {\x5cn        // Note: EventTarget is not available in all browsers,\x5cn        // if it\x27s not available, we instead patch the APIs in the IDL that inherit from EventTarget\x5cn        apis = NO_EVENT_TARGET;\x5cn    }\x5cn    var isDisableIECheck = _global[\x27__Zone_disable_IE_check\x27] || false;\x5cn    var isEnableCrossContextCheck = _global[\x27__Zone_enable_cross_context_check\x27] || false;\x5cn    var ieOrEdge = isIEOrEdge();\x5cn    var ADD_EVENT_LISTENER_SOURCE = \x27.addEventListener:\x27;\x5cn    var FUNCTION_WRAPPER = \x27[object FunctionWrapper]\x27;\x5cn    var BROWSER_TOOLS = \x27function __BROWSERTOOLS_CONSOLE_SAFEFUNC() { [native code] }\x27;\x5cn    //  predefine all __zone_symbol__ + eventName + true/false string\x5cn    for (var i = 0; i \x3c eventNames.length; i++) {\x5cn        var eventName = eventNames[i];\x5cn        var falseEventName = eventName + FALSE_STR;\x5cn        var trueEventName = eventName + TRUE_STR;\x5cn        var symbol = ZONE_SYMBOL_PREFIX + falseEventName;\x5cn        var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\x5cn        zoneSymbolEventNames$1[eventName] = {};\x5cn        zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;\x5cn        zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;\x5cn    }\x5cn    //  predefine all task.source string\x5cn    for (var i = 0; i \x3c WTF_ISSUE_555.length; i++) {\x5cn        var target = WTF_ISSUE_555_ARRAY[i];\x5cn        var targets = globalSources[target] = {};\x5cn        for (var j = 0; j \x3c eventNames.length; j++) {\x5cn            var eventName = eventNames[j];\x5cn            targets[eventName] = target + ADD_EVENT_LISTENER_SOURCE + eventName;\x5cn        }\x5cn    }\x5cn    var checkIEAndCrossContext = function (nativeDelegate, delegate, target, args) {\x5cn        if (!isDisableIECheck && ieOrEdge) {\x5cn            if (isEnableCrossContextCheck) {\x5cn                try {\x5cn                    var testString = delegate.toString();\x5cn                    if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) {\x5cn                        nativeDelegate.apply(target, args);\x5cn                        return false;\x5cn                    }\x5cn                }\x5cn                catch (error) {\x5cn                    nativeDelegate.apply(target, args);\x5cn                    return false;\x5cn                }\x5cn            }\x5cn            else {\x5cn                var testString = delegate.toString();\x5cn                if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) {\x5cn                    nativeDelegate.apply(target, args);\x5cn                    return false;\x5cn                }\x5cn            }\x5cn        }\x5cn        else if (isEnableCrossContextCheck) {\x5cn            try {\x5cn                delegate.toString();\x5cn            }\x5cn            catch (error) {\x5cn                nativeDelegate.apply(target, args);\x5cn                return false;\x5cn            }\x5cn        }\x5cn        return true;\x5cn    };\x5cn    var apiTypes = [];\x5cn    for (var i = 0; i \x3c apis.length; i++) {\x5cn        var type = _global[apis[i]];\x5cn        apiTypes.push(type && type.prototype);\x5cn    }\x5cn    // vh is validateHandler to check event handler\x5cn    // is valid or not(for security check)\x5cn    patchEventTarget(_global, apiTypes, { vh: checkIEAndCrossContext });\x5cn    api.patchEventTarget = patchEventTarget;\x5cn    return true;\x5cn}\x5cnfunction patchEvent(global, api) {\x5cn    patchEventPrototype(global, api);\x5cn}\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cnfunction registerElementPatch(_global) {\x5cn    if ((!isBrowser && !isMix) || !(\x27registerElement\x27 in _global.document)) {\x5cn        return;\x5cn    }\x5cn    var _registerElement = document.registerElement;\x5cn    var callbacks = [\x27createdCallback\x27, \x27attachedCallback\x27, \x27detachedCallback\x27, \x27attributeChangedCallback\x27];\x5cn    document.registerElement = function (name, opts) {\x5cn        if (opts && opts.prototype) {\x5cn            callbacks.forEach(function (callback) {\x5cn                var source = \x27Document.registerElement::\x27 + callback;\x5cn                var prototype = opts.prototype;\x5cn                if (prototype.hasOwnProperty(callback)) {\x5cn                    var descriptor = ObjectGetOwnPropertyDescriptor(prototype, callback);\x5cn                    if (descriptor && descriptor.value) {\x5cn                        descriptor.value = wrapWithCurrentZone(descriptor.value, source);\x5cn                        _redefineProperty(opts.prototype, callback, descriptor);\x5cn                    }\x5cn                    else {\x5cn                        prototype[callback] = wrapWithCurrentZone(prototype[callback], source);\x5cn                    }\x5cn                }\x5cn                else if (prototype[callback]) {\x5cn                    prototype[callback] = wrapWithCurrentZone(prototype[callback], source);\x5cn                }\x5cn            });\x5cn        }\x5cn        return _registerElement.call(document, name, opts);\x5cn    };\x5cn    attachOriginToPatched(document.registerElement, _registerElement);\x5cn}\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cn/**\x5cn * @fileoverview\x5cn * @suppress {missingRequire}\x5cn */\x5cnZone.__load_patch(\x27util\x27, function (global, Zone, api) {\x5cn    api.patchOnProperties = patchOnProperties;\x5cn    api.patchMethod = patchMethod;\x5cn    api.bindArguments = bindArguments;\x5cn});\x5cnZone.__load_patch(\x27timers\x27, function (global) {\x5cn    var set = \x27set\x27;\x5cn    var clear = \x27clear\x27;\x5cn    patchTimer(global, set, clear, \x27Timeout\x27);\x5cn    patchTimer(global, set, clear, \x27Interval\x27);\x5cn    patchTimer(global, set, clear, \x27Immediate\x27);\x5cn});\x5cnZone.__load_patch(\x27requestAnimationFrame\x27, function (global) {\x5cn    patchTimer(global, \x27request\x27, \x27cancel\x27, \x27AnimationFrame\x27);\x5cn    patchTimer(global, \x27mozRequest\x27, \x27mozCancel\x27, \x27AnimationFrame\x27);\x5cn    patchTimer(global, \x27webkitRequest\x27, \x27webkitCancel\x27, \x27AnimationFrame\x27);\x5cn});\x5cnZone.__load_patch(\x27blocking\x27, function (global, Zone) {\x5cn    var blockingMethods = [\x27alert\x27, \x27prompt\x27, \x27confirm\x27];\x5cn    for (var i = 0; i \x3c blockingMethods.length; i++) {\x5cn        var name_1 = blockingMethods[i];\x5cn        patchMethod(global, name_1, function (delegate, symbol, name) {\x5cn            return function (s, args) {\x5cn                return Zone.current.run(delegate, global, args, name);\x5cn            };\x5cn        });\x5cn    }\x5cn});\x5cnZone.__load_patch(\x27EventTarget\x27, function (global, Zone, api) {\x5cn    // load blackListEvents from global\x5cn    var SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__(\x27BLACK_LISTED_EVENTS\x27);\x5cn    if (global[SYMBOL_BLACK_LISTED_EVENTS]) {\x5cn        Zone[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_BLACK_LISTED_EVENTS];\x5cn    }\x5cn    patchEvent(global, api);\x5cn    eventTargetPatch(global, api);\x5cn    // patch XMLHttpRequestEventTarget\x27s addEventListener/removeEventListener\x5cn    var XMLHttpRequestEventTarget = global[\x27XMLHttpRequestEventTarget\x27];\x5cn    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\x5cn        api.patchEventTarget(global, [XMLHttpRequestEventTarget.prototype]);\x5cn    }\x5cn    patchClass(\x27MutationObserver\x27);\x5cn    patchClass(\x27WebKitMutationObserver\x27);\x5cn    patchClass(\x27IntersectionObserver\x27);\x5cn    patchClass(\x27FileReader\x27);\x5cn});\x5cnZone.__load_patch(\x27on_property\x27, function (global, Zone, api) {\x5cn    propertyDescriptorPatch(api, global);\x5cn    propertyPatch();\x5cn    registerElementPatch(global);\x5cn});\x5cnZone.__load_patch(\x27canvas\x27, function (global) {\x5cn    var HTMLCanvasElement = global[\x27HTMLCanvasElement\x27];\x5cn    if (typeof HTMLCanvasElement !== \x27undefined\x27 && HTMLCanvasElement.prototype &&\x5cn        HTMLCanvasElement.prototype.toBlob) {\x5cn        patchMacroTask(HTMLCanvasElement.prototype, \x27toBlob\x27, function (self, args) {\x5cn            return { name: \x27HTMLCanvasElement.toBlob\x27, target: self, cbIdx: 0, args: args };\x5cn        });\x5cn    }\x5cn});\x5cnZone.__load_patch(\x27XHR\x27, function (global, Zone) {\x5cn    // Treat XMLHttpRequest as a macrotask.\x5cn    patchXHR(global);\x5cn    var XHR_TASK = zoneSymbol(\x27xhrTask\x27);\x5cn    var XHR_SYNC = zoneSymbol(\x27xhrSync\x27);\x5cn    var XHR_LISTENER = zoneSymbol(\x27xhrListener\x27);\x5cn    var XHR_SCHEDULED = zoneSymbol(\x27xhrScheduled\x27);\x5cn    var XHR_URL = zoneSymbol(\x27xhrURL\x27);\x5cn    function patchXHR(window) {\x5cn        var XMLHttpRequestPrototype = XMLHttpRequest.prototype;\x5cn        function findPendingTask(target) {\x5cn            return target[XHR_TASK];\x5cn        }\x5cn        var oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\x5cn        var oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\x5cn        if (!oriAddListener) {\x5cn            var XMLHttpRequestEventTarget = window[\x27XMLHttpRequestEventTarget\x27];\x5cn            if (XMLHttpRequestEventTarget) {\x5cn                var XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;\x5cn                oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\x5cn                oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\x5cn            }\x5cn        }\x5cn        var READY_STATE_CHANGE = \x27readystatechange\x27;\x5cn        var SCHEDULED = \x27scheduled\x27;\x5cn        function scheduleTask(task) {\x5cn            XMLHttpRequest[XHR_SCHEDULED] = false;\x5cn            var data = task.data;\x5cn            var target = data.target;\x5cn            // remove existing event listener\x5cn            var listener = target[XHR_LISTENER];\x5cn            if (!oriAddListener) {\x5cn                oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];\x5cn                oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\x5cn            }\x5cn            if (listener) {\x5cn                oriRemoveListener.call(target, READY_STATE_CHANGE, listener);\x5cn            }\x5cn            var newListener = target[XHR_LISTENER] = function () {\x5cn                if (target.readyState === target.DONE) {\x5cn                    // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with\x5cn                    // readyState=4 multiple times, so we need to check task state here\x5cn                    if (!data.aborted && XMLHttpRequest[XHR_SCHEDULED] && task.state === SCHEDULED) {\x5cn                        task.invoke();\x5cn                    }\x5cn                }\x5cn            };\x5cn            oriAddListener.call(target, READY_STATE_CHANGE, newListener);\x5cn            var storedTask = target[XHR_TASK];\x5cn            if (!storedTask) {\x5cn                target[XHR_TASK] = task;\x5cn            }\x5cn            sendNative.apply(target, data.args);\x5cn            XMLHttpRequest[XHR_SCHEDULED] = true;\x5cn            return task;\x5cn        }\x5cn        function placeholderCallback() { }\x5cn        function clearTask(task) {\x5cn            var data = task.data;\x5cn            // Note - ideally, we would call data.target.removeEventListener here, but it\x27s too late\x5cn            // to prevent it from firing. So instead, we store info for the event listener.\x5cn            data.aborted = true;\x5cn            return abortNative.apply(data.target, data.args);\x5cn        }\x5cn        var openNative = patchMethod(XMLHttpRequestPrototype, \x27open\x27, function () { return function (self, args) {\x5cn            self[XHR_SYNC] = args[2] == false;\x5cn            self[XHR_URL] = args[1];\x5cn            return openNative.apply(self, args);\x5cn        }; });\x5cn        var XMLHTTPREQUEST_SOURCE = \x27XMLHttpRequest.send\x27;\x5cn        var sendNative = patchMethod(XMLHttpRequestPrototype, \x27send\x27, function () { return function (self, args) {\x5cn            if (self[XHR_SYNC]) {\x5cn                // if the XHR is sync there is no task to schedule, just execute the code.\x5cn                return sendNative.apply(self, args);\x5cn            }\x5cn            else {\x5cn                var options = {\x5cn                    target: self,\x5cn                    url: self[XHR_URL],\x5cn                    isPeriodic: false,\x5cn                    delay: null,\x5cn                    args: args,\x5cn                    aborted: false\x5cn                };\x5cn                return scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);\x5cn            }\x5cn        }; });\x5cn        var abortNative = patchMethod(XMLHttpRequestPrototype, \x27abort\x27, function () { return function (self) {\x5cn            var task = findPendingTask(self);\x5cn            if (task && typeof task.type == \x27string\x27) {\x5cn                // If the XHR has already completed, do nothing.\x5cn                // If the XHR has already been aborted, do nothing.\x5cn                // Fix #569, call abort multiple times before done will cause\x5cn                // macroTask task count be negative number\x5cn                if (task.cancelFn == null || (task.data && task.data.aborted)) {\x5cn                    return;\x5cn                }\x5cn                task.zone.cancelTask(task);\x5cn            }\x5cn            // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no\x5cn            // task\x5cn            // to cancel. Do nothing.\x5cn        }; });\x5cn    }\x5cn});\x5cnZone.__load_patch(\x27geolocation\x27, function (global) {\x5cn    /// GEO_LOCATION\x5cn    if (global[\x27navigator\x27] && global[\x27navigator\x27].geolocation) {\x5cn        patchPrototype(global[\x27navigator\x27].geolocation, [\x27getCurrentPosition\x27, \x27watchPosition\x27]);\x5cn    }\x5cn});\x5cnZone.__load_patch(\x27PromiseRejectionEvent\x27, function (global, Zone) {\x5cn    // handle unhandled promise rejection\x5cn    function findPromiseRejectionHandler(evtName) {\x5cn        return function (e) {\x5cn            var eventTasks = findEventTasks(global, evtName);\x5cn            eventTasks.forEach(function (eventTask) {\x5cn                // windows has added unhandledrejection event listener\x5cn                // trigger the event listener\x5cn                var PromiseRejectionEvent = global[\x27PromiseRejectionEvent\x27];\x5cn                if (PromiseRejectionEvent) {\x5cn                    var evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });\x5cn                    eventTask.invoke(evt);\x5cn                }\x5cn            });\x5cn        };\x5cn    }\x5cn    if (global[\x27PromiseRejectionEvent\x27]) {\x5cn        Zone[zoneSymbol(\x27unhandledPromiseRejectionHandler\x27)] =\x5cn            findPromiseRejectionHandler(\x27unhandledrejection\x27);\x5cn        Zone[zoneSymbol(\x27rejectionHandledHandler\x27)] =\x5cn            findPromiseRejectionHandler(\x27rejectionhandled\x27);\x5cn    }\x5cn});\x5cn\x5cn/**\x5cn * @license\x5cn * Copyright Google Inc. All Rights Reserved.\x5cn *\x5cn * Use of this source code is governed by an MIT-style license that can be\x5cn * found in the LICENSE file at https://angular.io/license\x5cn */\x5cn\x5cn})));\x5cn\x22,\x22/**\x5cn * This file includes polyfills needed by Angular and is loaded before the app.\x5cn * You can add your own extra polyfills to this file.\x5cn *\x5cn * This file is divided into 2 sections:\x5cn *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.\x5cn *   2. Application imports. Files imported after ZoneJS that should be loaded before your main\x5cn *      file.\x5cn *\x5cn * The current setup is for so-called \x5c\x22evergreen\x5c\x22 browsers; the last versions of browsers that\x5cn * automatically update themselves. This includes Safari \x3e= 10, Chrome \x3e= 55 (including Opera),\x5cn * Edge \x3e= 13 on the desktop, and iOS 10 and Chrome on mobile.\x5cn *\x5cn * Learn more in https://angular.io/docs/ts/latest/guide/browser-support.html\x5cn */\x5cn\x5cn/***************************************************************************************************\x5cn * BROWSER POLYFILLS\x5cn */\x5cn\x5cn/** IE9, IE10 and IE11 requires all of the following polyfills. **/\x5cn// import \x27core-js/es6/symbol\x27;\x5cn// import \x27core-js/es6/object\x27;\x5cn// import \x27core-js/es6/function\x27;\x5cn// import \x27core-js/es6/parse-int\x27;\x5cn// import \x27core-js/es6/parse-float\x27;\x5cn// import \x27core-js/es6/number\x27;\x5cn// import \x27core-js/es6/math\x27;\x5cn// import \x27core-js/es6/string\x27;\x5cn// import \x27core-js/es6/date\x27;\x5cn// import \x27core-js/es6/array\x27;\x5cn// import \x27core-js/es6/regexp\x27;\x5cn// import \x27core-js/es6/map\x27;\x5cn// import \x27core-js/es6/weak-map\x27;\x5cn// import \x27core-js/es6/set\x27;\x5cn\x5cn/** IE10 and IE11 requires the following for NgClass support on SVG elements */\x5cn// import \x27classlist.js\x27;  // Run `npm install --save classlist.js`.\x5cn\x5cn/** IE10 and IE11 requires the following for the Reflect API. */\x5cn// import \x27core-js/es6/reflect\x27;\x5cn\x5cn\x5cn/** Evergreen browsers require these. **/\x5cn// Used for reflect-metadata in JIT. If you use AOT (and only Angular decorators), you can remove.\x5cnimport \x27core-js/es7/reflect\x27;\x5cn\x5cn\x5cn/**\x5cn * Web Animations `@angular/platform-browser/animations`\x5cn * Only required if AnimationBuilder is used within the application and using IE/Edge or Safari.\x5cn * Standard animation support in Angular DOES NOT require any polyfills (as of Angular 6.0).\x5cn **/\x5cn// import \x27web-animations-js\x27;  // Run `npm install --save web-animations-js`.\x5cn\x5cn/**\x5cn * By default, zone.js will patch all possible macroTask and DomEvents\x5cn * user can disable parts of macroTask/DomEvents patch by setting following flags\x5cn */\x5cn\x5cn // (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame\x5cn // (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick\x5cn // (window as any).__zone_symbol__BLACK_LISTED_EVENTS = [\x27scroll\x27, \x27mousemove\x27]; // disable patch specified eventNames\x5cn\x5cn /*\x5cn * in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js\x5cn * with the following flag, it will bypass `zone.js` patch for IE/Edge\x5cn */\x5cn// (window as any).__Zone_enable_cross_context_check = true;\x5cn\x5cn/***************************************************************************************************\x5cn * Zone JS is required by default for Angular itself.\x5cn */\x5cnimport \x27zone.js/dist/zone\x27;  // Included with Angular CLI.\x5cn\x5cn\x5cn\x5cn/***************************************************************************************************\x5cn * APPLICATION IMPORTS\x5cn */\x5cn\x5cn// import \x27hammerjs/hammer\x27;\x5cn\x22],\x22sourceRoot\x22:\x22\x22}'}